[
  {
    "id": "632223619",
    "title": "React 如何实现超大文件的上传和下载",
    "date": "2022-05-23",
    "tags": [
      "react"
    ],
    "fileName": "React 如何实现超大文件的上传和下载.md",
    "content": "\n## 背景\n\n文件传输是一个常见的需求。对于大文件的下载和上传，直接使用传统的方式可能会遇到性能和用户体验方面的问题。幸运的是，前端技术提供了一些高效的解决方案：文件流操作和切片下载与上传。本文将深入探讨这些技术，帮助你理解它们的原理和实现方法，以优化文件传输效率和提升用户体验。\n\n## 一、前端文件流操作\n\n在前端开发中，文件流操作是指通过数据流的方式处理文件，对文件进行读取、写入和展示等操作。下面详细介绍了前端文件流操作的几个基本概念和技术。\n\n### 数据流和文件处理的基本概念\n\n数据流是指连续的数据序列，可以从一个源传输到另一个目的地。在前端开发中，文件可以被看作数据流的一种形式，可以通过数据流的方式进行处理。文件处理涉及读取和写入文件的操作，包括读取文件的内容、写入数据到文件，以及对文件进行删除、重命名等操作。\n\n### Blob 对象和 ArrayBuffer：处理二进制数据\n\n在前端处理文件时，经常需要处理二进制数据。Blob（Binary Large Object）对象是用来表示二进制数据的一个接口，可以存储大量的二进制数据。Blob 对象可以通过构造函数进行创建，也可以通过其他 API 生成，例如通过 FormData 对象获取上传的文件。而 ArrayBuffer 是 JavaScript 中的一个对象类型，用于表示一个通用的、固定长度的二进制数据缓冲区。我们可以通过 ArrayBuffer 来操作和处理文件的二进制数据。\n\n代码如下：\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction FileInput() {\n  const [fileContent, setFileContent] = useState('');\n  // 读取文件内容到ArrayBuffer\n  function readFileToArrayBuffer(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      // 堆代码 duidaima.com\n      // 注册文件读取完成后的回调函数\n      reader.onload = function (event) {\n        const arrayBuffer = event.target.result;\n        resolve(arrayBuffer);\n      };\n      // 读取文件内容到ArrayBuffer\n      reader.readAsArrayBuffer(file);\n    });\n  }\n  // 将ArrayBuffer转为十六进制字符串\n  function arrayBufferToHexString(arrayBuffer) {\n    const uint8Array = new Uint8Array(arrayBuffer);\n    let hexString = '';\n    for (let i = 0; i < uint8Array.length; i++) {\n      const hex = uint8Array[i].toString(16).padStart(2, '0');\n      hexString += hex;\n    }\n    return hexString;\n  }\n  // 处理文件选择事件\n  function handleFileChange(event) {\n    const file = event.target.files[0]; // 获取选中的文件\n    if (file) {\n      readFileToArrayBuffer(file)\n        .then((arrayBuffer) => {\n          const hexString = arrayBufferToHexString(arrayBuffer);\n          setFileContent(hexString);\n        })\n        .catch((error) => {\n          console.error('文件读取失败:', error);\n        });\n    } else {\n      setFileContent('请选择一个文件');\n    }\n  }\n  return (\n    <div>\n      <input type=\"file\" onChange={handleFileChange} />\n      <div>\n        <h4>文件内容：</h4>\n        <pre>{fileContent}</pre>\n      </div>\n    </div>\n  );\n}\n\nexport default FileInput;\n```\n\n上面代码里，我们创建了一个名为 FileInput 的函数式组件。该组件包含一个文件选择框和一个用于显示文件内容的 <pre> 元素。当用户选择文件时，通过 FileReader 将文件内容读取为 ArrayBuffer，然后将 ArrayBuffer 转换为十六进制字符串，并将结果显示在页面上。\n\n### 使用 FileReader 进行文件读取\n\nFileReader 是前端浏览器提供的一个 API，用于读取文件内容。通过 FileReader，我们可以通过异步方式读取文件，并将文件内容转换为可用的数据形式，比如文本数据或二进制数据。FileReader 提供了一些读取文件的方法，例如 readAsText()、readAsArrayBuffer() 等，可以根据需要选择合适的方法来读取文件内容。\n\n### 将文件流展示在前端页面中\n\n一旦我们成功地读取了文件的内容，就可以将文件流展示在前端页面上。具体的展示方式取决于文件的类型。例如，对于文本文件，可以直接将其内容显示在页面的文本框或区域中；对于图片文件，可以使用 <img> 标签展示图片；对于音视频文件，可以使用 <video> 或 <audio> 标签来播放。通过将文件流展示在前端页面上，我们可以实现在线预览和查看文件内容的功能。\n\n好的，这一部分就基本介绍完毕，总结一下。前端文件操作流是处理大型文件的一种常见方式，他可以通过数据流的方式对文件进行操作。Blob对象 和 ArrayBuffer是处理二进制数据的重要工具。而 FileReader则是读取文件内容的的关键组件。通过这些技术，我们可以方便的在前端页面上进行操作或者文件展示。\n\n## 二、文件切片下载\n\n这一步就进入到我们今天文章主题了，先来主要的看下流程:\ngraph LR\nA(开始) --> B{选择文件}\nB -- 用户选择文件 --> C[切割文件为多个切片]\nC --> D{上传切片}\nD -- 上传完成 --> E[合并切片为完整文件]\nE -- 文件合并完成 --> F(上传成功)\nD -- 上传中断 --> G{保存上传进度}\nG -- 上传恢复 --> D\n\nG -- 取消上传 --> H(上传取消)\n\n### 传统文件下载的性能问题\n\n文件切片下载是一种提升文件下载效率的技术，通过将大文件分割成多个小片段（切片），并使用多个并发请求同时下载这些切片，从而加快整体下载速度。传统的文件下载方式对于大文件来说存在性能问题。当用户请求下载一个大文件时，服务器需要将整个文件发送给客户端。这会导致以下几个问题：\n\n1. 较长的等待时间：大文件需要较长的时间来传输到客户端，用户需要等待很长时间才能开始使用文件。\n2. 网络阻塞：由于下载过程中占用了网络带宽，其他用户可能会遇到下载速度慢的问题。\n3. 断点续传困难：如果下载过程中出现网络故障或者用户中断下载，需要重新下载整个文件，无法继续之前的下载进度。\n\n### 利用文件切片提升下载效率\n\n文件切片下载通过将文件分割成多个小片段，每个片段大小通常在几百KB到几MB之间。然后客户端通过多个并发请求同时下载这些片段。这样做的好处是：\n\n![1.jpg](https://free4.yunpng.top/2025/02/27/67bfb865ba8df.jpg)\n\n快速启动：客户端可以快速开始下载，因为只需要下载第一个切片即可。\n并发下载：通过使用多个并发请求下载切片，可以充分利用带宽，并提高整体下载速度。\n断点续传：如果下载中断，客户端只需要重新下载中断的切片，而不需要重新下载整个文件。\n\n切片上传代码示例：\n\n```jsx\nconst [selectedFile, setSelectedFile] = useState(null);\nconst [progress, setProgress] = useState(0);\n// 处理文件选择事件\nfunction handleFileChange(event) {\n  setSelectedFile(event.target.files[0]);\n}\n// 处理文件上传事件\nfunction handleFileUpload() {\n  if (selectedFile) {\n    // 计算切片数量和每个切片的大小\n    const fileSize = selectedFile.size;\n    const chunkSize = 1024 * 1024; // 设置切片大小为1MB\n    const totalChunks = Math.ceil(fileSize / chunkSize);\n    // 创建FormData对象，并添加文件信息\n    const formData = new FormData();\n    formData.append('file', selectedFile);\n    formData.append('totalChunks', totalChunks);\n    // 循环上传切片\n    for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\n      const start = chunkNumber * chunkSize;\n      const end = Math.min(start + chunkSize, fileSize);\n      const chunk = selectedFile.slice(start, end);\n      formData.append(`chunk-${chunkNumber}`, chunk, selectedFile.name);\n    }\n    // 发起文件上传请求\n    axios\n      .post('/upload', formData, {\n        onUploadProgress: (progressEvent) => {\n          const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);\n          setProgress(progress);\n        },\n      })\n      .then((response) => {\n        console.log('文件上传成功:', response.data);\n      })\n      .catch((error) => {\n        console.error('文件上传失败:', error);\n      });\n  }\n}\n```\n\n当涉及到切片上传和下载时，前端使用的技术通常是基于前端库或框架提供的文件处理功能，结合后端服务实现。\n\n上面代码里我们提到了文件如何切片上传。\n当用户选择文件后，通过 handleFileChange 函数处理文件选择事件，将选择的文件保存在 selectedFile 状态中。\n当用户点击上传按钮时，通过 handleFileUpload 函数处理文件上传事件。\n\n在 handleFileUpload 函数中，计算切片数量和每个切片的大小，并创建一个 FormData 对象用于存储文件信息和切片数据。\n\n### 实现客户端切片下载的方案\n\n实现客户端切片下载的基本方案如下：\n\n1. 服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。\n2. 客户端发送请求获取切片列表，同时开始下载第一个切片。\n3. 客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。\n4. 当所有切片都下载完成后，客户端将下载的数据合并为完整的文件。\n\n代码示例：\n\n```jsx\nfunction downloadFile() {\n  // 发起文件下载请求\n  fetch('/download', {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n    .then((response) => response.json())\n    .then((data) => {\n      const totalSize = data.totalSize;\n      const totalChunks = data.totalChunks;\n      let downloadedChunks = 0;\n      let chunks = [];\n      // 下载每个切片\n      for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\n        fetch(`/download/${chunkNumber}`, {\n          method: 'GET',\n        })\n          .then((response) => response.blob())\n          .then((chunk) => {\n            downloadedChunks++;\n            chunks.push(chunk);\n            // 当所有切片都下载完成时\n            if (downloadedChunks === totalChunks) {\n              // 合并切片\n              const mergedBlob = new Blob(chunks);\n              // 创建对象 URL，生成下载链接\n              const downloadUrl = window.URL.createObjectURL(mergedBlob);\n              // 创建 <a> 元素并设置属性\n              const link = document.createElement('a');\n              link.href = downloadUrl;\n              link.setAttribute('download', 'file.txt');\n              // 模拟点击下载\n              link.click();\n              // 释放资源\n              window.URL.revokeObjectURL(downloadUrl);\n            }\n          });\n      }\n    })\n    .catch((error) => {\n      console.error('文件下载失败:', error);\n    });\n}\n```\n\n我们看下代码，首先使用 BLOB 对象创建一共对象 URL，用于生成下载连接，然后创建 a 标签并且设置 href 的属性为刚刚创建的对象 URL,继续设置 a 标签的 download 属性是文件名，方便点击的时候自动下载文件。\n\n### 显示下载进度和完成状态\n\n为了显示下载进度和完成状态，可以在客户端实现以下功能：\n显示进度条：客户端可以通过监听每个切片的下载进度来计算整体下载进度，并实时更新进度条的显示。\n显示完成状态：当所有切片都下载完成后，客户端可以显示下载完成的状态，例如显示一个完成的图标或者文本。\n\n这里我们可以继续接着切片上传代码示例里的继续写。\n代码示例：\n\n```jsx\n\n// 处理文件下载事件\nfunction handleFileDownload() {\n  axios.get('/download', {\n    responseType: 'blob',\n    onDownloadProgress: progressEvent => {\n      const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);\n      setProgress(progress);\n    }\n  })\n    .then(response => {\n      // 创建一个临时的URL对象用于下载\n      const url = window.URL.createObjectURL(new Blob([response.data]));\n      const link = document.createElement('a');\n      link.href = url;\n      link.setAttribute('download', 'file.txt');\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    })\n    .catch(error => {\n      console.error('文件下载失败:', error);\n    });\n}\n\n\n<button onClick={handleFileDownload}>下载文件</button>\n  <div>进度：{progress}%</div>\n```\n\n1. 当用户点击下载按钮时，通过 handleFileDownload 函数处理文件下载事件。\n2. 在 handleFileDownload 函数中，使用 axios 库发起文件下载请求，并设置 responseType: 'blob' 表示返回二进制数据。\n3. 通过监听 onDownloadProgress 属性获取下载进度，并更新进度条的显示。\n4. 下载完成后，创建一个临时的 URL 对象用于下载，并通过动态创建 <a> 元素模拟点击下载。\n\n## 三、大文件上传的问题与解决方案\n\n### 传统的文件上传方式存在的问题\n\n1. 大文件上传耗时长，容易导致请求超时。\n2. 占用服务器和网络带宽资源，可能影响其他用户的访问速度。\n3. 如果上传中断，需要重新上传整个文件，效率低下。\n4. 难以实现上传进度的显示和控制。\n\n### 前端文件切片上传的优势\n\n1. 将大文件分割为更小的文件切片，分多次上传，提高上传效率和稳定性。\n2. 提供上传进度的监控和展示，提高用户体验。\n3. 充分利用浏览器的并发上传能力，减轻服务器负担。\n4. 实现断点续传功能，避免重复上传已上传的部分。\n\n### 实现前端切片上传的方法\n\n1. 使用 JavaScript 的 `File API` 获取文件对象，并使用 `Blob.prototype.slice()` 方法将文件切割为多个切片。\n2. 使用 FormData 对象将切片数据通过 AJAX 或 Fetch API 发送到服务器。\n3. 在后端服务器上接收切片并保存到临时存储中，等待后续合并。\n4. 在客户端通过监听上传进度事件，在进度条或提示中展示上传进度。\n\n代码示例：\n\n```jsx\n\nconst [file, setFile] = useState(null);  //用来存放我本地上传的文件\nconst chunkSize = 1024 * 1024; // 1MB 切片大小\nconst upload = () => {\n  if (!file) {\n    alert(\"请选择要上传的文件！\");\n    return;\n  }\n  const chunkSize = 1024 * 1024; // 1MB\n  let start = 0;\n  let end = Math.min(chunkSize, file.size);\n  while (start < file.size) {\n    const chunk = file.slice(start, end);\n\n    // 创建FormData对象\n    const formData = new FormData();\n    formData.append('file', chunk);\n    // 发送切片到服务器\n    fetch('上传接口xxxx', {\n      method: 'POST',\n      body: formData\n    })\n      .then(response => response.json())\n      .then(data => {\n        console.log(data);\n        // 处理响应结果\n      })\n      .catch(error => {\n        console.error(error);\n        // 处理错误\n      });\n    start = end;\n    end = Math.min(start + chunkSize, file.size);\n  }\n};\n\nreturn (\n  <div>\n  <input type=\"file\" onChange={handleFileChange} />\n  <button onClick={upload}>上传</button>\n  </div>\n);\n```\n\n在上面的代码中，创建了一个名为 Upload 的函数组件。它使用了 React 的 useState 钩子来管理选中的文件。通过 onChange 事件监听文件输入框的变化，并在 handleFileChange 函数中获取选择的文件，并更新 file 状态。\n\n点击`上传`按钮时，调用 upload 函数。它与之前的示例代码类似，将文件切割为多个大小相等的切片，并使用 FormData 对象和 fetch 函数发送切片数据到服务器。\n\n### 实现断点续传的技术：记录和恢复上传状态\n\n在前端，可以使用 localStorage 或 sessionStorage 来存储已上传的切片信息，包括已上传的切片索引、切片大小等。每次上传前，先检查本地存储中是否存在已上传的切片信息，若存在，则从断点处继续上传。在后端，可以使用一个临时文件夹或数据库来记录已接收到的切片信息，包括已上传的切片索引、切片大小等。在上传完成前，保存上传状态，以便在上传中断后能够恢复上传进度。\n\n```jsx\nimport React, { useEffect, useRef, useState } from 'react';\n\nfunction Upload() {\n  const [file, setFile] = useState(null);\n  const [uploadedChunks, setUploadedChunks] = useState([]);\n  const [uploading, setUploading] = useState(false);\n  const uploadRequestRef = useRef();\n  const handleFileChange = (event) => {\n    const selectedFile = event.target.files[0];\n    setFile(selectedFile);\n  };\n  const uploadChunk = (chunk) => {\n    // 创建FormData对象\n    const formData = new FormData();\n    formData.append('file', chunk);\n    // 发送切片到服务器\n    return fetch('your-upload-url', {\n      method: 'POST',\n      body: formData,\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        console.log(data);\n        // 处理响应结果\n        return data;\n      });\n  };\n  const upload = async () => {\n    if (!file) {\n      alert('请选择要上传的文件！');\n      return;\n    }\n    const chunkSize = 1024 * 1024; // 1MB\n    const totalChunks = Math.ceil(file.size / chunkSize);\n    let start = 0;\n    let end = Math.min(chunkSize, file.size);\n    setUploading(true);\n    for (let i = 0; i < totalChunks; i++) {\n      const chunk = file.slice(start, end);\n      const uploadedChunkIndex = uploadedChunks.indexOf(i);\n      if (uploadedChunkIndex === -1) {\n        try {\n          const response = await uploadChunk(chunk);\n          setUploadedChunks((prevChunks) => [...prevChunks, i]);\n          // 保存已上传的切片信息到本地存储\n          localStorage.setItem('uploadedChunks', JSON.stringify(uploadedChunks));\n        } catch (error) {\n          console.error(error);\n          // 处理错误\n        }\n      }\n      start = end;\n      end = Math.min(start + chunkSize, file.size);\n    }\n    setUploading(false);\n    // 上传完毕，清除本地存储的切片信息\n    localStorage.removeItem('uploadedChunks');\n  };\n  useEffect(() => {\n    const storedUploadedChunks = localStorage.getItem('uploadedChunks');\n    if (storedUploadedChunks) {\n      setUploadedChunks(JSON.parse(storedUploadedChunks));\n    }\n  }, []);\n  return (\n    <div>\n      <input type=\"file\" onChange={handleFileChange} />\n      <button onClick={upload} disabled={uploading}>\n        {uploading ? '上传中...' : '上传'}\n      </button>\n    </div>\n  );\n}\n```\n\n首先，使用 useState 钩子创建了一个 uploadedChunks 状态来保存已上传的切片索引数组。初始值为空数组。\n然后，我们使用 useRef 钩子创建了一个 uploadRequestRef 引用，用于存储当前的上传请求。\n在 handleFileChange 函数中，我们更新了 file 状态以选择要上传的文件。\n在 uploadChunk 函数中，我们发送切片到服务器，并返回一个 Promise 对象来处理响应结果。\n在 upload 函数中，我们添加了断点续传的逻辑。首先，我们获取切片的总数，并设置 uploading 状态为 true 来禁用上传按钮。\n然后，我们使用 for 循环遍历所有切片。对于每个切片，我们检查 uploadedChunks 数组中是否已经包含该索引，如果不包含，则进行上传操作。\n在上传切片之后，我们将已上传的切片索引添加到 uploadedChunks 数组，并使用 localStorage 保存已上传的切片信息。\n最后，在上传完毕后，我们将 uploading 状态设为 false，并清除本地存储的切片信息。\n\n在实现大文件上传时要考虑服务器端的处理能力和存储空间，以及安全性问题。同时，为了保障断点续传的准确性，应该尽量避免并发上传相同文件的情况，可以采用文件唯一标识符或用户会话标识符进行区分。\n\n## 四、优化用户体验：切片下载与上传的应用场景\n\n### 后台管理系统中的文件下载和上传\n\n文件下载：在后台管理系统中，用户可能需要下载大型文件，如报表、日志文件、数据库备份等。通过将文件切片下载，可以提高下载速度和稳定性，同时允许用户中断下载并从中断处继续下载。\n\n文件上传：后台管理系统中，用户可能需要上传大型文件，如数据导入、文件备份等。使用切片上传可以提高上传效率，分批上传文件切片，并显示上传进度，使用户能够了解上传的状态。\n\n### 图片/视频上传和预览：\n\n图片上传和预览：在图片上传场景中，用户可以选择多张图片进行上传。通过切片上传，可以加快图片上传速度，并实时显示上传进度。同时，在上传完成后，可以提供预览功能，让用户可以立即查看上传的图片。\n\n视频上传和预览：对于较大的视频文件，切片上传可以确保上传过程可靠且高效。同时，可以实现上传进度的实时展示。上传完成后，通过切片下载技术，用户可以流畅地观看视频，无需等待整个文件下载完成。\n\n### 云存储和云盘应用中的文件操作\n\n文件分块上传：云存储和云盘应用通常需要处理大量文件的上传。通过切片上传可以提高上传速度和稳定性，并允许用户中断并继续上传。\n文件分块下载：当用户需要下载云存储或云盘中的大型文件时，可以使用切片下载技术，加快下载速度并提供中断恢复功能。\n文件预览和在线编辑：通过将文件切片并进行预览，在线编辑，可以提供更好的用户体验。用户可以在不需完全下载文件的情况下，直接预览和编辑文件。\n",
    "wordCount": 3701
  },
  {
    "id": "1814315346",
    "title": "class-transformer 实践",
    "date": "2020-12-14",
    "tags": [
      "typescript",
      "class-transformer"
    ],
    "fileName": "class-transformer 实践.md",
    "content": "\n## 为什么要使用这个库\n\n比如，我们在后台管理系统中要发布一篇文章，我们只需创建一个普通的平面对象，然后将所有填写的标题、内容等信息给到这个普通对象。但是，如果这个普通对象若是转为对应的类对象，则会出现以下问题：\n\n代码：\n\n```ts\nimport { plainToClass } from 'class-transformer';\nimport { validate } from 'class-validator';\nimport Express from 'express';\n\nimport Article from './model/Article';\nimport articleRoute from './routes/articleRoute';\n\nconst app = Express();\n\napp.use('/api/article', articleRoute);\n\n// 约束为平面对象\nconst article: any = {};\n\narticle.title = '12345';\narticle.content = '123';\narticle.publishTime = new Date();\n// 下面的属性是必须的，但是这里进行注释\n// article.tagList = ['12']\n\n// 按理说，这里应该要输出缺失了tagList这个属性的信息\nvalidate(article).then((errors) => {\n  console.log(errors);\n});\n\napp.listen(3000, () => console.log('服务已开启！'));\n```\n\n运行结果（没有捕获到任何信息）：\n\n![1.png](https://free4.yunpng.top/2025/02/27/67bfb1b1c37a5.png)\n\n因此，我们需要对平面对象进行转换，才可结合class-validator对类属性信息进行约束。\n\n## 安装\n\n```ts\nyarn add class-transformer\n```\n\n## 使用\n\n```ts\nimport { plainToClass } from 'class-transformer';\nimport { validate } from 'class-validator';\nimport Express from 'express';\n\nimport Article from './model/Article';\nimport articleRoute from './routes/articleRoute';\n\nconst app = Express();\n\napp.use('/api/article', articleRoute);\n\n// 这是个平面对象\nconst article: any = {};\n\narticle.title = '12345';\narticle.content = '123';\narticle.publishTime = new Date();\n\nconst newArticle = plainToClass(Article, article);\n\nvalidate(newArticle).then((errors) => {\n  console.log(errors);\n});\n\napp.listen(3000, () => console.log('服务已开启！'));\n```\n\n运行结果:\n\n![2.png](https://free4.yunpng.top/2025/02/27/67bfb1b1ad296.png)\n\n## 没这么简单\n\n如果，一开始给平面对象赋值时的属性的类型就不对呢？\n\n如下代码：\n\n```ts\n// 这是个平面对象\nconst article: any = {};\n\n// 类约束是的类型是字符串，这里赋值数字\narticle.title = 123;\narticle.content = '123';\narticle.publishTime = new Date();\narticle.tagList = ['123'];\n\nconst newArticle = plainToClass(Article, article);\n\nconsole.log(newArticle.title, typeof newArticle.title);\n\nvalidate(newArticle).then((errors) => {\n  console.log(errors);\n});\n```\n\n运行结果：\n\n![3.png](https://free4.yunpng.top/2025/02/27/67bfb1ec0579f.png)\n\n这里可以看出，虽然数据类型对于不上，但还是验证通过了。所以，我们需要使用class-transform提供给我们的运行时的类型验证。\n\n## 使用装饰器@Type进行运行时的类型约束\n\n1. 安装reflect-metadata\n\n```ts\nyarn add reflect-metadata\n```\n\n2. 在入口文件`index.ts`中全局导入\n\n```ts\n// 最好在第一行导入，否则可能依旧会报错\nimport 'reflect-metadata'\nimport Express from 'express'\nimport articleRoute from './routes/articleRoute'\nimport Article from './model/Article'\nimport { validate } from 'class-validator'\nimport { plainToClass } from 'class-transformer'\n...\n```\n\n3. 对Article类进行运行时的类型约束\n\n```ts\nimport { ArrayMinSize, IsDate, IsNotEmpty } from 'class-validator'\nimport { Type } from 'class-transformer'\n\nclass Article {\n\n  @IsNotEmpty({ message: '文章标题不可以为空' })\n  // 运行时的类型约束\n  @Type(() => String)\n  public title: string\n\n  @IsNotEmpty({ message: '文章标签不可以为空' })\n  @ArrayMinSize(1, { message: '文章标签至少有一个' })\n  // 文档建议如果是字符串的数组，使用字符串约束更好，因为js其实不存在数字数组，字符串数组等\n  @Type(() => String)\n  // 上面虽然解决了不是字符串的数组的问题，但是如果传进来的是一个字符串呢？这就太tm难了，所以再在编译时检查一下算了吧，运行时不管了\n  @IsArray({ message: '文章标签必须是一个数组' })\n  public tagList: string[]\n\n  @IsNotEmpty({ message: '发布日期不可以为空' })\n  @IsDate()\n  @Type(() => Date)\n  public publishTime: Date\n\n  @IsNotEmpty({ message: '文章内容不可以为空' })\n  @Type(() => String)\n  public content: string\n}\n\nexport default Article\n```\n\n4. 运行结果\n\n![4.png](https://free4.yunpng.top/2025/02/27/67bfb1ec05754.png)\n\n可以看出，已经将数字类型的title转为了字符串类型，同时也通过了验证。\n",
    "wordCount": 308
  },
  {
    "id": "1155390892",
    "title": "React 工程中 SVG 的高级使用方法",
    "date": "2020-09-09",
    "tags": [
      "react",
      "webpack",
      "svg"
    ],
    "fileName": "React 工程中 SVG 的高级使用方法.md",
    "content": "\n## 比较 low 的做法\n\n打开 create-react-app 的官方文档，它会告诉你使用 svg，将 svg 进行导入（实际导入的是 svg 的路径字符串），然后放到 img 的 src 上。这种方法我们称为将 svg 当做图片使用。\n\n为什么这种方式不好？\n\n比如：无法改变 svg 的颜色\n\n## 使用 svg-sprite-loader（自己配置法）\n\n使用 svg-sprite-loader 要在 webpack.config.js 里配置，但是我们用 create-react-app 搭建起来的项目里没有 webpack 的配置文件。\n\n使用 `yarn eject` 命令，可以把配置文件弄出来。运行后，发现项目下多了两个目录，其中就有 webpack.config.js，我们就可以修改它进行配置。按照官网配置即可。\n\n注意：一定要先进行 git commit，才能运行 eject，否则会无法成功弹出配置。\n\n### 步骤\n\n1. 安装两个 loader\n\n```\nyarn add --dev svg-sprite-loader\nyarn add --dev svgo-loader\n```\n\n2. 在 webpack.config.js 中配置这两个 loader\n\n```js\n{\n  test: /\\.svg$/,\n  use: [\n    { loader: 'svg-sprite-loader', options: {} },\n    { loader: 'svgo-loader', options: {} },\n  ]\n},\n```\n\n3. 使用\n\nApp.tsx\n\n```tsx\nimport x from \"icons/apple.svg\";\n\nconsole.log(x) // 查看浏览器dom树，可以发现多了一个svg\n\n// 多出来的svg如下：\n<svg fill='red'>\n   <use xlinkHref='#apple'/>\n</svg>\n```\n\napple 就是文件名。svg 上还可以直接加 fill 属性来改变颜色。\n引入的 x 如果不使用，就是如果不打印，页面上的图标就看不到了。必须用一下图标才能生效。这是因为treeshaking，意思是，如果你用不上一个东西，我就把他从树上摇下来。react 发现你引入了 x，但是没使用，就会把它删了。\n那我怎么样既能引入也不需要打印呢？\ntreeshaking 不适用于 require，所以可以用 require导入\n\n4. 封装 svg 成 icon 组件\n\n现在每次使用 svg 都要写三句代码，还要 require 引入。避免重复，把它封装成组件。\n\n```tsx\nimport React from 'react';\n\nconst importAll = (requireContext: __WebpackModuleApi.RequireContext) => requireContext.keys().forEach(requireContext);\ntry {\n  importAll(require.context('../icons', true, /\\.svg$/));\n} catch (error) {\n  console.log(error);\n}\n\ntype Props = {\n  name: string;\n};\n\nfunction Icon(props: Props) {\n  return (\n    <svg className=\"icon\">\n      <use xlinkHref={'#' + props.name} />\n    </svg>\n  );\n}\n\nexport default Icon;\n```\n\n说明：\n\n把 require 导入也放进来。但是如果有 100 个 svg，就要写 100 次 require。所以我们选择直接导入一个目录，这个目录里存放所有的 svg。这里封装为 importAll。\n\n但是有报错，说找不到 `__WebpackModuleApi`，这是因为在 ts 里不支持这个的问题。去谷歌搜索解决方案。\n安装：`yarn add --dev @types/webpack-env` 就可以解决。\n\n其他组件想使用 Icon，一句话引入即可 `<Icon name='chart'/>` name 属性是文件名。\n\nIcon 如果想改变颜色，可以直接在 css 里用 fill 改变：\n\n```css\n.icon {\n  fill: rgb(140, 177, 253);\n}\n```\n\n可是有一些svg图标是自带颜色的，在它们的文件里会通过 fill 属性指定颜色。如果是这种情况，就改不了颜色了。我们可以选择手动去它们的 svg 文件里删除 fill 属性，但是如果有很多图标，一个个删除太慢了。\n\nsvgo-loader 有一个功能，可以删除fill属性，只需要把需要的语句添加到配置文件的 svgo-loader 后边的选项options 里边就可以。\nsvgo 就是 svg optimizer 优化器的意思。\n\n```js\n{ loader: 'svgo-loader', options: {\n  plugins:[\n      {removeAttrs: {attrs:'fill'}}\n    ]\n  }\n},\n```\n",
    "wordCount": 682
  },
  {
    "id": "76987253",
    "title": "使用 useReducer 和 Context 实现 redux 的功能",
    "date": "2020-07-24",
    "tags": [
      "react",
      "redux"
    ],
    "fileName": "使用 useReducer 和 Context 实现 redux 的功能.md",
    "content": "\n## 使用 useReducer 和 Context 实现 redux 的功能\n\n步骤：\n\n1. 将数据集中在一个 store 对象\n2. 将所有操作集中在 reducer\n3. 创建一个 Context\n4. 创建对数据的读写 API\n5. 将第4步的内容放到第 3 步的 Context 中\n6. 用 Context.Provider 将 Context 提供给所有组件\n7. 各个组件用 useContext 获取读写 API\n\n代码演示：\n\n```tsx\nimport React, { Dispatch, createContext, useContext, useEffect, useReducer } from 'react';\n\nimport './App.css';\n\ninterface IPersonState {\n  books: string[];\n  movies: string[];\n}\n\ntype IPersonAction = {\n  type: 'getBooks' | 'getMovies';\n  payload: string[];\n};\n\nconst initialState: IPersonState = {\n  books: [],\n  movies: [],\n};\n\nfunction reducer(state: IPersonState = initialState, action: IPersonAction) {\n  if (action.type === 'getBooks') {\n    return { ...state, books: action.payload };\n  }\n  if (action.type === 'getMovies') {\n    return { ...state, movies: action.payload };\n  }\n  return state;\n}\n\nexport interface IContextValue {\n  state: IPersonState;\n  dispatch: Dispatch<IPersonAction>;\n}\n\nconst Context = createContext<IContextValue | undefined>(undefined);\n\nfunction Person() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <Context.Provider value={{ state, dispatch }}>\n      <div>\n        <Books />\n        <Movies />\n      </div>\n    </Context.Provider>\n  );\n}\n\nfunction Books() {\n  const { state, dispatch } = useContext(Context)!;\n  useEffect(() => {\n    fetch('http://api.kuanglinfeng.com')\n      .then((response) => response.json())\n      .then((data) => dispatch({ type: 'getBooks', payload: data.books }));\n  }, []);\n\n  return (\n    <div>\n      <h1>我的书籍</h1>\n      <ul>\n        {state.books!.map((book) => (\n          <li key={book}>{book}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction Movies() {\n  const { state, dispatch } = useContext(Context)!;\n\n  useEffect(() => {\n    fetch('http://api.kuanglinfeng.com')\n      .then((response) => response.json())\n      .then((data) => dispatch({ type: 'getMovies', payload: data.movies }));\n  }, []);\n  return (\n    <div>\n      <h1>我的电影</h1>\n      {state.movies.map((movie) => (\n        <li key={movie}>{movie}</li>\n      ))}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Person />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n如何对 reducer 进行拆分？\n\n答：可将 reducer 写成多个对象的形式，合并所有的子 reducer 时只需要 `{...reducer1, ...reducer2, ...}` 即可\n",
    "wordCount": 121
  },
  {
    "id": "1642119396",
    "title": "Icon 的所有方案",
    "date": "2020-07-21",
    "tags": [
      "icon"
    ],
    "fileName": "Icon 的所有方案.md",
    "content": "\n## icon 的各种做法\n\n1. img 法\n2. background 法\n3. background 合一法\n4. font 法\n5. svg-symbol 法\n6. css 就是干法\n\n### img 法\n\n1. 搞一张图片\n2. 使用`<img src=\"图片路径\"/>`来使用图片\n3. 通过其它 css 属性来控制图片的大小，位置等\n\n优点：可以利用图片默认自动缩放的特性，通过仅设置宽度或者高度来改变图片的大小\n\n### background 法\n\n1. 搞一张图片\n2. 利用 css 属性`background: url(./image.png)`\n3. 通过其它 css 属性来控制图片的大小，位置等\n\n### background 合一法\n\n1. 将几张图片拼成一张图，可以用网上的 css sprites generator 工具\n2. 利用 css 属性`width，height, overflow, background-position`来显示某一张图片\n\n### font 法\n\n使用 icon-font，字体即图标，图标即字体。常用网站：http://iconfont.cn\n\n注意：一般来说，字体图标的 Entity Number 一般都以`&#xe6`开头，因为这一段范围通常不表示任何字符\n\n- inconfont 的 HTML 形式（对应 iconfont.cn 里的 unicode 功能）\n\n用法：\n\n1. 在样式里引入@font-face\n\n```css\n@font-face {\n  font-family: 'iconfont'; /* project id 1958405 */\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\n  src:\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\n}\n```\n\n2. 使用字体对应的 Entity Number（unicode）并指定 font-family\n\n```html\n<div style=\"font-family: iconfont;\">&#xe600;</div>\n```\n\n- inconfont 的 CSS 形式（对应 iconfont.cn 里的 Font class 功能）\n\n1. 在样式里引入@font-face，并使用伪类指定对应 iconfont 的 Entity Number\n\n```css\n@font-face {\n  font-family: 'iconfont'; /* project id 1958405 */\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\n  src:\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\n}\n.xxx:before {\n  content: '\\e600';\n}\n```\n\n2. 指定 font-family 和伪类\n\n```html\n<div class=\"xxx\" style=\"font-family: iconfont;\"></div>\n```\n\n### svg-symbol 法\n\n这种方式是最推荐的做法。与以上方式相比有如下特点：\n\n1. 支持多色图标，不再受单色限制\n2. 通过一些技巧，支持像字体那样，通过 font-size，color 来调样式\n3. 兼容性较差，支持 ie9+即现代浏览器\n4. 浏览器渲染 svg 的性能一般，还不如 png\n\n使用步骤：\n\n1. 从 iconfont.cn 上拷贝项目下生成的 symbol 代码\n\n```js\n//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js\n```\n\n2. 加入通用 css 代码（引入一次就行）\n\n```html\n<style type=\"text/css\">\n  .icon {\n    width: 1em;\n    height: 1em;\n    vertical-align: -0.15em;\n    fill: currentColor;\n    overflow: hidden;\n  }\n</style>\n```\n\n3. 挑选相应的图标并获取类名，应用于页面\n\n```html\n<svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-xxx\"></use>\n</svg>\n```\n\n### 「CSS 就是干」法\n\n纯 css 技巧来实现 icon。\n\n推荐一个网站，这个网站是一个设计师写的，全是用 css 实现的 icon。\n\nhttps://cssicon.space\n",
    "wordCount": 481
  }
]