[
  {
    "id": "454138604",
    "title": "SourceMap 的原理",
    "date": "2023-05-15",
    "tags": [
      "webpack"
    ],
    "fileName": "SourceMap 的原理.md",
    "content": "\n## 前言\n\nSourceMap 是一种将压缩、合并或转译后的代码映射回原始源代码的技术，主要用于调试和错误追踪。它的核心原理是通过记录压缩代码与原始代码之间的位置对应关系，使开发者工具（如浏览器 DevTools）能够将压缩后的代码位置“翻译”回原始代码的位置。\n\n## SourceMap 的核心组成\n\n一个 SourceMap 文件（通常是 `.map` 后缀）包含以下关键信息（类似于一个 JSON 的格式，具有以下 6 个字段）：\n\n1. **版本（version）**：当前 SourceMap 的版本（如 3）。\n2. **文件（file）**：生成的压缩文件名（如 bundle.min.js）。\n3. **原始文件列表（sources）**：所有原始源文件的路径（如 [\"src/index.js\", \"src/utils.js\"]）。\n4. **原始内容（sourcesContent）**：可选，直接包含原始代码内容，避免额外请求。\n5. **名称（names）**：压缩过程中被缩短的变量名或函数名的原始名称（如将 myVariable 压缩为 a）。\n6. **映射数据（mappings）**：最核心的部分，通过特定编码（如 VLQ）记录压缩代码与原始代码的位置对应关系。\n\n## 映射数据（mappings）的编码原理\n\n`mappings` 字段是一个字符串，通过分段编码记录了每个生成代码位置对应的原始位置。其编码过程如下：\n\n1. 位置分段\n\n- 每一行生成代码（压缩后的代码）用分号 ; 分隔。\n- 同一行内的每个位置映射用逗号 , 分隔。\n- 每个位置映射包含 1-5 个字段，用 VLQ 编码表示：\n\n```\n生成的列 > 原始文件索引 > 原始行 > 原始列 > （可选）名称索引\n```\n\n2. VLQ（Variable Length Quantity）编码\n\n- VLQ 是一种变长编码，能将大整数转换为 Base64 字符，减少文件体积。\n- 每个位置字段的值是相对于前一个位置的 偏移量（而非绝对值），进一步压缩数据。\n- 例如：数值 7 的 VLQ 编码是 7 → Base64 字符 7；数值 1000 的 VLQ 编码是 qB。\n\n3. 编码示例\n\n假设有以下映射字符串：\n\n```\nmappings: \"AAAA,SAASA,CAASC\"\n```\n\n解码后可能表示：\n\n- AAAA → 生成代码第 0 列 → 对应原始文件 0 的第 0 行第 0 列。\n- SAASA → 生成代码第 1 列 → 对应原始文件 1 的第 1 行第 0 列。\n\n## 生成与使用流程\n\n1. 生成阶段：\n\n- 构建工具（如 Webpack、Babel、Terser）在压缩/转译代码时生成 SourceMap。\n- 工具会记录每个生成代码位置对应的原始文件、行号、列号及原始名称。\n\n2. 浏览器使用阶段：\n\n- 浏览器检测到压缩文件末尾的 //# sourceMappingURL=bundle.min.js.map 注释时，会加载 SourceMap。\n- 开发者工具（如 Chrome DevTools）根据 SourceMap 将压缩代码的位置映射回原始代码，显示原始文件名、行号等信息。\n\n## 注意事项\n\n1. 安全性：生产环境应避免暴露 SourceMap 文件，否则可能泄露源代码。\n2. 性能：SourceMap 仅在打开开发者工具时加载，不影响普通用户性能。\n3. 兼容性：现代浏览器均支持 SourceMap。\n\n## 总结\n\n通过这种映射机制，SourceMap 让开发者能在压缩代码中直接调试原始代码，极大提升了开发体验。\n",
    "wordCount": 758
  },
  {
    "id": "1909767292",
    "title": "CommonJS 和 ESModule 详解",
    "date": "2022-08-23",
    "tags": [
      "模块化"
    ],
    "fileName": "CommonJS 和 ESModule 详解.md",
    "content": "\n## CommonJS 和 ESModule 的起源与背景\n\n### CommonJS\n\n- 起源：2009 年由 Mozilla 工程师 Kevin Dangoor 提出，旨在为 JavaScript 在浏览器外（如服务器端）提供模块化支持。\n- 应用场景：Node.js 的默认模块系统，主要用于服务器端开发。\n- 核心目标：解决 JavaScript 无模块化的问题，实现代码复用和依赖管理。\n\n### ESModule\n\n- 起源：2015 年随 ES6 (ECMAScript 2015) 正式发布，成为 JavaScript 语言标准的一部分。\n- 应用场景：现代浏览器和前端构建工具（如 Webpack、Rollup）广泛支持，逐步成为主流。\n- 核心目标：统一 JavaScript 的模块化标准，支持静态分析和异步加载。\n\n## 语法对比\n\n### CommonJS 语法\n\n导出模块：\n\n```js\n// 导出单个值\nmodule.exports = function add(a, b) {\n  return a + b;\n};\n\n// 导出多个值\nexports.subtract = (a, b) => a - b;\nexports.multiply = (a, b) => a * b;\n```\n\n导入模块：\n\n```js// 导入整个模块\nconst math = require('./math.js');\nmath.add(2, 3); // 5\n\n// 解构导入\nconst { subtract } = require('./math.js');\nsubtract(5, 2); // 3\n```\n\n### ESModule 语法\n\n导出模块：\n\n```js\n// 命名导出\nexport const PI = 3.14;\nexport function circleArea(r) {\n  return PI * r * r;\n}\n\n// 默认导出\nexport default class Calculator {\n  /* ... */\n}\n```\n\n导入模块：\n\n```js\n// 导入命名导出\n// 12.56\n// 导入默认导出\nimport Calculator from './Calculator.js';\nimport { PI, circleArea } from './math.js';\n\nconsole.log(circleArea(2)); // 12.56\n\nconst calc = new Calculator();\n\n// 动态导入（异步）\nimport('./math.js').then((module) => {\n  console.log(module.PI);\n});\n```\n\n## 核心差异\n\n### 标准\n\n一个是社区标准，一个是官方标准。\n\n### 加载方式\n\n| 特性     | CommonJS                   | ESModule                 |\n| -------- | -------------------------- | ------------------------ |\n| 加载时机 | 运行时同步加载（阻塞执行） | 编译时静态解析，异步加载 |\n| 适用环境 | 服务器（Node.js）          | 浏览器和现代 Node.js     |\n| 动态导入 | 支持 `require` 动态加载    | 支持 `import()` 动态加载 |\n\n示例：动态加载\n\n```js\n// CommonJS\nif (condition) {\n  const module = require('./dynamic-module');\n}\n\n// ESModule\nif (condition) {\n  import('./dynamic-module.js').then((module) => {\n    /* ... */\n  });\n}\n```\n\n### 模块作用域与值传递\n\n| 特性     | CommonJS                               | ESModule                            |\n| -------- | -------------------------------------- | ----------------------------------- |\n| 输出类型 | 输出值的拷贝（原始类型复制，对象引用） | 输出值的只读引用（类似 const 绑定） |\n| 响应性   | 导出值变化后，导入方不受影响           | 导出值变化后，导入方同步更新        |\n\n示例：值传递差异\n\n```js\n// counter.js (CommonJS)\nlet count = 0;\nmodule.exports = { count, increment: () => count++ };\n\n// main.js\nconst { count, increment } = require('./counter');\nincrement();\nconsole.log(count); // 0（count 是原始值的拷贝）\n\n// counter.mjs (ESModule)\nexport let count = 0;\nexport const increment = () => count++;\n\n// main.mjs\nimport { count, increment } from './counter.mjs';\nincrement();\nconsole.log(count); // 1（count 是引用）\n```\n\n### 循环依赖处理\n\n| 特性     | CommonJS                         | ESModule                   |\n| -------- | -------------------------------- | -------------------------- |\n| 处理方式 | 可能获取不完整模块（已执行部分） | 通过静态分析确保引用完整性 |\n\n示例：循环依赖\n\n```js\n// a.js (CommonJS)\nconst b = require('./b');\nconsole.log('a: b.value =', b.value);\nmodule.exports = { value: 'a' };\n\n// b.js (CommonJS)\nconst a = require('./a');\nconsole.log('b: a.value =', a.value); // 输出 {}（a 未完成初始化）\nmodule.exports = { value: 'b' };\n\n// 执行 node a.js 输出：\n// b: a.value = {}\n// a: b.value = b\n\n// a.mjs (ESModule)\nimport { value } from './b.mjs';\nconsole.log('a:', value);\nexport const value = 'a';\n\n// b.mjs (ESModule)\nimport { value } from './a.mjs';\nconsole.log('b:', value); // 报错：无法在初始化前访问 'value'\nexport const value = 'b';\n\n// 浏览器中执行会直接报错（ReferenceError）\n```\n\n### 静态分析与 Tree Shaking\n\n- ESModule：支持静态分析，构建工具（如 Webpack）可进行 Tree Shaking，删除未使用的代码。\n- CommonJS：动态特性导致无法可靠分析依赖，Tree Shaking 效果有限。\n\n示例：Tree Shaking\n\n```js\n// main.js\nimport { add } from './math.js';\n\n// math.js (ESModule)\nexport function add(a, b) {\n  return a + b;\n}\nexport function multiply(a, b) {\n  return a * b;\n}\n\nconsole.log(add(2, 3));\n\n// 构建后产物中不会包含 multiply 函数。\n```\n\n### Top-Level Await\n\n- ESModule：支持在模块顶层使用 await。\n- CommonJS：不支持，必须在函数内部使用。\n\n示例：Top-Level Await\n\n```js\n// data.mjs (ESModule)\nconst data = await fetch('https://api.example.com/data');\nexport { data };\n\n// main.mjs\nimport { data } from './data.mjs';\nconsole.log(data);\n```\n\n## 现代开发中的使用与兼容\n\n### Node.js 中的 ESModule 支持\n\n- 文件扩展名：使用 .mjs 或设置 package.json 中 \"type\": \"module\"。\n- 互操作性：可通过 import 加载 CommonJS 模块，但部分特性（如动态 require）受限。\n\n示例：Node.js 配置\n\n```json\n// package.json\n{\n  \"type\": \"module\", // 启用 ESModule\n  \"scripts\": {\n    \"start\": \"node index.mjs\"\n  }\n}\n```\n\n### 构建工具中的转换\n\n- Babel：将 ESModule 转换为 CommonJS 以兼容旧环境。\n- Webpack/Rollup：支持混合使用两种模块系统。\n\n示例：Babel 配置\n\n```json\n// .babelrc\n{\n  \"presets\": [\n    [\"@babel/preset-env\", { \"modules\": \"commonjs\" }] // 转译 ESM 为 CJS\n  ]\n}\n```\n\n## 总结与选择建议\n\n| 场景                | 推荐模块系统            | 理由                        |\n| ------------------- | ----------------------- | --------------------------- |\n| Node.js 服务端      | CommonJS                | 内置支持，生态成熟          |\n| 现代浏览器/前端项目 | ESModule                | 原生支持，Tree Shaking 优化 |\n| 混合项目            | ESModule + 构建工具转换 | 兼容新旧环境，统一代码风格  |\n\n未来趋势：ESModule 逐渐成为主流，Node.js 也在增强对 ESM 的支持。建议新项目优先使用 ESModule，旧项目逐步迁移。\n",
    "wordCount": 719
  },
  {
    "id": "1726424687",
    "title": "Webpack 常见问题",
    "date": "2022-07-16",
    "tags": [
      "webpack"
    ],
    "fileName": "Webpack 常见问题.md",
    "content": "\n## Webpack5 和 Webpack4 之间重要的区别\n\n1. 性能改进：Webpack5 在构建速度和打包体积方面进行了一些优化。它引入了持久缓存，可以减少构建时间。此外，Webpack5 还引入了更好的树摇（tree shaking）算法，可以更好地优化打包体积。\n2. 模块联邦（Module Federation）：这是 Webpack5 中最重要的新功能之一。模块联邦允许不同的应用程序共享模块，从而实现更好的代码复用和拆分。\n   这对于构建大型的微服务架构非常有用。\n3. 支持 WebAssembly：Webpack5 对 WebAssembly 提供了更好的支持。它可以直接导入和导出 WebAssembly 模块，并且可以通过配置进行优化。\n4. 改进的缓存策略：Webpack5 引入了更好的缓存策略，可以更好地利用浏览器缓存。这可以减少用户在更新应用程序时需要下载的文件数量。\n5. 改进的 Tree Shaking：Webpack5 引入了更好的 Tree Shaking 算法，可以更好地识别和删除未使用的代码。这可以进一步减少打包体积。\n6. 改进的持久缓存：Webpack5 引入了更好的持久缓存策略，可以更好地利用缓存。这可以减少构建时间。\n\n## 安装\n\n```js\nnpm init -y     // 初始化package.json\nnpm install webpack webpack-cli --save-dev\n\nnpx webpack --watch     // 监听文件修改\nnpx webpack-dev-server  // 以server的方式启动项目，不会打包物理文件，而是输出到内存\n```\n\n## 生命周期钩子\n\n- beforeRun：在 Webpack 开始运行之前调用，可以在此处执行一些准备工作。\n\n- run：在 Webpack 开始运行时调用，可以在此处执行一些初始化操作。\n\n- beforeCompile：在 Webpack 开始编译之前调用，可以在此处执行一些准备工作。\n\n- compile：在 Webpack 开始编译时调用，可以在此处执行一些初始化操作。\n\n- make：在 Webpack 开始构建编译器时调用，可以在此处执行一些准备工作。\n\n- afterCompile：在 Webpack 完成编译之后调用，可以在此处执行一些后处理操作。\n\n- emit：在 Webpack 生成最终的资源之前调用，可以在此处执行一些额外的操作，如生成额外的文件。\n\n- afterEmit：在 Webpack 生成最终的资源之后调用，可以在此处执行一些后处理操作。\n\n- done：在 Webpack 完成构建之后调用，可以在此处执行一些清理工作。\n\n### 使用钩子\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    {\n      apply: (compiler) => {\n        compiler.hooks.beforeRun.tap('MyPlugin', () => {\n          console.log('Before run');\n        });\n\n        compiler.hooks.done.tap('MyPlugin', () => {\n          console.log('Build done');\n        });\n      },\n    },\n  ],\n};\n\n//在上述示例中，我们定义了一个自定义插件，并在其中使用了beforeRun和done两个生命周期钩子函数。\n//在这些钩子函数中，我们可以执行一些自定义的操作，如输出日志信息。\n```\n\n## Loader（转换器）\n\nWebpack Loader 在 Webpack 构建过程中的生命周期中的工作主要分为以下几个阶段：\n\n- 解析阶段：Webpack 会根据配置文件中的入口文件，递归解析所有的依赖模块。在这个阶段，Webpack 会根据文件的后缀名来确定使用哪个 Loader 来处理该文件。\n\n- 编译阶段：在这个阶段，Webpack 会将解析后的模块转换成 AST（抽象语法树），并且根据配置文件中的规则，将模块中的代码进行转换和处理。这个阶段是 Loader 的主要工作阶段，Loader 可以对模块进行各种处理，例如转换代码、添加额外的功能等。\n\n- 生成阶段：在这个阶段，Webpack 会根据处理后的模块生成最终的输出文件。输出文件的格式和路径可以通过配置文件进行配置。\n\n在这些阶段中，Loader 主要在编译阶段发挥作用。Loader 可以通过导出一个函数来定义自己的处理逻辑，这个函数接收一个参数，即待处理的模块的源代码，然后返回处理后的代码。\n\n### 常用 Loader\n\n以下是一些常用的 Webpack Loader：\n\n- babel-loader：用于将 ES6+ 的 JavaScript 代码转换为 ES5 代码，以便在旧版本浏览器中运行。\n\n- css-loader：用于解析 CSS 文件，并处理其中的 import 和 url() 等语法。\n\n- style-loader：将解析后的 CSS 代码以 `<style>` 标签的形式插入到 HTML 文件中。\n\n- file-loader：用于处理文件资源（如图片、字体等），并将其复制到输出目录中。\n\n- url-loader：类似于 file-loader，但可以根据文件大小将文件转换为 DataURL，以减少 HTTP 请求。\n\n- sass-loader：用于将 SASS/SCSS 代码转换为 CSS 代码。\n\n- less-loader：用于将 Less 代码转换为CSS代码。\n\n- postcss-loader：用于对 CSS 代码进行后处理，如自动添加浏览器前缀等。\n\n- vue-loader：用于解析和转换 Vue 单文件组件。\n\n- ts-loader：用于将 TypeScript 代码转换为 JavaScript 代码。\n\n### 自定义 Loader\n\n```js\n// 核心代码：\n\nfunction clearConsoleLoader(source) {\n  // 使用正则表达式匹配并替换console语句\n  const modifiedSource = source.replace(/console\\.[a-z]+\\(.+\\);?/g, '');\n\n  return modifiedSource;\n}\n\nmodule.exports = clearConsoleLoader;\n\n//使用\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: ['babel-loader', './path/to/clearConsoleLoader.js'],\n      },\n    ],\n  },\n};\n```\n\n## Plugin（插件）\n\n### 工作原理\n\nWebpack Plugin 是用来扩展 Webpack 功能的工具，它可以在 Webpack 构建过程中的不同阶段执行一些额外的操作。\n\n插件的工作原理是通过在 Webpack 的构建过程中的不同生命周期中注册一些钩子函数，然后在对应的阶段执行这些钩子函数中的逻辑。\n\nWebpack 的构建过程中有以下几个生命周期：\n\n- 初始化阶段：在这个阶段，Webpack 会初始化配置参数，加载插件，并准备开始编译。\n\n- 编译阶段：在这个阶段，Webpack 会从入口文件开始递归解析所有的依赖模块，并将模块转换成 AST（抽象语法树），然后根据配置文件中的规则进行转换和处理。\n\n- 完成编译阶段：在这个阶段，Webpack 已经完成了所有的模块的转换和处理，并且生成了最终的输出文件。\n\n- 输出阶段：在这个阶段，Webpack 会将生成的输出文件写入到磁盘上。\n\n插件可以在这些生命周期中的任意阶段注册对应的钩子函数，并在钩子函数中执行一些额外的操作。\n\n### 常用 Plugin\n\n以下是一些常用的 Webpack 插件：\n\n- html-webpack-plugin：用于生成 HTML 文件，并自动将打包后的资源插入到 HTML 文件中。\n\n- mini-css-extract-plugin：用于将 CSS 代码提取成单独的文件，并生成一个 CSS 文件。\n\n- webpack-bundle-analyzer：用于分析打包后的文件结构，并生成一个可视化的报告。\n\n- webpack-dev-server：用于提供一个本地开发服务器，并自动刷新浏览器。\n\n- webpack-merge：用于合并多个 Webpack 配置文件。\n\n- webpack-plugin-replace：用于在打包过程中替换文件中的变量。\n\n- webpack-bundle-analyzer：用于分析打包后的文件结构，并生成一个可视化的报告。\n\n- webpack-dev-server：用于提供一个本地开发服务器，并自动刷新浏览器。\n\n- webpack-merge：用于合并多个 Webpack 配置文件。\n\n- webpack-plugin-replace：用于在打包过程中替换文件中的变量。\n\n### 自定义 Plugin\n\n```js\nclass MyPlugin {\n  apply(compiler) {\n    // 注册初始化阶段的钩子函数\n    compiler.hooks.initialize.tap('MyPlugin', () => {\n      console.log('MyPlugin initialized');\n    });\n\n    // 注册编译阶段的钩子函数\n    compiler.hooks.compile.tap('MyPlugin', () => {\n      console.log('MyPlugin compiling');\n    });\n  }\n}\n\nmodule.exports = MyPlugin;\n\n// 使用\n\nconst MyPlugin = require('./my-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new MyPlugin(),\n  ],\n};\n```\n\n## 打包过程\n\n- 读取配置文件：Webpack 会首先读取配置文件，根据配置文件中的入口、出口等信息进行打包。\n\n- 解析模块依赖：Webpack 会从指定的入口文件开始递归解析所有的模块依赖，直到找到所有的模块。\n\n- 加载器处理：对于不同类型的模块，Webpack 会使用相应的加载器对其进行处理。例如，对于 JavaScript 模块，Webpack 会使用 Babel 加载器将 ES6 语法转换为 ES5 语法；对于 CSS 模块，Webpack 会使用 CSS 加载器将 CSS 代码打包进 JS 文件中。\n\n- 插件处理：在模块加载完成之后，Webpack 会执行一系列插件，用于完成一些额外的任务，例如生成 HTML 文件、提取 CSS 文件等。\n\n- 编译打包：Webpack 将经过处理的模块和插件生成最终的打包文件。通常情况下，Webpack 会生成一个或多个 JavaScript 文件，同时也可以生成其他类型的文件，例如 CSS、图片等。\n\n- 输出打包文件：Webpack 将生成的打包文件输出到指定的目录中。通常情况下，Webpack 会将打包文件输出到 dist 目录下。\n\n## 加速 Webpack 打包速度和减小打包体积的优化\n\n### 优化打包速度\n\n1. 优化 Webpack 配置：使用 Tree shaking 来减小打包体积，设置 Webpack 的 mode 为 production 以启用 UglifyJsPlugin 等插件进行代码压缩和优化。\n\n2. 使用 Webpack 的 code splitting 功能：将代码分割成较小的块，以便在需要时动态加载。\n\n3. 压缩图片和字体文件：使用 ImageMinWebpackPlugin 和 FontminWebpackPlugin 等插件来压缩图片和字体文件，减小打包体积。\n\n4. 缓存：启用 Webpack 的缓存功能，以便在修改代码时只重新打包修改的文件，而不是重新打包所有文件。\n\n5. 使用 DLLPlugin和DllReferencePlugin：将一些第三方库打包成单独的文件，以便在每次打包应用程序时不必重新打包这些库。\n\n6. 使用 HappyPack 插件：使用多线程来加速Webpack打包，以便同时处理多个任务。\n\n7. 使用 externals 选项：将一些不需要打包的库从打包中排除，以便减小打包体积。\n\n8. 使用 webpack-bundle-analyzer 插件：分析打包后的文件，以便找出冗余的代码和依赖关系，进行优化。\n\n这些技巧可以帮助优化Webpack的打包速度和打包体积。\n\n## Webpack 配置文件\n\n```js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // 自动引入资源插件  npm install --save-dev html-webpack-plugin\nconst MiniCssExtracPlugin = require('mini-css-extrac-plugin'); // css抽离\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\n//加载toml、yarm、json5数据资源 npm install toml yarm json5 -D\nconst toml = require('toml');\nconst yarm = require('yarm');\nconst json5 = require('json5');\n\nmodule.exports = (env) => {\n  return {\n    // 手动分离公共文件，通过配置成对象的方式实现多入口代码分割\n    // entry: {\n    //  index:{\n    //    import:\"./src/index.js\",\n    //    dependOn: \"shared\"  // 抽离公共文件\n    //  },\n    //  shared: \"lodash\"      // 公共的js文件\n    // },\n    // 多入口\n    // entry: {\n    // \t pageOne: './src/pageOne/index.js',\n    //  \tpageTwo: './src/pageTwo/index.js',\n    //  \tpageThree: './src/pageThree/index.js',\n    // },\n    // 单入口\n    entry: {\n      index: './src/index.js',\n    },\n    output: {\n      filename: 'scripts/[name].[contenthash].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\n      path: path.resolve(__dirname, './dist'),\n      clean: true, // 清除上一次的垃圾文件\n      assetModuleFilename: 'images/[contenthash][ext]', // 在images目录下，根据文件内容自动生成hash文件名\n      publicPath: 'https://*****.com/', // 公共路径（cdn域名或者本地localhost）\n    },\n    mode: env.prodection ? 'prodection' : 'development', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\n    devtool: 'cheap-module-source-map', // 真实报错文件指向,生产环境一般不开启sourcemap\n    // 插件（非必要的，缺少也不影响项目打包）\n    plugins: [\n      new HtmlWebpackPlugin({\n        template: './index.html', // 模板\n        filename: 'app.html',\n        inject: 'body', // script 存在的位置\n        hash: true, // 解决缓存\n        minify: {\n          removeAttributeQuotes: true, // 压缩，去掉引号\n        },\n      }),\n      new MiniCssExtracPlugin({\n        filename: 'style/[contenthash].css',\n      }),\n    ],\n    devServer: {\n      static: './dist', // 监听根目录文件变化，自动刷新页面插件 npm install --save-dev webpack-dev-server\n      //反向代理\n      proxy: {\n        '/ajax': {\n          target: 'https:**********',\n          ws: true,\n          changeOrigin: true,\n        },\n      },\n    },\n    // 模块（必要的，缺少影响项目打包）\n    module: {\n      rules: [\n        //资源模块类型我们称之为Asset Modules Type，总共有四种，来代替loader，分别是：\n        // asset/resource：发送一个单独的文件并导出URL，替代file-loader\n        // asset/inline：导出一个资源的data URI(base64)，替代url-loader\n        // asset/source：导出资源的源代码，之前通过使用raw-loader实现\n        // asset：介于asset/resource和asset/inline之间， 之前通过url-loader+limit属性实现。\n        {\n          test: /\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则图片文件\n          type: 'asset',\n          generator: {\n            filename: 'images/[contenthash][ext]', // 优先级高于 assetModuleFilename\n          },\n        },\n        {\n          // 支持less\n          // npm install style-loader css-loader less-loader less --save-dev\n          // 抽离 npm install mini-css-extrac-plugin  --save-dev   webpack5环境下构建的插件\n          test: /\\.(le|c)ss$/, // .less and .css\n          use: [MiniCssExtracPlugin.loader, /* \"style-loader\", */ 'css-loader', 'less-loader'],\n        },\n        {\n          test: /\\.(woff|woff2|eot|ttf|oft)$/, // 正则字体文件\n          type: 'asset/resource',\n        },\n        //加载csv、xml数据资源 npm install csv-loader xml-loader -D\n        {\n          test: /\\.(csv|tsv)$/,\n          use: 'csv-loader',\n        },\n        {\n          test: /\\.xml$/,\n          use: 'xml-loader',\n        },\n        //加载toml、yarm、json5数据资源\n        {\n          test: /\\.toml$/,\n          type: 'json',\n          parser: {\n            parse: toml.parse,\n          },\n        },\n        {\n          test: /\\.yarm$/,\n          type: 'json',\n          parser: {\n            parse: yarm.parse,\n          },\n        },\n        {\n          test: /\\.json5$/,\n          type: 'json',\n          parser: {\n            parse: json5.parse,\n          },\n        },\n        // loader工具 支持数组方式链式调用，数组靠后的元素先执行\n        {\n          // 压缩图片\n          //图片小于一定大小使用base64 否则使用file-loader产生真实图片 npm install url-loader --save-dev\n          test: /\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则\n          use: [\n            {\n              loader: 'url-loader',\n              options: {\n                limit: 5000, //小于限定使用base64\n                name: 'home/images/[name].[hash:8].[ext]',\n                publicPath: `../../`,\n                esModule: false,\n              },\n            },\n          ],\n        },\n        // 使用babel-loader npm install -D babel-loader @babel/core @babel/preset-env\n        // regeneratorRuntime是webpack打包生成的全局辅助函数，由babel生成，用于兼容 async/await 的语法\n        // npm install --save @babel/runtime\n        // npm install --save-dev @babel/plugin-transform-runtime\n        {\n          test: /\\.js$/,\n          exclude: /node_modules/, // *业务代码里面可能会引入node_modules外部js，这些js不需要babel-loader编译，因此需要排除掉\n          use: {\n            loader: 'babel-loader', // *引入babel-loader\n            options: {\n              presets: ['@babel/preset-env'], // *引入预设\n              plugins: [\n                [\n                  '@babel/plugin-transform-runtime', // *配置插件信息\n                ],\n              ],\n            },\n          },\n        },\n      ],\n    },\n    optimization: {\n      minimizer: [new CssMinimizerPlugin(), new TerserPlugin()], //代码压缩 mode改为 production\n      splitChunks: {\n        // 缓存\n        cacheGroups: {\n          vendor: {\n            test: /[\\\\/]node_modules[\\\\/]/,\n            name: 'vendors',\n            chunks: 'all', // 自动重复代码抽离\n          },\n        },\n      },\n    },\n  };\n};\n```\n\n## Webpack 配置文件拆分\n\n### webpack.config.common.js\n\nwebpack.config.common.js 文件用于公共环境配置\n\n```js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // 自动引入资源插件  npm install --save-dev html-webpack-plugin\nconst MiniCssExtracPlugin = require('mini-css-extrac-plugin'); // css抽离\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\n//加载toml、yarm、json5数据资源 npm install toml yarm json5 -D\nconst toml = require('toml');\nconst yarm = require('yarm');\nconst json5 = require('json5');\n\nmodule.exports = {\n  entry: {\n    index: './src/index.js',\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    clean: true, // 清除上一次的垃圾文件\n    assetModuleFilename: 'images/[contenthash][ext]', // 在images目录下，根据文件内容自动生成hash文件名\n  },\n  // 插件（非必要的，缺少也不影响项目打包）\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './index.html', // 模板\n      filename: 'app.html',\n      inject: 'body', // script 存在的位置\n      hash: true, // 解决缓存\n      minify: {\n        removeAttributeQuotes: true, // 压缩，去掉引号\n      },\n    }),\n    new MiniCssExtracPlugin({\n      filename: 'style/[contenthash].css',\n    }),\n  ],\n  // 模块（必要的，缺少影响项目打包）\n  module: {\n    rules: [\n      //资源模块类型我们称之为Asset Modules Type，总共有四种，来代替loader，分别是：\n      // asset/resource：发送一个单独的文件并导出URL，替代file-loader\n      // asset/inline：导出一个资源的data URI(base64)，替代url-loader\n      // asset/source：导出资源的源代码，之前通过使用raw-loader实现\n      // asset：介于asset/resource和asset/inline之间， 之前通过url-loader+limit属性实现。\n      {\n        test: /\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则图片文件\n        type: 'asset',\n        generator: {\n          filename: 'images/[contenthash][ext]', // 优先级高于 assetModuleFilename\n        },\n      },\n      {\n        // 支持less\n        // npm install style-loader css-loader less-loader less --save-dev\n        // 抽离 npm install mini-css-extrac-plugin  --save-dev   webpack5环境下构建的插件\n        test: /\\.(le|c)ss$/, // .less and .css\n        use: [MiniCssExtracPlugin.loader, /* \"style-loader\", */ 'css-loader', 'less-loader'],\n      },\n      {\n        test: /\\.(woff|woff2|eot|ttf|oft)$/, // 正则字体文件\n        type: 'asset/resource',\n      },\n      //加载csv、xml数据资源 npm install csv-loader xml-loader -D\n      {\n        test: /\\.(csv|tsv)$/,\n        use: 'csv-loader',\n      },\n      {\n        test: /\\.xml$/,\n        use: 'xml-loader',\n      },\n      //加载toml、yarm、json5数据资源\n      {\n        test: /\\.toml$/,\n        type: 'json',\n        parser: {\n          parse: toml.parse,\n        },\n      },\n      {\n        test: /\\.yarm$/,\n        type: 'json',\n        parser: {\n          parse: yarm.parse,\n        },\n      },\n      {\n        test: /\\.json5$/,\n        type: 'json',\n        parser: {\n          parse: json5.parse,\n        },\n      },\n      // loader工具 支持数组方式链式调用，数组靠后的元素先执行\n      {\n        // 压缩图片\n        //图片小于一定大小使用base64 否则使用file-loader产生真实图片 npm install url-loader --save-dev\n        test: /\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 5000, //小于限定使用base64\n              name: 'home/images/[name].[hash:8].[ext]',\n              publicPath: `../../`,\n              esModule: false,\n            },\n          },\n        ],\n      },\n      // 使用babel-loader npm install -D babel-loader @babel/core @babel/preset-env\n      // regeneratorRuntime是webpack打包生成的全局辅助函数，由babel生成，用于兼容 async/await 的语法\n      // npm install --save @babel/runtime\n      // npm install --save-dev @babel/plugin-transform-runtime\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/, // *业务代码里面可能会引入node_modules外部js，这些js不需要babel-loader编译，因此需要排除掉\n        use: {\n          loader: 'babel-loader', // *引入babel-loader\n          options: {\n            presets: ['@babel/preset-env'], // *引入预设\n            plugins: [\n              [\n                '@babel/plugin-transform-runtime', // *配置插件信息\n              ],\n            ],\n          },\n        },\n      },\n    ],\n  },\n  optimization: {\n    splitChunks: {\n      // 缓存\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all', // 自动重复代码抽离\n        },\n      },\n    },\n  },\n};\n```\n\n### webpack.config.dev.js\n\nwebpack.config.dev.js 文件用于开发环境配置，`npx webpack -c ./webpack.config.dev.js`\n\n```js\nmodule.exports = {\n  output: {\n    filename: 'scripts/[name].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\n  },\n  mode: 'development', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\n  devtool: 'cheap-module-source-map', // 真实报错文件指向,生产\n  devServer: {\n    static: './dist', // 监听根目录文件变化，自动刷新页面插件 npm install --save-dev webpack-dev-server\n    //反向代理\n    proxy: {\n      '/ajax': {\n        target: 'https:**********',\n        ws: true,\n        changeOrigin: true,\n      },\n    },\n  },\n};\n```\n\n### webpack.config.prod.js\n\nwebpack.config.prod.js 文件用于生产环境配置，`npx webpack -c ./webpack.config.prod.js`\n\n```js\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\n\nmodule.exports = {\n  output: {\n    filename: 'scripts/[name].[contenthash].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\n    publicPath: 'https://*****.com/', // 公共路径（cdn域名或者本地localhost）\n  },\n  mode: 'prodection', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\n  optimization: {\n    minimizer: [new CssMinimizerPlugin(), new TerserPlugin()], //代码压缩 mode改为 production\n  },\n  performance: {\n    hints: false, // 关闭性能提示\n  },\n};\n```\n\n### webpack.config.js\n\n总的配置文件，根据环境变量来决定使用哪个配置文件，`npx webpack -c ./webpack.config.js --env development`\n\n```js\nconst { merge } = require('webpack-merge'); // npm install webpack-merge -D\nconst commonConfig = require('./webpack.config.common');\nconst productionConfig = require('./webpack.config.prod');\nconst developmentConfig = require('./webpack.config.dev');\n\nmodule.exports = (env) => {\n  switch (true) {\n    case env.development:\n      return merge(commonConfig, developmentConfig);\n    case env.production:\n      return merge(commonConfig, productionConfig);\n      defult: return new Error();\n  }\n};\n```\n\n## 封装 Webpack 自定义插件\n\n```js\n1. 创建一个 JavaScript 文件，并导出一个函数。这个函数将作为你的插件的构造函数。\n\n2. 在函数中定义一个 apply 方法，该方法接收一个 compiler 参数。这个 compiler 对象是 Webpack 的核心，它包含了 Webpack 的所有配置和工作流程。\n\n3. 在 apply 方法中，可以通过 compiler.hooks 对象访问 Webpack 的生命周期钩子。通过这些钩子，你可以在 Webpack 运行的不同阶段执行自定义代码。\n\n4. 实现你的插件逻辑，例如在特定的 Webpack 钩子上注册回调函数，向编译器添加自定义插件等。\n\n5. 将你的插件打包成一个 npm 模块，并在项目中引入和使用它。\n\n下面是一个简单的 Webpack 插件示例：\n\nconst MyPlugin = function() {};\n\nMyPlugin.prototype.apply = function(compiler) {\n  compiler.hooks.done.tap('MyPlugin', stats => {\n    console.log('Webpack is done!');\n  });\n};\n\nmodule.exports = MyPlugin;\n\n在这个示例中，我们定义了一个 MyPlugin 插件，它在 Webpack 编译完成后输出一条信息。\n在 apply 方法中，我们使用 compiler.hooks.done 钩子注册了一个回调函数，在编译完成后输出一条消息。\n\n要使用这个插件，你需要将它打包成一个 npm 模块，并在 Webpack 配置文件中引入和使用它：\n\nconst MyPlugin = require('my-plugin');\n\nmodule.exports = {\n  plugins: [\n    new MyPlugin()\n  ]\n};\n\n这个示例中，我们在 Webpack 配置文件中引入了 MyPlugin 插件，并将它作为插件数组的一项传递给 plugins 选项。\n这样，当 Webpack 编译时，MyPlugin 将会被启用并执行它的逻辑。\n```\n",
    "wordCount": 2361
  },
  {
    "id": "1477085777",
    "title": "React 如何实现超大文件的上传和下载",
    "date": "2022-05-23",
    "tags": [
      "react"
    ],
    "fileName": "React 如何实现超大文件的上传和下载.md",
    "content": "\n## 背景\n\n文件传输是一个常见的需求。对于大文件的下载和上传，直接使用传统的方式可能会遇到性能和用户体验方面的问题。幸运的是，前端技术提供了一些高效的解决方案：文件流操作和切片下载与上传。本文将深入探讨这些技术，帮助你理解它们的原理和实现方法，以优化文件传输效率和提升用户体验。\n\n## 一、前端文件流操作\n\n在前端开发中，文件流操作是指通过数据流的方式处理文件，对文件进行读取、写入和展示等操作。下面详细介绍了前端文件流操作的几个基本概念和技术。\n\n### 数据流和文件处理的基本概念\n\n数据流是指连续的数据序列，可以从一个源传输到另一个目的地。在前端开发中，文件可以被看作数据流的一种形式，可以通过数据流的方式进行处理。文件处理涉及读取和写入文件的操作，包括读取文件的内容、写入数据到文件，以及对文件进行删除、重命名等操作。\n\n### Blob 对象和 ArrayBuffer：处理二进制数据\n\n在前端处理文件时，经常需要处理二进制数据。Blob（Binary Large Object）对象是用来表示二进制数据的一个接口，可以存储大量的二进制数据。Blob 对象可以通过构造函数进行创建，也可以通过其他 API 生成，例如通过 FormData 对象获取上传的文件。而 ArrayBuffer 是 JavaScript 中的一个对象类型，用于表示一个通用的、固定长度的二进制数据缓冲区。我们可以通过 ArrayBuffer 来操作和处理文件的二进制数据。\n\n代码如下：\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction FileInput() {\n  const [fileContent, setFileContent] = useState('');\n  // 读取文件内容到ArrayBuffer\n  function readFileToArrayBuffer(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      // 堆代码 duidaima.com\n      // 注册文件读取完成后的回调函数\n      reader.onload = function (event) {\n        const arrayBuffer = event.target.result;\n        resolve(arrayBuffer);\n      };\n      // 读取文件内容到ArrayBuffer\n      reader.readAsArrayBuffer(file);\n    });\n  }\n  // 将ArrayBuffer转为十六进制字符串\n  function arrayBufferToHexString(arrayBuffer) {\n    const uint8Array = new Uint8Array(arrayBuffer);\n    let hexString = '';\n    for (let i = 0; i < uint8Array.length; i++) {\n      const hex = uint8Array[i].toString(16).padStart(2, '0');\n      hexString += hex;\n    }\n    return hexString;\n  }\n  // 处理文件选择事件\n  function handleFileChange(event) {\n    const file = event.target.files[0]; // 获取选中的文件\n    if (file) {\n      readFileToArrayBuffer(file)\n        .then((arrayBuffer) => {\n          const hexString = arrayBufferToHexString(arrayBuffer);\n          setFileContent(hexString);\n        })\n        .catch((error) => {\n          console.error('文件读取失败:', error);\n        });\n    } else {\n      setFileContent('请选择一个文件');\n    }\n  }\n  return (\n    <div>\n      <input type=\"file\" onChange={handleFileChange} />\n      <div>\n        <h4>文件内容：</h4>\n        <pre>{fileContent}</pre>\n      </div>\n    </div>\n  );\n}\n\nexport default FileInput;\n```\n\n上面代码里，我们创建了一个名为 FileInput 的函数式组件。该组件包含一个文件选择框和一个用于显示文件内容的 <pre> 元素。当用户选择文件时，通过 FileReader 将文件内容读取为 ArrayBuffer，然后将 ArrayBuffer 转换为十六进制字符串，并将结果显示在页面上。\n\n### 使用 FileReader 进行文件读取\n\nFileReader 是前端浏览器提供的一个 API，用于读取文件内容。通过 FileReader，我们可以通过异步方式读取文件，并将文件内容转换为可用的数据形式，比如文本数据或二进制数据。FileReader 提供了一些读取文件的方法，例如 readAsText()、readAsArrayBuffer() 等，可以根据需要选择合适的方法来读取文件内容。\n\n### 将文件流展示在前端页面中\n\n一旦我们成功地读取了文件的内容，就可以将文件流展示在前端页面上。具体的展示方式取决于文件的类型。例如，对于文本文件，可以直接将其内容显示在页面的文本框或区域中；对于图片文件，可以使用 <img> 标签展示图片；对于音视频文件，可以使用 <video> 或 <audio> 标签来播放。通过将文件流展示在前端页面上，我们可以实现在线预览和查看文件内容的功能。\n\n好的，这一部分就基本介绍完毕，总结一下。前端文件操作流是处理大型文件的一种常见方式，他可以通过数据流的方式对文件进行操作。Blob对象 和 ArrayBuffer是处理二进制数据的重要工具。而 FileReader则是读取文件内容的的关键组件。通过这些技术，我们可以方便的在前端页面上进行操作或者文件展示。\n\n## 二、文件切片下载\n\n这一步就进入到我们今天文章主题了，先来主要的看下流程:\ngraph LR\nA(开始) --> B{选择文件}\nB -- 用户选择文件 --> C[切割文件为多个切片]\nC --> D{上传切片}\nD -- 上传完成 --> E[合并切片为完整文件]\nE -- 文件合并完成 --> F(上传成功)\nD -- 上传中断 --> G{保存上传进度}\nG -- 上传恢复 --> D\n\nG -- 取消上传 --> H(上传取消)\n\n### 传统文件下载的性能问题\n\n文件切片下载是一种提升文件下载效率的技术，通过将大文件分割成多个小片段（切片），并使用多个并发请求同时下载这些切片，从而加快整体下载速度。传统的文件下载方式对于大文件来说存在性能问题。当用户请求下载一个大文件时，服务器需要将整个文件发送给客户端。这会导致以下几个问题：\n\n1. 较长的等待时间：大文件需要较长的时间来传输到客户端，用户需要等待很长时间才能开始使用文件。\n2. 网络阻塞：由于下载过程中占用了网络带宽，其他用户可能会遇到下载速度慢的问题。\n3. 断点续传困难：如果下载过程中出现网络故障或者用户中断下载，需要重新下载整个文件，无法继续之前的下载进度。\n\n### 利用文件切片提升下载效率\n\n文件切片下载通过将文件分割成多个小片段，每个片段大小通常在几百KB到几MB之间。然后客户端通过多个并发请求同时下载这些片段。这样做的好处是：\n\n![1.jpg](https://free4.yunpng.top/2025/02/27/67bfb865ba8df.jpg)\n\n快速启动：客户端可以快速开始下载，因为只需要下载第一个切片即可。\n并发下载：通过使用多个并发请求下载切片，可以充分利用带宽，并提高整体下载速度。\n断点续传：如果下载中断，客户端只需要重新下载中断的切片，而不需要重新下载整个文件。\n\n切片上传代码示例：\n\n```jsx\nconst [selectedFile, setSelectedFile] = useState(null);\nconst [progress, setProgress] = useState(0);\n// 处理文件选择事件\nfunction handleFileChange(event) {\n  setSelectedFile(event.target.files[0]);\n}\n// 处理文件上传事件\nfunction handleFileUpload() {\n  if (selectedFile) {\n    // 计算切片数量和每个切片的大小\n    const fileSize = selectedFile.size;\n    const chunkSize = 1024 * 1024; // 设置切片大小为1MB\n    const totalChunks = Math.ceil(fileSize / chunkSize);\n    // 创建FormData对象，并添加文件信息\n    const formData = new FormData();\n    formData.append('file', selectedFile);\n    formData.append('totalChunks', totalChunks);\n    // 循环上传切片\n    for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\n      const start = chunkNumber * chunkSize;\n      const end = Math.min(start + chunkSize, fileSize);\n      const chunk = selectedFile.slice(start, end);\n      formData.append(`chunk-${chunkNumber}`, chunk, selectedFile.name);\n    }\n    // 发起文件上传请求\n    axios\n      .post('/upload', formData, {\n        onUploadProgress: (progressEvent) => {\n          const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);\n          setProgress(progress);\n        },\n      })\n      .then((response) => {\n        console.log('文件上传成功:', response.data);\n      })\n      .catch((error) => {\n        console.error('文件上传失败:', error);\n      });\n  }\n}\n```\n\n当涉及到切片上传和下载时，前端使用的技术通常是基于前端库或框架提供的文件处理功能，结合后端服务实现。\n\n上面代码里我们提到了文件如何切片上传。\n当用户选择文件后，通过 handleFileChange 函数处理文件选择事件，将选择的文件保存在 selectedFile 状态中。\n当用户点击上传按钮时，通过 handleFileUpload 函数处理文件上传事件。\n\n在 handleFileUpload 函数中，计算切片数量和每个切片的大小，并创建一个 FormData 对象用于存储文件信息和切片数据。\n\n### 实现客户端切片下载的方案\n\n实现客户端切片下载的基本方案如下：\n\n1. 服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。\n2. 客户端发送请求获取切片列表，同时开始下载第一个切片。\n3. 客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。\n4. 当所有切片都下载完成后，客户端将下载的数据合并为完整的文件。\n\n代码示例：\n\n```jsx\nfunction downloadFile() {\n  // 发起文件下载请求\n  fetch('/download', {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n    .then((response) => response.json())\n    .then((data) => {\n      const totalSize = data.totalSize;\n      const totalChunks = data.totalChunks;\n      let downloadedChunks = 0;\n      let chunks = [];\n      // 下载每个切片\n      for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\n        fetch(`/download/${chunkNumber}`, {\n          method: 'GET',\n        })\n          .then((response) => response.blob())\n          .then((chunk) => {\n            downloadedChunks++;\n            chunks.push(chunk);\n            // 当所有切片都下载完成时\n            if (downloadedChunks === totalChunks) {\n              // 合并切片\n              const mergedBlob = new Blob(chunks);\n              // 创建对象 URL，生成下载链接\n              const downloadUrl = window.URL.createObjectURL(mergedBlob);\n              // 创建 <a> 元素并设置属性\n              const link = document.createElement('a');\n              link.href = downloadUrl;\n              link.setAttribute('download', 'file.txt');\n              // 模拟点击下载\n              link.click();\n              // 释放资源\n              window.URL.revokeObjectURL(downloadUrl);\n            }\n          });\n      }\n    })\n    .catch((error) => {\n      console.error('文件下载失败:', error);\n    });\n}\n```\n\n我们看下代码，首先使用 BLOB 对象创建一共对象 URL，用于生成下载连接，然后创建 a 标签并且设置 href 的属性为刚刚创建的对象 URL,继续设置 a 标签的 download 属性是文件名，方便点击的时候自动下载文件。\n\n### 显示下载进度和完成状态\n\n为了显示下载进度和完成状态，可以在客户端实现以下功能：\n显示进度条：客户端可以通过监听每个切片的下载进度来计算整体下载进度，并实时更新进度条的显示。\n显示完成状态：当所有切片都下载完成后，客户端可以显示下载完成的状态，例如显示一个完成的图标或者文本。\n\n这里我们可以继续接着切片上传代码示例里的继续写。\n代码示例：\n\n```jsx\n\n// 处理文件下载事件\nfunction handleFileDownload() {\n  axios.get('/download', {\n    responseType: 'blob',\n    onDownloadProgress: progressEvent => {\n      const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);\n      setProgress(progress);\n    }\n  })\n    .then(response => {\n      // 创建一个临时的URL对象用于下载\n      const url = window.URL.createObjectURL(new Blob([response.data]));\n      const link = document.createElement('a');\n      link.href = url;\n      link.setAttribute('download', 'file.txt');\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    })\n    .catch(error => {\n      console.error('文件下载失败:', error);\n    });\n}\n\n\n<button onClick={handleFileDownload}>下载文件</button>\n  <div>进度：{progress}%</div>\n```\n\n1. 当用户点击下载按钮时，通过 handleFileDownload 函数处理文件下载事件。\n2. 在 handleFileDownload 函数中，使用 axios 库发起文件下载请求，并设置 responseType: 'blob' 表示返回二进制数据。\n3. 通过监听 onDownloadProgress 属性获取下载进度，并更新进度条的显示。\n4. 下载完成后，创建一个临时的 URL 对象用于下载，并通过动态创建 <a> 元素模拟点击下载。\n\n## 三、大文件上传的问题与解决方案\n\n### 传统的文件上传方式存在的问题\n\n1. 大文件上传耗时长，容易导致请求超时。\n2. 占用服务器和网络带宽资源，可能影响其他用户的访问速度。\n3. 如果上传中断，需要重新上传整个文件，效率低下。\n4. 难以实现上传进度的显示和控制。\n\n### 前端文件切片上传的优势\n\n1. 将大文件分割为更小的文件切片，分多次上传，提高上传效率和稳定性。\n2. 提供上传进度的监控和展示，提高用户体验。\n3. 充分利用浏览器的并发上传能力，减轻服务器负担。\n4. 实现断点续传功能，避免重复上传已上传的部分。\n\n### 实现前端切片上传的方法\n\n1. 使用 JavaScript 的 `File API` 获取文件对象，并使用 `Blob.prototype.slice()` 方法将文件切割为多个切片。\n2. 使用 FormData 对象将切片数据通过 AJAX 或 Fetch API 发送到服务器。\n3. 在后端服务器上接收切片并保存到临时存储中，等待后续合并。\n4. 在客户端通过监听上传进度事件，在进度条或提示中展示上传进度。\n\n代码示例：\n\n```jsx\n\nconst [file, setFile] = useState(null);  //用来存放我本地上传的文件\nconst chunkSize = 1024 * 1024; // 1MB 切片大小\nconst upload = () => {\n  if (!file) {\n    alert(\"请选择要上传的文件！\");\n    return;\n  }\n  const chunkSize = 1024 * 1024; // 1MB\n  let start = 0;\n  let end = Math.min(chunkSize, file.size);\n  while (start < file.size) {\n    const chunk = file.slice(start, end);\n\n    // 创建FormData对象\n    const formData = new FormData();\n    formData.append('file', chunk);\n    // 发送切片到服务器\n    fetch('上传接口xxxx', {\n      method: 'POST',\n      body: formData\n    })\n      .then(response => response.json())\n      .then(data => {\n        console.log(data);\n        // 处理响应结果\n      })\n      .catch(error => {\n        console.error(error);\n        // 处理错误\n      });\n    start = end;\n    end = Math.min(start + chunkSize, file.size);\n  }\n};\n\nreturn (\n  <div>\n  <input type=\"file\" onChange={handleFileChange} />\n  <button onClick={upload}>上传</button>\n  </div>\n);\n```\n\n在上面的代码中，创建了一个名为 Upload 的函数组件。它使用了 React 的 useState 钩子来管理选中的文件。通过 onChange 事件监听文件输入框的变化，并在 handleFileChange 函数中获取选择的文件，并更新 file 状态。\n\n点击`上传`按钮时，调用 upload 函数。它与之前的示例代码类似，将文件切割为多个大小相等的切片，并使用 FormData 对象和 fetch 函数发送切片数据到服务器。\n\n### 实现断点续传的技术：记录和恢复上传状态\n\n在前端，可以使用 localStorage 或 sessionStorage 来存储已上传的切片信息，包括已上传的切片索引、切片大小等。每次上传前，先检查本地存储中是否存在已上传的切片信息，若存在，则从断点处继续上传。在后端，可以使用一个临时文件夹或数据库来记录已接收到的切片信息，包括已上传的切片索引、切片大小等。在上传完成前，保存上传状态，以便在上传中断后能够恢复上传进度。\n\n```jsx\nimport React, { useEffect, useRef, useState } from 'react';\n\nfunction Upload() {\n  const [file, setFile] = useState(null);\n  const [uploadedChunks, setUploadedChunks] = useState([]);\n  const [uploading, setUploading] = useState(false);\n  const uploadRequestRef = useRef();\n  const handleFileChange = (event) => {\n    const selectedFile = event.target.files[0];\n    setFile(selectedFile);\n  };\n  const uploadChunk = (chunk) => {\n    // 创建FormData对象\n    const formData = new FormData();\n    formData.append('file', chunk);\n    // 发送切片到服务器\n    return fetch('your-upload-url', {\n      method: 'POST',\n      body: formData,\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        console.log(data);\n        // 处理响应结果\n        return data;\n      });\n  };\n  const upload = async () => {\n    if (!file) {\n      alert('请选择要上传的文件！');\n      return;\n    }\n    const chunkSize = 1024 * 1024; // 1MB\n    const totalChunks = Math.ceil(file.size / chunkSize);\n    let start = 0;\n    let end = Math.min(chunkSize, file.size);\n    setUploading(true);\n    for (let i = 0; i < totalChunks; i++) {\n      const chunk = file.slice(start, end);\n      const uploadedChunkIndex = uploadedChunks.indexOf(i);\n      if (uploadedChunkIndex === -1) {\n        try {\n          const response = await uploadChunk(chunk);\n          setUploadedChunks((prevChunks) => [...prevChunks, i]);\n          // 保存已上传的切片信息到本地存储\n          localStorage.setItem('uploadedChunks', JSON.stringify(uploadedChunks));\n        } catch (error) {\n          console.error(error);\n          // 处理错误\n        }\n      }\n      start = end;\n      end = Math.min(start + chunkSize, file.size);\n    }\n    setUploading(false);\n    // 上传完毕，清除本地存储的切片信息\n    localStorage.removeItem('uploadedChunks');\n  };\n  useEffect(() => {\n    const storedUploadedChunks = localStorage.getItem('uploadedChunks');\n    if (storedUploadedChunks) {\n      setUploadedChunks(JSON.parse(storedUploadedChunks));\n    }\n  }, []);\n  return (\n    <div>\n      <input type=\"file\" onChange={handleFileChange} />\n      <button onClick={upload} disabled={uploading}>\n        {uploading ? '上传中...' : '上传'}\n      </button>\n    </div>\n  );\n}\n```\n\n首先，使用 useState 钩子创建了一个 uploadedChunks 状态来保存已上传的切片索引数组。初始值为空数组。\n然后，我们使用 useRef 钩子创建了一个 uploadRequestRef 引用，用于存储当前的上传请求。\n在 handleFileChange 函数中，我们更新了 file 状态以选择要上传的文件。\n在 uploadChunk 函数中，我们发送切片到服务器，并返回一个 Promise 对象来处理响应结果。\n在 upload 函数中，我们添加了断点续传的逻辑。首先，我们获取切片的总数，并设置 uploading 状态为 true 来禁用上传按钮。\n然后，我们使用 for 循环遍历所有切片。对于每个切片，我们检查 uploadedChunks 数组中是否已经包含该索引，如果不包含，则进行上传操作。\n在上传切片之后，我们将已上传的切片索引添加到 uploadedChunks 数组，并使用 localStorage 保存已上传的切片信息。\n最后，在上传完毕后，我们将 uploading 状态设为 false，并清除本地存储的切片信息。\n\n在实现大文件上传时要考虑服务器端的处理能力和存储空间，以及安全性问题。同时，为了保障断点续传的准确性，应该尽量避免并发上传相同文件的情况，可以采用文件唯一标识符或用户会话标识符进行区分。\n\n## 四、优化用户体验：切片下载与上传的应用场景\n\n### 后台管理系统中的文件下载和上传\n\n文件下载：在后台管理系统中，用户可能需要下载大型文件，如报表、日志文件、数据库备份等。通过将文件切片下载，可以提高下载速度和稳定性，同时允许用户中断下载并从中断处继续下载。\n\n文件上传：后台管理系统中，用户可能需要上传大型文件，如数据导入、文件备份等。使用切片上传可以提高上传效率，分批上传文件切片，并显示上传进度，使用户能够了解上传的状态。\n\n### 图片/视频上传和预览\n\n图片上传和预览：在图片上传场景中，用户可以选择多张图片进行上传。通过切片上传，可以加快图片上传速度，并实时显示上传进度。同时，在上传完成后，可以提供预览功能，让用户可以立即查看上传的图片。\n\n视频上传和预览：对于较大的视频文件，切片上传可以确保上传过程可靠且高效。同时，可以实现上传进度的实时展示。上传完成后，通过切片下载技术，用户可以流畅地观看视频，无需等待整个文件下载完成。\n\n### 云存储和云盘应用中的文件操作\n\n文件分块上传：云存储和云盘应用通常需要处理大量文件的上传。通过切片上传可以提高上传速度和稳定性，并允许用户中断并继续上传。\n文件分块下载：当用户需要下载云存储或云盘中的大型文件时，可以使用切片下载技术，加快下载速度并提供中断恢复功能。\n文件预览和在线编辑：通过将文件切片并进行预览，在线编辑，可以提供更好的用户体验。用户可以在不需完全下载文件的情况下，直接预览和编辑文件。\n",
    "wordCount": 3701
  },
  {
    "id": "802312278",
    "title": "class-transformer 实践",
    "date": "2020-12-14",
    "tags": [
      "typescript",
      "class-transformer"
    ],
    "fileName": "class-transformer 实践.md",
    "content": "\n## 为什么要使用这个库\n\n比如，我们在后台管理系统中要发布一篇文章，我们只需创建一个普通的平面对象，然后将所有填写的标题、内容等信息给到这个普通对象。但是，如果这个普通对象若是转为对应的类对象，则会出现以下问题：\n\n代码：\n\n```ts\nimport { plainToClass } from 'class-transformer';\nimport { validate } from 'class-validator';\nimport Express from 'express';\n\nimport Article from './model/Article';\nimport articleRoute from './routes/articleRoute';\n\nconst app = Express();\n\napp.use('/api/article', articleRoute);\n\n// 约束为平面对象\nconst article: any = {};\n\narticle.title = '12345';\narticle.content = '123';\narticle.publishTime = new Date();\n// 下面的属性是必须的，但是这里进行注释\n// article.tagList = ['12']\n\n// 按理说，这里应该要输出缺失了tagList这个属性的信息\nvalidate(article).then((errors) => {\n  console.log(errors);\n});\n\napp.listen(3000, () => console.log('服务已开启！'));\n```\n\n运行结果（没有捕获到任何信息）：\n\n![1.png](https://free4.yunpng.top/2025/02/27/67bfb1b1c37a5.png)\n\n因此，我们需要对平面对象进行转换，才可结合 class-validator 对类属性信息进行约束。\n\n## 安装\n\n```ts\nyarn add class-transformer\n```\n\n## 使用\n\n```ts\nimport { plainToClass } from 'class-transformer';\nimport { validate } from 'class-validator';\nimport Express from 'express';\n\nimport Article from './model/Article';\nimport articleRoute from './routes/articleRoute';\n\nconst app = Express();\n\napp.use('/api/article', articleRoute);\n\n// 这是个平面对象\nconst article: any = {};\n\narticle.title = '12345';\narticle.content = '123';\narticle.publishTime = new Date();\n\nconst newArticle = plainToClass(Article, article);\n\nvalidate(newArticle).then((errors) => {\n  console.log(errors);\n});\n\napp.listen(3000, () => console.log('服务已开启！'));\n```\n\n运行结果:\n\n![2.png](https://free4.yunpng.top/2025/02/27/67bfb1b1ad296.png)\n\n## 没这么简单\n\n如果，一开始给平面对象赋值时的属性的类型就不对呢？\n\n如下代码：\n\n```ts\n// 这是个平面对象\nconst article: any = {};\n\n// 类约束是的类型是字符串，这里赋值数字\narticle.title = 123;\narticle.content = '123';\narticle.publishTime = new Date();\narticle.tagList = ['123'];\n\nconst newArticle = plainToClass(Article, article);\n\nconsole.log(newArticle.title, typeof newArticle.title);\n\nvalidate(newArticle).then((errors) => {\n  console.log(errors);\n});\n```\n\n运行结果：\n\n![3.png](https://free4.yunpng.top/2025/02/27/67bfb1ec0579f.png)\n\n这里可以看出，虽然数据类型对于不上，但还是验证通过了。所以，我们需要使用 class-transform 提供给我们的运行时的类型验证。\n\n## 使用装饰器 @Type 进行运行时的类型约束\n\n1. 安装reflect-metadata\n\n```ts\nyarn add reflect-metadata\n```\n\n2. 在入口文件`index.ts`中全局导入\n\n```ts\n// 最好在第一行导入，否则可能依旧会报错\nimport 'reflect-metadata'\nimport Express from 'express'\nimport articleRoute from './routes/articleRoute'\nimport Article from './model/Article'\nimport { validate } from 'class-validator'\nimport { plainToClass } from 'class-transformer'\n...\n```\n\n3. 对Article类进行运行时的类型约束\n\n```ts\nimport { ArrayMinSize, IsDate, IsNotEmpty } from 'class-validator'\nimport { Type } from 'class-transformer'\n\nclass Article {\n\n  @IsNotEmpty({ message: '文章标题不可以为空' })\n  // 运行时的类型约束\n  @Type(() => String)\n  public title: string\n\n  @IsNotEmpty({ message: '文章标签不可以为空' })\n  @ArrayMinSize(1, { message: '文章标签至少有一个' })\n  // 文档建议如果是字符串的数组，使用字符串约束更好，因为js其实不存在数字数组，字符串数组等\n  @Type(() => String)\n  // 上面虽然解决了不是字符串的数组的问题，但是如果传进来的是一个字符串呢？这就太tm难了，所以再在编译时检查一下算了吧，运行时不管了\n  @IsArray({ message: '文章标签必须是一个数组' })\n  public tagList: string[]\n\n  @IsNotEmpty({ message: '发布日期不可以为空' })\n  @IsDate()\n  @Type(() => Date)\n  public publishTime: Date\n\n  @IsNotEmpty({ message: '文章内容不可以为空' })\n  @Type(() => String)\n  public content: string\n}\n\nexport default Article\n```\n\n4. 运行结果\n\n![4.png](https://free4.yunpng.top/2025/02/27/67bfb1ec05754.png)\n\n可以看出，已经将数字类型的 title 转为了字符串类型，同时也通过了验证。\n",
    "wordCount": 308
  },
  {
    "id": "805863812",
    "title": "async 和 await 详解",
    "date": "2020-10-25",
    "tags": [
      "javascript",
      "es6"
    ],
    "fileName": "async 和 await 详解.md",
    "content": "\n## 基本概念\n\nasync/await 是 Promise 的语法糖，让异步代码看起来像同步代码。\n\n```js\n// Promise 方式\nfunction getData() {\n  return fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .then(data => console.log(data));\n}\n\n// async/await 方式\nasync function getData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  console.log(data);\n}\n```\n\n## async 函数\n\n```js\n// async 函数总是返回 Promise\nasync function example() {\n  return 'hello';  // 自动包装成 Promise\n}\n\n// 等价于\nfunction example() {\n  return Promise.resolve('hello');\n}\n\n// 使用\nexample().then(result => console.log(result)); // 'hello'\n```\n\n## await 关键字\n\n```js\nasync function example() {\n  // await 等待 Promise 完成\n  const result1 = await promise1;\n  const result2 = await promise2;\n  return result1 + result2;\n}\n\n// await 可以等待任何值\nconst str = await 'hello'; // 直接返回\nconst num = await 123; // 直接返回\nconst p = await Promise.resolve('world'); // 等待 Promise 完成\n```\n\n## 错误处理\n\n```js\n// 方式1：try/catch\nasync function example() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\n// 方式2：链式调用\nasync function example() {\n  const data = await fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .catch(error => console.error(error));\n  return data;\n}\n```\n\n## 并行执行\n\n```js\n// 串行执行 - 较慢\nasync function serial() {\n  const result1 = await asyncOperation1();\n  const result2 = await asyncOperation2();\n  return [result1, result2];\n}\n\n// 并行执行 - 较快\nasync function parallel() {\n  // Promise.all\n  const [result1, result2] = await Promise.all([\n    asyncOperation1(),\n    asyncOperation2()\n  ]);\n  return [result1, result2];\n\n  // 或者\n  const promise1 = asyncOperation1();  // 立即开始执行\n  const promise2 = asyncOperation2();  // 立即开始执行\n  const result1 = await promise1;      // 等待完成\n  const result2 = await promise2;      // 等待完成\n}\n```\n\n## 实际应用场景\n\n```js\n// 1. API 请求\nasync function fetchUserData(userId) {\n  try {\n    const response = await fetch(`/api/users/${userId}`);\n    const userData = await response.json();\n    return userData;\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    throw error;\n  }\n}\n\n// 2. 多个依赖请求\nasync function getUserWithPosts(userId) {\n  // 并行请求用户信息和文章\n  const [user, posts] = await Promise.all([fetchUser(userId), fetchUserPosts(userId)]);\n\n  return {\n    ...user,\n    posts,\n  };\n}\n\n// 3. 条件请求\nasync function conditionalFetch(id) {\n  const data = await fetchInitialData(id);\n\n  if (data.needsExtra) {\n    const extraData = await fetchExtraData(id);\n    return { ...data, ...extraData };\n  }\n\n  return data;\n}\n```\n\n## 循环中的 async/await\n\n```js\n// 串行处理\nasync function processArray(array) {\n  for (const item of array) {\n    await processItem(item);  // 一个接一个处理\n  }\n}\n\n// 并行处理\nasync function processArray(array) {\n  const promises = array.map(item => processItem(item));\n  await Promise.all(promises);  // 同时处理所有项\n}\n\n// forEach 不能正确处理 async/await\narray.forEach(async item => {  // 错误！不会等待\n  await processItem(item);\n});\n```\n\n## 最佳实践\n\n```js\n// 1. 总是使用 try/catch 处理错误\nasync function example() {\n  try {\n    const result = await riskyOperation();\n    return result;\n  } catch (error) {\n    // 处理错误\n    console.error(error);\n    // 可以选择重新抛出\n    throw error;\n  }\n}\n\n// 2. 合理使用并行处理\nasync function fetchAllData() {\n  const [users, posts, comments] = await Promise.all([\n    fetchUsers(),\n    fetchPosts(),\n    fetchComments()\n  ]);\n  return { users, posts, comments };\n}\n\n// 3. 避免无谓的 await\nasync function example() {\n  const promise = fetchData();  // 立即开始\n  // 做其他事情\n  const result = await promise; // 需要结果时才等待\n}\n```\n\n## async/await 向 promise 转换示例\n\n### async 函数\n\n```js\n// async 函数\nasync function foo() {\n  return 'hello';\n}\n\n// 转换为 Promise\nfunction foo() {\n  return Promise.resolve('hello');\n}\n```\n\n### await 表达式\n\n```js\n// async/await 版本\nasync function example() {\n  const result = await somePromise();\n  return result + 1;\n}\n\n// 转换为 Promise 版本\nfunction example() {\n  return new Promise((resolve, reject) => {\n    somePromise()\n      .then(result => {\n        resolve(result + 1);\n      })\n      .catch(reject);\n  });\n}\n```\n\n### 多个 await 表达式\n\n```js\n// async/await 版本\nasync function getData() {\n  const data1 = await fetch('/api/data1');\n  const data2 = await fetch('/api/data2');\n  return data1 + data2;\n}\n\n// 转换为 Promise 版本\nfunction getData() {\n  return new Promise((resolve, reject) => {\n    fetch('/api/data1')\n      .then(data1 => {\n        return fetch('/api/data2')\n          .then(data2 => {\n            resolve(data1 + data2);\n          });\n      })\n      .catch(reject);\n  });\n}\n```\n\n### try/catch\n\n```js\n// async/await 版本\nasync function example() {\n  try {\n    const result = await riskyOperation();\n    return result;\n  } catch (error) {\n    console.error(error);\n    return 'default';\n  }\n}\n\n// 转换为 Promise 版本\nfunction example() {\n  return new Promise((resolve) => {\n    riskyOperation()\n      .then(result => {\n        resolve(result);\n      })\n      .catch(error => {\n        console.error(error);\n        resolve('default');\n      });\n  });\n}\n```\n\n### 复杂流程控制\n\n```js\n// async/await 版本\nasync function processData() {\n  const data = await fetchData();\n  if (data.needsExtra) {\n    const extra = await fetchExtra();\n    return { ...data, ...extra };\n  }\n  return data;\n}\n\n// 转换为 Promise 版本\nfunction processData() {\n  return new Promise((resolve, reject) => {\n    fetchData()\n      .then(data => {\n        if (data.needsExtra) {\n          return fetchExtra()\n            .then(extra => {\n              resolve({ ...data, ...extra });\n            });\n        }\n        resolve(data);\n      })\n      .catch(reject);\n  });\n}\n```\n\n### 循环\n\n```js\n// async/await 版本\nasync function processItems(items) {\n  const results = [];\n  for (const item of items) {\n    const result = await processItem(item);\n    results.push(result);\n  }\n  return results;\n}\n\n// 转换为 Promise 版本\nfunction processItems(items) {\n  return new Promise((resolve, reject) => {\n    const results = [];\n    let promise = Promise.resolve();\n\n    items.forEach(item => {\n      promise = promise\n        .then(() => processItem(item))\n        .then(result => {\n          results.push(result);\n        });\n    });\n\n    promise\n      .then(() => resolve(results))\n      .catch(reject);\n  });\n}\n```\n\n### 并行操作\n\n```js\n// async/await 版本\nasync function parallel() {\n  const [result1, result2] = await Promise.all([\n    asyncOp1(),\n    asyncOp2()\n  ]);\n  return result1 + result2;\n}\n\n// 转换为 Promise 版本\nfunction parallel() {\n  return Promise.all([asyncOp1(), asyncOp2()])\n    .then(([result1, result2]) => {\n      return result1 + result2;\n    });\n}\n```\n\n**转换的核心原则：**\n\n- async 函数总是返回 Promise\n- await 表达式转换为 .then() 调用\n- 错误处理转换为 .catch()\n- 保持执行顺序\n- 维护变量作用域\n\n这种转换通常是由 JavaScript 引擎或转译器（如 Babel）自动完成的，我们不需要手动进行这种转换。理解这个转换过程有助于我们更好地理解 async/await 的工作原理。\n\n## 注意事项\n\n1. async 函数总是返回 Promise\n2. await 只能在 async 函数内使用\n3. 错误会沿着调用链传播\n4. 注意区分串行和并行操作\n5. 小心循环中的 async/await\n\nasync/await 是现代 JavaScript 中处理异步操作的最佳方式，它让异步代码更容易理解和维护。合理使用 async/await 可以大大提高代码的可读性和可维护性。\n",
    "wordCount": 303
  },
  {
    "id": "572155432",
    "title": "手写一个简易版的 Promise",
    "date": "2020-10-21",
    "tags": [
      "javascript",
      "es6"
    ],
    "fileName": "手写一个简易版的 Promise.md",
    "content": "\n## 前言\n\nPromise 是 JavaScript 中用于处理异步操作的对象，它代表了一个异步操作的最终完成（或失败）及其结果值。\n\n## 用法\n\n### 创建 Promise\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('成功');\n  }, 1000);\n});\n```\n\n### 使用 Promise\n\n```js\npromise.then((result) => {\n  console.log(result);\n});\n```\n\n## 实现原理\n\n### 基础结构和构造函数\n\n```js\nclass MyPromise {\n  constructor(fn) {\n    // Promise 状态\n    this.status = 'pending';\n    // 成功值\n    this.value = null;\n    // 失败原因\n    this.reason = null;\n    // 成功回调队列\n    this.onFulfilledCallbacks = [];\n    // 失败回调队列\n    this.onRejectedCallbacks = [];\n\n    // resolve 处理函数\n    const resolve = (value) => {\n      if (this.status === 'pending') {\n        this.status = 'fulfilled';\n        this.value = value;\n        this.onFulfilledCallbacks.forEach((callback) => callback(value));\n      }\n    };\n\n    // reject 处理函数\n    const reject = (reason) => {\n      if (this.status === 'pending') {\n        this.status = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach((callback) => callback(reason));\n      }\n    };\n\n    // 执行传入的函数\n    try {\n      fn(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n}\n```\n\n关键点：\n\n- 维护 Promise 的三种状态：pending、fulfilled、rejected\n- 使用回调队列存储异步操作的回调函数\n- 状态一旦改变就不可逆\n\n### then 方法实现\n\n```js\nthen(onFulfilled, onRejected) {\n  // 参数校验，确保是函数\n  onFulfilled =\n    typeof onFulfilled === \"function\" ? onFulfilled : (value) => value;\n  onRejected =\n    typeof onRejected === \"function\"\n      ? onRejected\n      : (reason) => {\n          throw reason;\n        };\n  // 返回新的 Promise 以支持链式调用\n  const promise2 = new MyPromise((resolve, reject) => {\n    if (this.status === \"fulfilled\") {\n      setTimeout(() => {\n        try {\n          const x = onFulfilled(this.value);\n          resolvePromise(promise2, x, resolve, reject);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n    if (this.status === \"rejected\") {\n      setTimeout(() => {\n        try {\n          const x = onRejected(this.reason);\n          resolvePromise(promise2, x, resolve, reject);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    }\n    if (this.status === \"pending\") {\n      this.onFulfilledCallbacks.push(() => {\n        setTimeout(() => {\n          try {\n            const x = onFulfilled(this.value);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n      this.onRejectedCallbacks.push(() => {\n        setTimeout(() => {\n          try {\n            const x = onRejected(this.reason);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n    }\n  });\n  return promise2;\n}\n```\n\n关键点：\n\n- 支持链式调用\n- 使用 setTimeout 确保异步执行\n- 处理返回值的 Promise 状态\n\n### resolvePromise 方法实现\n\n```js\nfunction resolvePromise(promise2, x, resolve, reject) {\n  // 防止循环引用\n  if (promise2 === x) {\n    return reject(new TypeError('Chaining cycle detected for promise'));\n  }\n\n  // 处理返回值为 Promise 的情况\n  if (x instanceof MyPromise) {\n    x.then((value) => {\n      resolvePromise(promise2, value, resolve, reject);\n    }).catch(reject);\n  } else {\n    // 普通值直接 resolve\n    resolve(x);\n  }\n}\n```\n\n关键点：\n\n- 处理循环引用问题\n- 处理返回值为 Promise 的情况\n- 递归解析 Promise\n\n### 静态方法实现\n\n```js\n// 创建一个已完成的 Promise\nstatic resolve(value) {\n  return new MyPromise(resolve => resolve(value));\n}\n\n// 创建一个已拒绝的 Promise\nstatic reject(reason) {\n  return new MyPromise((_, reject) => reject(reason));\n}\n\n// 等待所有 Promise 完成\nstatic all(promises) {\n  return new MyPromise((resolve, reject) => {\n    const results = [];\n    promises.forEach((promise, index) => {\n      MyPromise.resolve(promise)\n        .then(value => {\n          results[index] = value;\n          if (results.length === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}\n\n// 返回最先完成的 Promise\nstatic race(promises) {\n  return new MyPromise((resolve, reject) => {\n    promises.forEach(promise => {\n      MyPromise.resolve(promise)\n        .then(resolve)\n        .catch(reject);\n    });\n  });\n}\n\n// 返回所有 Promise 的状态和结果\nstatic allSettled(promises) {\n  return new MyPromise((resolve) => {\n    const results = [];\n    promises.forEach((promise, index) => {\n      MyPromise.resolve(promise)\n        .then((value) => {\n          results[index] = { status: \"fulfilled\", value };\n          if (results.length === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch((reason) => {\n          results[index] = { status: \"rejected\", reason };\n          if (results.length === promises.length) {\n            resolve(results);\n          }\n        });\n    });\n  });\n}\n```\n\n### 辅助方法实现\n\n```js\n// 错误处理\ncatch(onRejected) {\n  return this.then(null, onRejected);\n}\n\n// 无论成功失败都会执行\nfinally(callback) {\n  return this.then(callback, callback);\n}\n```\n\n## 完整代码\n\n```js\n// 手写简版 promise\nclass MyPromise {\n  constructor(fn) {\n    this.status = 'pending';\n    this.value = null;\n    this.reason = null;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n    const resolve = (value) => {\n      if (this.status === 'pending') {\n        this.status = 'fulfilled';\n        this.value = value;\n        this.onFulfilledCallbacks.forEach((callback) => callback(value));\n      }\n    };\n    const reject = (reason) => {\n      if (this.status === 'pending') {\n        this.status = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach((callback) => callback(reason));\n      }\n    };\n    try {\n      fn(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (value) => value;\n    onRejected =\n      typeof onRejected === 'function'\n        ? onRejected\n        : (reason) => {\n            throw reason;\n          };\n    const promise2 = new MyPromise((resolve, reject) => {\n      if (this.status === 'fulfilled') {\n        setTimeout(() => {\n          try {\n            const x = onFulfilled(this.value);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      }\n      if (this.status === 'rejected') {\n        setTimeout(() => {\n          try {\n            const x = onRejected(this.reason);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      }\n      if (this.status === 'pending') {\n        this.onFulfilledCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onFulfilled(this.value);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        });\n        this.onRejectedCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onRejected(this.reason);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        });\n      }\n    });\n    return promise2;\n  }\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n  finally(callback) {\n    return this.then(callback, callback);\n  }\n  static resolve(value) {\n    return new MyPromise((resolve) => resolve(value));\n  }\n  static reject(reason) {\n    return new MyPromise((_, reject) => reject(reason));\n  }\n  static all(promises) {\n    return new MyPromise((resolve, reject) => {\n      const results = [];\n      promises.forEach((promise, index) => {\n        MyPromise.resolve(promise)\n          .then((value) => {\n            results[index] = value;\n            if (results.length === promises.length) {\n              resolve(results);\n            }\n          })\n          .catch(reject);\n      });\n    });\n  }\n  static race(promises) {\n    return new MyPromise((resolve, reject) => {\n      promises.forEach((promise) => {\n        MyPromise.resolve(promise).then(resolve).catch(reject);\n      });\n    });\n  }\n  static allSettled(promises) {\n    return new MyPromise((resolve) => {\n      const results = [];\n      promises.forEach((promise, index) => {\n        MyPromise.resolve(promise)\n          .then((value) => {\n            results[index] = { status: 'fulfilled', value };\n            if (results.length === promises.length) {\n              resolve(results);\n            }\n          })\n          .catch((reason) => {\n            results[index] = { status: 'rejected', reason };\n            if (results.length === promises.length) {\n              resolve(results);\n            }\n          });\n      });\n    });\n  }\n}\n\nfunction resolvePromise(promise2, x, resolve, reject) {\n  if (promise2 === x) {\n    return reject(new TypeError('Chaining cycle detected for promise'));\n  }\n  if (x instanceof MyPromise) {\n    x.then((value) => {\n      resolvePromise(promise2, value, resolve, reject);\n    }).catch(reject);\n  } else {\n    resolve(x);\n  }\n}\n```\n\n## 总结\n\n这个实现涵盖了 Promise 的主要特性：\n\n- Promise 状态管理\n- 异步操作处理\n- 链式调用\n- 错误处理\n- 常用静态方法\n\n需要注意的是，这是一个简化版的实现，完整的 Promise/A+ 规范还包括更多的边界情况处理。但这个实现已经可以满足大多数使用场景。\n",
    "wordCount": 274
  },
  {
    "id": "71788929",
    "title": "Promise 指南",
    "date": "2020-10-15",
    "tags": [
      "javascript",
      "es6"
    ],
    "fileName": "Promise 指南.md",
    "content": "\n## Promise 是什么\n\nPromise 是 JavaScript 中用于处理异步操作的对象，它代表了一个异步操作的最终完成（或失败）及其结果值。\n\n## Promise 的状态\n\nPromise 有三种状态：\n\n```js\n// 1. pending（进行中）\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作尚未完成\n});\n\n// 2. fulfilled（已成功）\nconst promise = new Promise((resolve, reject) => {\n  resolve('success');\n});\n\n// 3. rejected（已失败）\nconst promise = new Promise((resolve, reject) => {\n  reject('error');\n});\n```\n\n特点：\n\n- 状态只能从 pending 转为 fulfilled 或 rejected\n- 状态一旦改变，就不会再变\n\n## Promise 的基本用法\n\n```js\n// 创建 Promise\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  setTimeout(() => {\n    if (/* 操作成功 */) {\n      resolve('success');\n    } else {\n      reject('error');\n    }\n  }, 1000);\n});\n\n// 使用 Promise\npromise\n  .then(result => {\n    console.log(result); // 处理成功\n  })\n  .catch(error => {\n    console.log(error);  // 处理失败\n  })\n  .finally(() => {\n    console.log('完成'); // 无论成功失败\n  });\n```\n\n## Promise 的链式调用\n\n```js\n// 链式调用示例\nnew Promise((resolve, reject) => {\n  resolve(1);\n})\n  .then((value) => {\n    return value + 1; // 2\n  })\n  .then((value) => {\n    return value * 2; // 4\n  })\n  .then((value) => {\n    console.log(value); // 4\n  });\n```\n\n## Promise 的静态方法\n\n```js\n// Promise.resolve\nPromise.resolve('success').then((value) => {\n  console.log(value); // 'success'\n});\n\n// Promise.reject\nPromise.reject('error').catch((error) => {\n  console.log(error); // 'error'\n});\n\n// Promise.all - 所有Promise都成功才成功\nPromise.all([promise1, promise2, promise3]).then((results) => {\n  console.log(results); // [result1, result2, result3]\n});\n\n// Promise.race - 返回最快的Promise结果\nPromise.race([promise1, promise2]).then((result) => {\n  console.log('最快完成的结果:', result);\n});\n\n// Promise.allSettled - 等待所有Promise完成\nPromise.allSettled([promise1, promise2]).then((results) => {\n  // 返回所有Promise的结果，包括成功和失败\n});\n```\n\n## 错误处理\n\n```js\n// 方式1：使用 catch\npromise\n  .then((result) => {})\n  .catch((error) => {\n    console.log('捕获错误:', error);\n  });\n\n// 方式2：then 的第二个参数\npromise.then(\n  (result) => {},\n  (error) => {\n    console.log('捕获错误:', error);\n  }\n);\n```\n\n## Promise 的优势\n\n1. 解决回调地狱\n\n```js\n// 回调地狱\nasyncFunc1(function (result1) {\n  asyncFunc2(result1, function (result2) {\n    asyncFunc3(result2, function (result3) {\n      console.log(result3);\n    });\n  });\n});\n\n// Promise 方式\nasyncFunc1()\n  .then((result1) => asyncFunc2(result1))\n  .then((result2) => asyncFunc3(result2))\n  .then((result3) => console.log(result3));\n```\n\n2. 更好的错误处理\n3. 链式调用更清晰\n4. 支持并行操作\n\n## 实际应用场景\n\n```js\n// 1. 网络请求\nfetch('https://api.example.com/data')\n  .then((response) => response.json())\n  .then((data) => console.log(data));\n\n// 2. 文件操作\nreadFile('file.txt')\n  .then((content) => writeFile('new.txt', content))\n  .then(() => console.log('完成'));\n\n// 3. 延时操作\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\ndelay(1000).then(() => console.log('1秒后执行'));\n```\n\n## 注意事项\n\n1. Promise 一旦创建就会执行\n2. then 方法返回新的 Promise\n3. 错误会沿着链式调用传递\n4. Promise 状态一旦改变就不可逆\n5. finally 不接收参数\n\n## 最佳实践\n\n```js\n// 1. 始终使用 catch 处理错误\n// 2. 合理使用 Promise.all 和 Promise.race\n// 3. 避免嵌套 Promise\n// 4. 使用 async/await 让代码更简洁\nasync function example() {\n  try {\n    const result = await somePromise();\n    return result;\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n",
    "wordCount": 187
  },
  {
    "id": "688339781",
    "title": "Set、Map 和 WeakMap 全解",
    "date": "2020-09-27",
    "tags": [
      "javascript",
      "es6"
    ],
    "fileName": "Set、Map 和 WeakMap 全解.md",
    "content": "\n## Set\n\n### 前言\n\n- Set 是 ES6 引入的一种新的数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。\n- Set 本身是一个构造函数，可以接受一个数组（或具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n### 基础使用\n\n```js\n// 创建 Set\nconst set = new Set();\n\n// 添加值\nset.add(1);\nset.add('text');\nset.add({ x: 10 });\n\n// 链式调用\nset.add(1).add(2).add(3);\n\n// 检查值是否存在\nconsole.log(set.has(1)); // true\n\n// 删除值\nset.delete(1);\n\n// 获取大小\nconsole.log(set.size);\n\n// 清空 Set\nset.clear();\n```\n\n### 特点\n\n```js\n// 1. 值的唯一性\nconst set = new Set([1, 1, 2, 2, 3, 3]);\nconsole.log(set); // Set(3) {1, 2, 3}\n\n// 2. NaN 的处理\nconst set = new Set([NaN, NaN]);\nconsole.log(set.size); // 1\n\n// 3. +0 和 -0 被视为相同\nconst set = new Set([+0, -0]);\nconsole.log(set.size); // 1\n\n// 4. 对象引用不同则视为不同值\nconst set = new Set();\nset.add({});\nset.add({});\nconsole.log(set.size); // 2\n```\n\n### 常用操作\n\n```js\n// 1. 数组去重\nconst array = [1, 2, 2, 3, 3, 4];\nconst uniqueArray = [...new Set(array)];\nconsole.log(uniqueArray); // [1, 2, 3, 4]\n\n// 2. 字符串去重\nconst str = 'hello';\nconst uniqueStr = [...new Set(str)].join('');\nconsole.log(uniqueStr); // 'helo'\n\n// 3. Set 转数组\nconst set = new Set([1, 2, 3]);\nconst array1 = Array.from(set);\nconst array2 = [...set];\n\n// 4. 遍历操作\nconst set = new Set(['a', 'b', 'c']);\n\n// forEach\nset.forEach(value => {\n  console.log(value);\n});\n\n// for...of\nfor (const value of set) {\n  console.log(value);\n}\n```\n\n### 集合操作\n\n```js\n// 1. 并集\nfunction union(setA, setB) {\n  return new Set([...setA, ...setB]);\n}\n\n// 2. 交集\nfunction intersection(setA, setB) {\n  return new Set([...setA].filter((x) => setB.has(x)));\n}\n\n// 3. 差集\nfunction difference(setA, setB) {\n  return new Set([...setA].filter((x) => !setB.has(x)));\n}\n\n// 使用示例\nconst setA = new Set([1, 2, 3]);\nconst setB = new Set([2, 3, 4]);\n\nconsole.log(union(setA, setB)); // Set(4) {1, 2, 3, 4}\nconsole.log(intersection(setA, setB)); // Set(2) {2, 3}\nconsole.log(difference(setA, setB)); // Set(1) {1}\n```\n\n## Map\n\n### 前言\n\nMap 是 ES6 引入的一种新的数据结构，它类似于对象，但是键值对的键可以是任意类型。\n\n### 基础使用\n\n```js\n// 创建 Map\nconst map = new Map();\n\n// 设置键值对\nmap.set('name', 'Alice');\nmap.set(1, 'number one');\nmap.set({}, 'object');\n\n// 链式调用\nmap.set('a', 1).set('b', 2).set('c', 3);\n\n// 获取值\nconsole.log(map.get('name')); // 'Alice'\n\n// 检查键是否存在\nconsole.log(map.has('name')); // true\n\n// 删除键值对\nmap.delete('name');\n\n// 获取大小\nconsole.log(map.size);\n\n// 清空 Map\nmap.clear();\n```\n\n### 特点\n\n```js\n// 1. 任何类型都可以作为键\nconst map = new Map();\n\n// 使用对象作为键\nconst objKey = { id: 1 };\nmap.set(objKey, 'object value');\n\n// 使用函数作为键\nconst fnKey = function () {};\nmap.set(fnKey, 'function value');\n\n// 使用 NaN 作为键\nmap.set(NaN, 'NaN value');\nconsole.log(map.get(NaN)); // 'NaN value'\n\n// 2. 键的比较使用 Same-value-zero 算法\nmap.set(-0, 'negative zero');\nconsole.log(map.get(+0)); // 'negative zero'\n\n// 3. 保持插入顺序\nconst orderedMap = new Map([\n  ['first', 1],\n  ['second', 2],\n  ['third', 3],\n]);\n\n// 遍历按插入顺序进行\nfor (const [key, value] of orderedMap) {\n  console.log(key, value);\n}\n```\n\n## WeakMap\n\n### 前言\n\nWeakMap 和 Map 功能类似，只不过它具有弱引用的特点且只能使用对象作为键。\n\n### 基础使用\n\n```js\n// 创建 WeakMap\nconst weakMap = new WeakMap();\n\n// 只能使用对象作为键\nconst obj = { id: 1 };\nweakMap.set(obj, 'object data');\n\n// 获取值\nconsole.log(weakMap.get(obj));\n\n// 检查键是否存在\nconsole.log(weakMap.has(obj));\n\n// 删除键值对\nweakMap.delete(obj);\n```\n\n### 特点\n\n```js\n// 1. 弱引用特性\nlet obj = { id: 1 };\nconst weakMap = new WeakMap();\nweakMap.set(obj, 'data');\n\nobj = null; // 对象可被垃圾回收\n// weakMap 中的键值对会自动被清除\n\n// 2. 不可遍历\n// 没有 size 属性\n// 没有 clear() 方法\n// 不能使用 for...of\n\n// 3. 只接受对象作为键\n// 这些都会报错\nweakMap.set(1, 'value');\nweakMap.set('key', 'value');\nweakMap.set(true, 'value');\n```\n\n## Map vs WeakMap\n\n### 引用区别\n\n```js\n// Map：强引用\nconst map = new Map();\nlet obj = { id: 1 };\nmap.set(obj, 'data');\nobj = null; // 原对象仍然在 map 中\n\n// WeakMap：弱引用\nconst weakMap = new WeakMap();\nlet obj2 = { id: 2 };\nweakMap.set(obj2, 'data');\nobj2 = null; // 对象可被垃圾回收\n```\n\n### 性能区别\n\n```js\n// 1. 频繁增删键值对\nconst map = new Map(); // 适合\n\n// 2. 存储对象关联数据，且需要自动清理\nconst weakMap = new WeakMap(); // 适合\n\n// 3. 需要遍历操作\nconst map = new Map(); // 适合\n// WeakMap 不支持遍历\n\n// 4. 内存敏感的场景\nconst weakMap = new WeakMap(); // 适合\n```\n\n### 最佳实践\n\n```js\n// 1. 使用 Map 的场景\n// - 需要频繁添加/删除键值对\n// - 需要遍历键值对\n// - 需要获取键值对数量\nconst userRoles = new Map();\nuserRoles.set(user1, ['admin']);\nuserRoles.set(user2, ['user']);\n\n// 2. 使用 WeakMap 的场景\n// - 存储对象的元数据\n// - DOM 节点相关数据\n// - 需要自动垃圾回收\nconst domData = new WeakMap();\ndomData.set(element, {\n  clickCount: 0,\n  lastClicked: null,\n});\n```\n\n选择使用 Map 还是 WeakMap 主要考虑：\n\n1. 键的类型（是否只用对象）\n2. 是否需要遍历\n3. 内存管理需求\n4. 是否需要获取集合大小\n5. 是否需要清空操作\n",
    "wordCount": 242
  },
  {
    "id": "1760989906",
    "title": "对 MVC 和 MVVM 的理解",
    "date": "2020-09-13",
    "tags": [
      "软件架构",
      "react",
      "vue"
    ],
    "fileName": "对 MVC 和 MVVM 的理解.md",
    "content": "\n## MVC（Model-View-Controller）与 React\n\n### MVC 核心思想\n\n- Model（模型）：管理数据和业务逻辑（如数据获取、存储、验证）。\n- View（视图）：负责 UI 的呈现（如 HTML、CSS）。\n- Controller（控制器）：处理用户输入，协调 Model 和 View 的交互。\n\n### React 如何体现 MVC 模式\n\nReact 本身更侧重 View 层，但结合其他库（如 Redux、Context API）可实现类似 MVC 的架构：\n\n| 角色       | React 中的对应                                                                    |\n| ---------- | --------------------------------------------------------------------------------- |\n| Model      | 状态管理工具（如 Redux Store、Context API 的全局状态、组件内部的 useState）       |\n| View       | React 组件（JSX 描述 UI，通过 Props 和 State 渲染）                               |\n| Controller | 事件处理函数（如 onClick）、Redux 的 Actions/Reducers、自定义 Hooks（业务逻辑）。 |\n\n### React 的 MVC 数据流\n\n1. 用户触发事件（如点击按钮），调用 Controller 逻辑（如 Redux Action）。\n2. Controller 更新 Model（如修改 Redux Store 的状态）。\n3. Model 变化触发 View 更新（React 组件重新渲染）。\n\n示例（React + Redux）：\n\n```jsx\n// Model (Redux Store)\nconst initialState = { count: 0 };\nfunction counterReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    default:\n      return state;\n  }\n}\n\n// View (React Component)\nconst Counter = ({ count, increment }) => (\n  <div>\n    <p>{count}</p>\n    <button onClick={increment}>+</button>\n  </div>\n);\n\n// Controller (Redux Action)\nconst mapDispatch = (dispatch) => ({\n  increment: () => dispatch({ type: 'INCREMENT' }),\n});\nexport default connect(mapState, mapDispatch)(Counter);\n```\n\n### React MVC 的特点\n\n- 单向数据流：数据从 Model → View → Controller → Model 循环。\n- 职责分离：状态管理（Model）、UI 渲染（View）、逻辑处理（Controller）解耦。\n- 灵活性：需要手动管理状态和逻辑的传递（如 Props Drilling）。\n\n## MVVM（Model-View-ViewModel）与 Vue\n\n### MVVM 核心思想\n\n- Model（模型）：管理数据和业务逻辑（与 MVC 的 Model 类似）。\n- View（视图）：UI 的声明式描述（如 Vue 模板）。\n- ViewModel（视图模型）：连接 View 和 Model 的桥梁，通过数据绑定自动同步两者。\n\n### Vue 如何实现 MVVM？\n\nVue 是典型的 MVVM 框架，其核心是 响应式系统 和 模板语法：\n\n| 角色      | Vue 中的对应                                           |\n| --------- | ------------------------------------------------------ |\n| Model     | Vue 组件的 data 属性、Pinia/Vuex 的状态                |\n| View      | Vue 模板（.vue 文件中的 <template> 部分）              |\n| ViewModel | Vue 实例（自动生成的响应式系统，处理模板与数据的绑定） |\n\n### Vue 的 MVVM 数据流\n\n1. View 中声明数据绑定（如 {{ count }} 或 v-model）。\n\n2. ViewModel 监听 Model 变化，自动更新 View。\n\n3. 用户操作 View（如输入框输入），ViewModel 自动更新 Model。\n\n示例：\n\n```vue\n<template>\n  <!-- View -->\n  <div>\n    <p>{{ count }}</p>\n    <button @click=\"increment\">+</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  // Model\n  data() {\n    return { count: 0 };\n  },\n  // ViewModel (逻辑处理)\n  methods: {\n    increment() {\n      this.count++;\n    }\n  }\n};\n</script>\n```\n\n### Vue MVVM 的特点\n\n- 双向数据绑定：通过 v-model 实现 View 和 Model 的自动同步。\n- 声明式编程：模板中直接绑定数据和事件，无需手动操作 DOM。\n- 响应式系统：基于依赖追踪的自动更新（无需手动触发渲染）。\n\n## MVC（React） vs MVVM（Vue）对比\n\n| 特性     | React MVC                           | Vue MVVM                               |\n| -------- | ----------------------------------- | -------------------------------------- |\n| 数据流   | 单向数据流（需手动管理状态传递）    | 双向数据绑定（自动同步 View 和 Model） |\n| 状态管理 | 依赖外部库（如 Redux、Context API） | 内置响应式系统（data + reactive）      |\n| UI 更新  | 通过 Virtual DOM Diff 优化渲染      | 基于依赖追踪的精准更新                 |\n| 代码风格 | 函数式编程（Hooks + JSX）           | 声明式模板 + 选项式/组合式 API         |\n| 适用场景 | 大型复杂应用，需高度定制化架构      | 中小型应用，快速开发，注重开发体验     |\n\n## 总结\n\nReact 的 MVC 模式\n\n- 强调单向数据流和职责分离，适合需要精细控制状态和逻辑的场景。\n- 需要结合其他库实现完整的 MVC 架构。\n\nVue 的 MVVM 模式\n\n- 通过响应式系统和双向绑定简化开发，适合快速迭代和中小型项目。\n- 内置的 ViewModel 自动处理数据与视图的同步。\n\n根据项目需求选择框架：\n\n- 选择 React：需要高度灵活性和可扩展性的大型应用。\n- 选择 Vue：追求开发效率和简洁性的中小型应用。\n",
    "wordCount": 844
  },
  {
    "id": "1155390892",
    "title": "React 工程中 SVG 的高级使用方法",
    "date": "2020-09-09",
    "tags": [
      "react",
      "webpack",
      "svg"
    ],
    "fileName": "React 工程中 SVG 的高级使用方法.md",
    "content": "\n## 比较 low 的做法\n\n打开 create-react-app 的官方文档，它会告诉你使用 svg，将 svg 进行导入（实际导入的是 svg 的路径字符串），然后放到 img 的 src 上。这种方法我们称为将 svg 当做图片使用。\n\n为什么这种方式不好？\n\n比如：无法改变 svg 的颜色\n\n## 使用 svg-sprite-loader（自己配置法）\n\n使用 svg-sprite-loader 要在 webpack.config.js 里配置，但是我们用 create-react-app 搭建起来的项目里没有 webpack 的配置文件。\n\n使用 `yarn eject` 命令，可以把配置文件弄出来。运行后，发现项目下多了两个目录，其中就有 webpack.config.js，我们就可以修改它进行配置。按照官网配置即可。\n\n注意：一定要先进行 git commit，才能运行 eject，否则会无法成功弹出配置。\n\n### 步骤\n\n1. 安装两个 loader\n\n```\nyarn add --dev svg-sprite-loader\nyarn add --dev svgo-loader\n```\n\n2. 在 webpack.config.js 中配置这两个 loader\n\n```js\n{\n  test: /\\.svg$/,\n  use: [\n    { loader: 'svg-sprite-loader', options: {} },\n    { loader: 'svgo-loader', options: {} },\n  ]\n},\n```\n\n3. 使用\n\nApp.tsx\n\n```tsx\nimport x from \"icons/apple.svg\";\n\nconsole.log(x) // 查看浏览器dom树，可以发现多了一个svg\n\n// 多出来的svg如下：\n<svg fill='red'>\n   <use xlinkHref='#apple'/>\n</svg>\n```\n\napple 就是文件名。svg 上还可以直接加 fill 属性来改变颜色。\n引入的 x 如果不使用，就是如果不打印，页面上的图标就看不到了。必须用一下图标才能生效。这是因为treeshaking，意思是，如果你用不上一个东西，我就把他从树上摇下来。react 发现你引入了 x，但是没使用，就会把它删了。\n那我怎么样既能引入也不需要打印呢？\ntreeshaking 不适用于 require，所以可以用 require导入\n\n4. 封装 svg 成 icon 组件\n\n现在每次使用 svg 都要写三句代码，还要 require 引入。避免重复，把它封装成组件。\n\n```tsx\nimport React from 'react';\n\nconst importAll = (requireContext: __WebpackModuleApi.RequireContext) => requireContext.keys().forEach(requireContext);\ntry {\n  importAll(require.context('../icons', true, /\\.svg$/));\n} catch (error) {\n  console.log(error);\n}\n\ntype Props = {\n  name: string;\n};\n\nfunction Icon(props: Props) {\n  return (\n    <svg className=\"icon\">\n      <use xlinkHref={'#' + props.name} />\n    </svg>\n  );\n}\n\nexport default Icon;\n```\n\n说明：\n\n把 require 导入也放进来。但是如果有 100 个 svg，就要写 100 次 require。所以我们选择直接导入一个目录，这个目录里存放所有的 svg。这里封装为 importAll。\n\n但是有报错，说找不到 `__WebpackModuleApi`，这是因为在 ts 里不支持这个的问题。去谷歌搜索解决方案。\n安装：`yarn add --dev @types/webpack-env` 就可以解决。\n\n其他组件想使用 Icon，一句话引入即可 `<Icon name='chart'/>` name 属性是文件名。\n\nIcon 如果想改变颜色，可以直接在 css 里用 fill 改变：\n\n```css\n.icon {\n  fill: rgb(140, 177, 253);\n}\n```\n\n可是有一些svg图标是自带颜色的，在它们的文件里会通过 fill 属性指定颜色。如果是这种情况，就改不了颜色了。我们可以选择手动去它们的 svg 文件里删除 fill 属性，但是如果有很多图标，一个个删除太慢了。\n\nsvgo-loader 有一个功能，可以删除fill属性，只需要把需要的语句添加到配置文件的 svgo-loader 后边的选项options 里边就可以。\nsvgo 就是 svg optimizer 优化器的意思。\n\n```js\n{ loader: 'svgo-loader', options: {\n  plugins:[\n      {removeAttrs: {attrs:'fill'}}\n    ]\n  }\n},\n```\n",
    "wordCount": 682
  },
  {
    "id": "76987253",
    "title": "使用 useReducer 和 Context 实现 redux 的功能",
    "date": "2020-07-24",
    "tags": [
      "react",
      "redux"
    ],
    "fileName": "使用 useReducer 和 Context 实现 redux 的功能.md",
    "content": "\n## 使用 useReducer 和 Context 实现 redux 的功能\n\n步骤：\n\n1. 将数据集中在一个 store 对象\n2. 将所有操作集中在 reducer\n3. 创建一个 Context\n4. 创建对数据的读写 API\n5. 将第4步的内容放到第 3 步的 Context 中\n6. 用 Context.Provider 将 Context 提供给所有组件\n7. 各个组件用 useContext 获取读写 API\n\n代码演示：\n\n```tsx\nimport React, { Dispatch, createContext, useContext, useEffect, useReducer } from 'react';\n\nimport './App.css';\n\ninterface IPersonState {\n  books: string[];\n  movies: string[];\n}\n\ntype IPersonAction = {\n  type: 'getBooks' | 'getMovies';\n  payload: string[];\n};\n\nconst initialState: IPersonState = {\n  books: [],\n  movies: [],\n};\n\nfunction reducer(state: IPersonState = initialState, action: IPersonAction) {\n  if (action.type === 'getBooks') {\n    return { ...state, books: action.payload };\n  }\n  if (action.type === 'getMovies') {\n    return { ...state, movies: action.payload };\n  }\n  return state;\n}\n\nexport interface IContextValue {\n  state: IPersonState;\n  dispatch: Dispatch<IPersonAction>;\n}\n\nconst Context = createContext<IContextValue | undefined>(undefined);\n\nfunction Person() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <Context.Provider value={{ state, dispatch }}>\n      <div>\n        <Books />\n        <Movies />\n      </div>\n    </Context.Provider>\n  );\n}\n\nfunction Books() {\n  const { state, dispatch } = useContext(Context)!;\n  useEffect(() => {\n    fetch('http://api.kuanglinfeng.com')\n      .then((response) => response.json())\n      .then((data) => dispatch({ type: 'getBooks', payload: data.books }));\n  }, []);\n\n  return (\n    <div>\n      <h1>我的书籍</h1>\n      <ul>\n        {state.books!.map((book) => (\n          <li key={book}>{book}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction Movies() {\n  const { state, dispatch } = useContext(Context)!;\n\n  useEffect(() => {\n    fetch('http://api.kuanglinfeng.com')\n      .then((response) => response.json())\n      .then((data) => dispatch({ type: 'getMovies', payload: data.movies }));\n  }, []);\n  return (\n    <div>\n      <h1>我的电影</h1>\n      {state.movies.map((movie) => (\n        <li key={movie}>{movie}</li>\n      ))}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Person />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n如何对 reducer 进行拆分？\n\n答：可将 reducer 写成多个对象的形式，合并所有的子 reducer 时只需要 `{...reducer1, ...reducer2, ...}` 即可\n",
    "wordCount": 121
  },
  {
    "id": "1642119396",
    "title": "Icon 的所有方案",
    "date": "2020-07-21",
    "tags": [
      "icon"
    ],
    "fileName": "Icon 的所有方案.md",
    "content": "\n## icon 的各种做法\n\n1. img 法\n2. background 法\n3. background 合一法\n4. font 法\n5. svg-symbol 法\n6. css 就是干法\n\n### img 法\n\n1. 搞一张图片\n2. 使用`<img src=\"图片路径\"/>`来使用图片\n3. 通过其它 css 属性来控制图片的大小，位置等\n\n优点：可以利用图片默认自动缩放的特性，通过仅设置宽度或者高度来改变图片的大小\n\n### background 法\n\n1. 搞一张图片\n2. 利用 css 属性`background: url(./image.png)`\n3. 通过其它 css 属性来控制图片的大小，位置等\n\n### background 合一法\n\n1. 将几张图片拼成一张图，可以用网上的 css sprites generator 工具\n2. 利用 css 属性`width，height, overflow, background-position`来显示某一张图片\n\n### font 法\n\n使用 icon-font，字体即图标，图标即字体。常用网站：http://iconfont.cn\n\n注意：一般来说，字体图标的 Entity Number 一般都以`&#xe6`开头，因为这一段范围通常不表示任何字符\n\n- inconfont 的 HTML 形式（对应 iconfont.cn 里的 unicode 功能）\n\n用法：\n\n1. 在样式里引入@font-face\n\n```css\n@font-face {\n  font-family: 'iconfont'; /* project id 1958405 */\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\n  src:\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\n}\n```\n\n2. 使用字体对应的 Entity Number（unicode）并指定 font-family\n\n```html\n<div style=\"font-family: iconfont;\">&#xe600;</div>\n```\n\n- inconfont 的 CSS 形式（对应 iconfont.cn 里的 Font class 功能）\n\n1. 在样式里引入@font-face，并使用伪类指定对应 iconfont 的 Entity Number\n\n```css\n@font-face {\n  font-family: 'iconfont'; /* project id 1958405 */\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\n  src:\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\n}\n.xxx:before {\n  content: '\\e600';\n}\n```\n\n2. 指定 font-family 和伪类\n\n```html\n<div class=\"xxx\" style=\"font-family: iconfont;\"></div>\n```\n\n### svg-symbol 法\n\n这种方式是最推荐的做法。与以上方式相比有如下特点：\n\n1. 支持多色图标，不再受单色限制\n2. 通过一些技巧，支持像字体那样，通过 font-size，color 来调样式\n3. 兼容性较差，支持 ie9+即现代浏览器\n4. 浏览器渲染 svg 的性能一般，还不如 png\n\n使用步骤：\n\n1. 从 iconfont.cn 上拷贝项目下生成的 symbol 代码\n\n```js\n//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js\n```\n\n2. 加入通用 css 代码（引入一次就行）\n\n```html\n<style type=\"text/css\">\n  .icon {\n    width: 1em;\n    height: 1em;\n    vertical-align: -0.15em;\n    fill: currentColor;\n    overflow: hidden;\n  }\n</style>\n```\n\n3. 挑选相应的图标并获取类名，应用于页面\n\n```html\n<svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-xxx\"></use>\n</svg>\n```\n\n### 「CSS 就是干」法\n\n纯 css 技巧来实现 icon。\n\n推荐一个网站，这个网站是一个设计师写的，全是用 css 实现的 icon。\n\nhttps://cssicon.space\n",
    "wordCount": 481
  },
  {
    "id": "816050360",
    "title": "bind 函数全解",
    "date": "2020-07-19",
    "tags": [
      "javascript"
    ],
    "fileName": "bind 函数全解.md",
    "content": "\n## 功能\n\nbind 函数是 JavaScript 中一个非常重要的函数，它可以将一个函数的上下文绑定到指定的对象上，从而改变函数执行时的上下文。bind 的传参结构为`function.bind(thisArg, arg1, arg2, ...)`，`thisArg` 表示绑定的 this 上下文，`arg1, arg2, ...`表示预设的参数。\n\n## 用法\n\n### 绑定 this\n\n```js\nconst person = {\n  name: 'Alice',\n  greet() {\n    console.log(`Hello, I'm ${this.name}`);\n  },\n};\n\nconst greet = person.greet;\n// 直接调用会丢失 this 上下文\ngreet(); // Hello, I'm undefined\n\nconst boundGreet = person.greet.bind(person);\n// bind 后保持了正确的 this 指向\nboundGreet(); // Hello, I'm Alice\n```\n\n### 参数预设\n\n```js\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// 创建一个新函数，第一个参数固定为 2\nconst double = multiply.bind(null, 2);\nconsole.log(double(4)); // 8\nconsole.log(double(5)); // 10\n```\n\n### 在类/构造函数中使用\n\n```js\nclass Button {\n  constructor() {\n    this.clicked = false;\n    // 在事件处理中保持 this 指向\n    this.onClick = this.onClick.bind(this);\n  }\n\n  onClick() {\n    this.clicked = true;\n    console.log('Button clicked');\n  }\n}\n```\n\n### 支持作为构造函数使用\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\n// 创建一个预设年龄的构造函数\nconst CreateTeenager = Person.bind(null, 'Unknown', 16);\nconst teen = new CreateTeenager();\nconsole.log(teen.age); // 16\n```\n\n## 实现原理\n\n具体代码实现：\n\n```js\nFunction.prototype.myBind = function (context, ...args) {\n  if (typeof this !== 'function') {\n    throw new Error('Function.prototype.bind - what is trying to be bound is not callable');\n  }\n\n  const self = this; // 保存原函数的引用\n  // 改用普通函数，这样可以作为构造函数使用\n  const fBound = function (...boundArgs) {\n    return self.apply(\n      // 使用 instanceof 检查是否是通过 new 调用\n      this instanceof fBound ? this : context,\n      [...args, ...boundArgs]\n    );\n  };\n\n  // 设置 fBound.__proto__ 指向 self，使之可以访问 self 对象上的静态方法\n  Object.setPrototypeOf(fBound, self);\n  // 设置 fBound.prototype 为 self.prototype 的副本，这样 fBound 的实例可以继承 self 的原型对象上的方法\n  fBound.prototype = Object.create(self.prototype);\n\n  return fBound;\n};\n```\n\n代码解析：\n\n1. 参数检查\n\n```js\nif (typeof this !== 'function') {\n  throw new Error('Function.prototype.bind - what is trying to be bound is not callable');\n}\n```\n\n- 因为 myBind 是定义在 Function.prototype 上的方法\n- 检查调用 myBind 的对象是否为函数\n- 如果不是函数则抛出错误\n\n2. 保存原函数引用\n\n```js\nconst self = this;\n```\n\n- this 在这里指向原始函数\n- 保存引用是为了在后面的函数中使用\n\n3. 创建绑定函数\n\n```js\nconst fBound = function (...boundArgs) {\n  // 函数体\n};\n```\n\n- 创建一个新函数作为返回值\n- 使用剩余参数语法收集调用时传入的参数\n\n4. 处理 this 指向\n\n```js\nthis instanceof fBound ? this : context;\n```\n\n- 判断 fBound 是否被作为构造函数调用（使用 new）\n- 如果是构造函数调用：使用新创建的实例（this）\n- 如果是普通调用：使用传入的上下文（context）\n\n5. 合并参数\n\n```js\n[...args, ...boundArgs];\n```\n\n- args：调用 bind 时预设的参数\n- boundArgs：调用绑定函数时传入的参数\n- 使用扩展运算符合并两组参数\n\n6. 继承原型链\n\n```js\nObject.setPrototypeOf(fBound, self);\nfBound.prototype = Object.create(self.prototype);\n```\n\n- 设置 fBound 函数对象的原型（**proto**）指向原函数，继承静态属性/方法\n- 创建原函数原型的副本作为 fBound 的 prototype，继承实例方法\n",
    "wordCount": 372
  },
  {
    "id": "299326428",
    "title": "call 和 apply 函数全解",
    "date": "2020-07-17",
    "tags": [
      "javascript"
    ],
    "fileName": "call 和 apply 函数全解.md",
    "content": "\n## 功能\n\ncall 和 apply 函数是 JavaScript 中用于改变函数执行上下文（this 值）的函数。它们可以调用一个函数，并指定函数执行时的上下文（this 值）。他们两个的差异在于传参方式不同，call 的传参结构为`function.call(thisArg, arg1, arg2, ...)`，apply 的传参结构为`function.apply(thisArg, [argsArray])`。\n\n## 用法\n\n### 绑定函数 this\n\n```js\nfunction greet(greeting) {\n  console.log(`${greeting}, ${this.name}!`);\n}\n\nconst person = { name: 'Alice' };\ngreet.call(person, 'Hello'); // Hello, Alice!\n```\n\n### 多参数\n\n```js\nfunction introduce(greeting, profession) {\n  console.log(`${greeting}, I'm ${this.name}, I'm a ${profession}`);\n}\n\nconst person = { name: 'Bob' };\nintroduce.myCall(person, 'Hi', 'developer'); // Hi, I'm Bob, I'm a developer\n```\n\n## 实现原理\n\n具体代码实现（call）：\n\n```js\nFunction.prototype.myCall = function (context, ...args) {\n  if (typeof this !== 'function') {\n    throw new Error('Function.prototype.call - what is trying to be bound is not callable');\n  }\n  context = context || window;\n  const fn = Symbol('fn');\n  context.fn = fn;\n  const res = context.fn(...args);\n  delete context.fn;\n  return res;\n};\n```\n\n具体代码实现（apply）：\n\n```js\nFunction.prototype.myApply = function (context, args) {\n  if (typeof this !== 'function') {\n    throw new Error('Function.prototype.apply - what is trying to be bound is not callable');\n  }\n  context = context || window;\n  const fn = Symbol('fn');\n  context.fn = fn;\n  const res = context.fn(...args);\n  delete context.fn;\n  return res;\n};\n```\n\n不难看出，call 和 apply 的底层实现都是类似的：\n\n1. 函数临时添加为目标对象的方法\n2. 通过对象调用这个方法（此时 this 自然指向该对象）\n3. 调用完成后删除这个临时方法\n\n这种实现方式巧妙地利用了 JavaScript 中 this 的指向规则：当函数作为对象的方法调用时，this 指向该对象。\n\n## 注意事项\n\n- 在严格模式下，需要特别处理 context 为 null/undefined 的情况\n- 在实际项目中，可能需要考虑 Symbol 的兼容性\n- 在 Node.js 环境中需要使用 global 替代 window\n- 需要注意属性名冲突的问题（虽然使用 Symbol 已经很好地解决了这个问题）\n",
    "wordCount": 293
  },
  {
    "id": "1351712202",
    "title": "XSS 和 CSRF 攻击详解",
    "date": "2020-06-03",
    "tags": [
      "前端安全"
    ],
    "fileName": "XSS 和 CSRF 攻击详解.md",
    "content": "\n## XSS （跨站脚本攻击）\n\n### 攻击原理\n\nXSS（Cross-Site Scripting）攻击的核心是让恶意脚本在受害者的浏览器中执行。攻击者通过注入恶意代码（通常是 JavaScript）到网页中，当其他用户访问该页面时，代码会被浏览器解析并执行，从而实现窃取用户数据、会话劫持、篡改页面内容等攻击行为。\n\n### 攻击类型\n\n- 反射型 XSS\n\n**原理**：恶意脚本通过 URL 参数注入，服务端未过滤直接返回给客户端。\n\n例如：用户点击一个精心构造的链接：\n\n```\nhttps://example.com/search?query=<script>alert('XSS')</script>\n```\n\n服务端将`query`参数直接插入到页面中，导致脚本执行\n\n**特点**：需要诱导用户主动点击恶意链接，常见于钓鱼攻击。\n\n- 存储型 XSS\n\n**原理**：恶意脚本被存储到服务器数据库（如评论、留言板），其他用户访问页面时触发。\n\n例如：攻击者在评论区提交内容：\n\n```html\n<script>\n  stealCookie(document.cookie);\n</script>\n```\n\n所有用户访问该页面时，脚本自动执行，窃取 Cookie。\n\n**特点**：危害范围广，持续时间长（数据长期存储在服务端）。\n\n- DOM 型 XSS\n\n**原理**：前端 JavaScript 动态操作 DOM 时未对用户输入转义，导致恶意脚本执行。\n\n例如：面通过 location.hash 获取 URL 片段并插入到 DOM 中：\n\n```js\ndocument.getElementById('content').innerHTML = location.hash.substring(1);\n```\n\n攻击者构造 URL：\n\n```\nhttps://example.com#<img src=x onerror=alert('XSS')>\n```\n\n用户访问该 URL 时，恶意脚本执行。\n**特点**：完全在客户端触发，无需服务端参与。\n\n### 攻击危害\n\n- 窃取用户 Cookie 或会话信息（Session Hijacking）。\n- 伪造用户操作（如转账、修改密码）。\n- 篡改页面内容（如插入钓鱼表单）。\n- 劫持用户浏览器（如发起 DDoS 攻击）。\n\n### 防御措施\n\n#### 输入过滤与输出编码\n\n- **输入过滤**：对用户输入进行严格校验（如正则表达式、白名单）。\n\n- **输出编码**：根据输出位置选择不同的转义规则：\n  - **HTML 上下文**：转义 <, >, &, \", ' 等字符。\n  ```js\n  function escapeHTML(str) {\n    return str.replace(\n      /[&<>\"']/g,\n      (c) =>\n        ({\n          '&': '&amp;',\n          '<': '&lt;',\n          '>': '&gt;',\n          '\"': '&quot;',\n          \"'\": '&#39;',\n        })[c]\n    );\n  }\n  ```\n  - **JavaScript 上下文**：使用 JSON.stringify 或 encodeURIComponent。\n  - **URL 上下文**：使用 encodeURIComponent 编码参数。\n\n#### CSP（内容安全策略）\n\n通过 HTTP 头限制资源加载来源：\n\n```http\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;\n```\n\n- 禁止内联脚本（unsafe-inline）和 eval。\n- 仅允许加载指定域名的脚本、样式、图片等资源。\n\n#### 安全的 Cookie 设置\n\n敏感 Cookie 设置 HttpOnly（禁止 JavaScript 访问）：\n\n```http\nSet-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Lax;\n```\n\n### 避免危险 API\n\n- 使用 textContent 替代 innerHTML。\n- 避免直接执行用户输入的字符串（如 eval）。\n\n## CSRF （跨站请求伪造）\n\n### 攻击原理\n\nCSRF（Cross-Site Request Forgery）攻击的核心是利用用户的登录状态，诱导用户访问恶意页面，伪造一个合法请求（如转账、修改密码），而用户并不知情。\n\n**典型场景**：\n\n1. 用户登录银行网站 bank.com，Cookie 中保存了会话信息。\n2. 用户访问恶意页面 evil.com，该页面自动发起一个向 bank.com/transfer 的请求：\n\n```js\n<img src=\"https://bank.com/transfer?to=hacker&amount=1000000\">\n```\n\n3. 浏览器自动携带 bank.com 的 Cookie，请求被服务器认为是合法的。\n\n### 攻击危害\n\n- 以用户身份执行敏感操作（如转账、删除数据）。\n- 修改用户账户信息（如邮箱、密码）。\n\n### 防御措施\n\n#### CSRF Token\n\n**原理**：服务端生成随机 Token，嵌入表单或请求头，提交时验证 Token 合法性。\n**实现步骤**：\n\n1. 用户访问页面时，服务端生成 Token 并存储在 Session 或 Cookie 中。\n2. 页面表单中插入 Token：\n\n```html\n<input type=\"hidden\" name=\"csrf_token\" value=\"随机Token\" />\n```\n\n3. 提交表单时，服务端验证 Token 合法性。\n   **关键点**：Token 需随机、一次性，且绑定用户会话。\n\n#### SameSite Cookie\n\n**原理**：通过 Cookie 的 SameSite 属性限制跨站请求携带 Cookie。\n\n```http\nSet-Cookie: sessionId=abc123; SameSite=Lax;\n```\n\n- Lax：允许部分安全请求（如导航跳转）携带 Cookie。\n- Strict：完全禁止跨站携带 Cookie。\n- None：允许跨站携带 Cookie（需配合 Secure）。\n\n#### 验证 Referer/Origin 头\n\n检查请求头中的 Referer 或 Origin 是否为可信域名。\n\n```js\n// 服务端校验示例（Node.js）\nif (req.headers.referer !== 'https://trusted-domain.com') {\n  throw new Error('非法请求来源');\n}\n```\n\n**局限性**：某些浏览器会禁用 Referer，且可能被伪造。\n\n#### 关键操作二次验证\n\n对敏感操作（如支付、修改密码）要求用户输入密码或短信验证码。\n\n## XSS 和 CSRF 的区别\n\n| 区别       | XSS                      | CSRF                           |\n| ---------- | ------------------------ | ------------------------------ |\n| 攻击目标   | 窃取用户数据或劫持会话   | 伪造用户身份执行操作           |\n| 依赖条件   | 需要注入恶意脚本         | 依赖用户已登录目标网站         |\n| 攻击发起者 | 用户访问含恶意脚本的页面 | 用户访问恶意页面或点击恶意链接 |\n| 防御核心   | 控制不可信数据的输出     | 验证请求来源和合法性           |\n\n## 总结\n\n- **XSS** 的核心是防止恶意脚本执行，需重点关注**输出编码**和 **CSP 策略**。\n- **CSRF** 的核心是验证请求是否由用户主动发起，需依赖 **CSRF Token** 和 **SameSite Cookie**。\n- 安全是系统工程，需前后端协作，结合多种防御手段降低风险。\n",
    "wordCount": 1198
  }
]