[
  {
    "id": "1516366830",
    "title": "class-transformer 实践",
    "date": "2020-12-14",
    "tags": [
      "typescript",
      "class-transformer"
    ],
    "fileName": "class-transformer 实践.md",
    "content": "\n## 为什么要使用这个库\n\n比如，我们在后台管理系统中要发布一篇文章，我们只需创建一个普通的平面对象，然后将所有填写的标题、内容等信息给到这个普通对象。但是，如果这个普通对象若是转为对应的类对象，则会出现以下问题：\n\n代码：\n\n```ts\nimport { plainToClass } from 'class-transformer';\nimport { validate } from 'class-validator';\nimport Express from 'express';\n\nimport Article from './model/Article';\nimport articleRoute from './routes/articleRoute';\n\nconst app = Express();\n\napp.use('/api/article', articleRoute);\n\n// 约束为平面对象\nconst article: any = {};\n\narticle.title = '12345';\narticle.content = '123';\narticle.publishTime = new Date();\n// 下面的属性是必须的，但是这里进行注释\n// article.tagList = ['12']\n\n// 按理说，这里应该要输出缺失了tagList这个属性的信息\nvalidate(article).then((errors) => {\n  console.log(errors);\n});\n\napp.listen(3000, () => console.log('服务已开启！'));\n```\n\n运行结果（没有捕获到任何信息）：\n\n![2.png](https://upload-images.jianshu.io/upload_images/17962931-c94b143ee9f65491.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因此，我们需要对平面对象进行转换，才可结合class-validator对类属性信息进行约束。\n\n## 安装\n\n```ts\nyarn add class-transformer\n```\n\n## 使用\n\n```ts\nimport { plainToClass } from 'class-transformer';\nimport { validate } from 'class-validator';\nimport Express from 'express';\n\nimport Article from './model/Article';\nimport articleRoute from './routes/articleRoute';\n\nconst app = Express();\n\napp.use('/api/article', articleRoute);\n\n// 这是个平面对象\nconst article: any = {};\n\narticle.title = '12345';\narticle.content = '123';\narticle.publishTime = new Date();\n\nconst newArticle = plainToClass(Article, article);\n\nvalidate(newArticle).then((errors) => {\n  console.log(errors);\n});\n\napp.listen(3000, () => console.log('服务已开启！'));\n```\n\n运行结果:\n\n![3.png](https://upload-images.jianshu.io/upload_images/17962931-a4ee172b3fc8410a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 没这么简单\n\n如果，一开始给平面对象赋值时的属性的类型就不对呢？\n\n如下代码：\n\n```ts\n// 这是个平面对象\nconst article: any = {};\n\n// 类约束是的类型是字符串，这里赋值数字\narticle.title = 123;\narticle.content = '123';\narticle.publishTime = new Date();\narticle.tagList = ['123'];\n\nconst newArticle = plainToClass(Article, article);\n\nconsole.log(newArticle.title, typeof newArticle.title);\n\nvalidate(newArticle).then((errors) => {\n  console.log(errors);\n});\n```\n\n运行结果：\n\n![4.png](https://upload-images.jianshu.io/upload_images/17962931-4b61bf847fc0a54a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里可以看出，虽然数据类型对于不上，但还是验证通过了。所以，我们需要使用class-transform提供给我们的运行时的类型验证。\n\n## 使用装饰器@Type进行运行时的类型约束\n\n1. 安装reflect-metadata\n\n```ts\nyarn add reflect-metadata\n```\n\n2. 在入口文件`index.ts`中全局导入\n\n```ts\n// 最好在第一行导入，否则可能依旧会报错\nimport 'reflect-metadata'\nimport Express from 'express'\nimport articleRoute from './routes/articleRoute'\nimport Article from './model/Article'\nimport { validate } from 'class-validator'\nimport { plainToClass } from 'class-transformer'\n...\n```\n\n3. 对Article类进行运行时的类型约束\n\n```ts\nimport { ArrayMinSize, IsDate, IsNotEmpty } from 'class-validator'\nimport { Type } from 'class-transformer'\n\nclass Article {\n\n  @IsNotEmpty({ message: '文章标题不可以为空' })\n  // 运行时的类型约束\n  @Type(() => String)\n  public title: string\n\n  @IsNotEmpty({ message: '文章标签不可以为空' })\n  @ArrayMinSize(1, { message: '文章标签至少有一个' })\n  // 文档建议如果是字符串的数组，使用字符串约束更好，因为js其实不存在数字数组，字符串数组等\n  @Type(() => String)\n  // 上面虽然解决了不是字符串的数组的问题，但是如果传进来的是一个字符串呢？这就太tm难了，所以再在编译时检查一下算了吧，运行时不管了\n  @IsArray({ message: '文章标签必须是一个数组' })\n  public tagList: string[]\n\n  @IsNotEmpty({ message: '发布日期不可以为空' })\n  @IsDate()\n  @Type(() => Date)\n  public publishTime: Date\n\n  @IsNotEmpty({ message: '文章内容不可以为空' })\n  @Type(() => String)\n  public content: string\n}\n\nexport default Article\n```\n\n4. 运行结果\n\n![5.png](https://upload-images.jianshu.io/upload_images/17962931-902e0916bb634436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看出，已经将数字类型的title转为了字符串类型，同时也通过了验证。\n",
    "wordCount": 308
  },
  {
    "id": "1155390892",
    "title": "React 工程中 SVG 的高级使用方法",
    "date": "2020-09-09",
    "tags": [
      "react",
      "webpack",
      "svg"
    ],
    "fileName": "React 工程中 SVG 的高级使用方法.md",
    "content": "\n## 比较 low 的做法\n\n打开 create-react-app 的官方文档，它会告诉你使用 svg，将 svg 进行导入（实际导入的是 svg 的路径字符串），然后放到 img 的 src 上。这种方法我们称为将 svg 当做图片使用。\n\n为什么这种方式不好？\n\n比如：无法改变 svg 的颜色\n\n## 使用 svg-sprite-loader（自己配置法）\n\n使用 svg-sprite-loader 要在 webpack.config.js 里配置，但是我们用 create-react-app 搭建起来的项目里没有 webpack 的配置文件。\n\n使用 `yarn eject` 命令，可以把配置文件弄出来。运行后，发现项目下多了两个目录，其中就有 webpack.config.js，我们就可以修改它进行配置。按照官网配置即可。\n\n注意：一定要先进行 git commit，才能运行 eject，否则会无法成功弹出配置。\n\n### 步骤\n\n1. 安装两个 loader\n\n```\nyarn add --dev svg-sprite-loader\nyarn add --dev svgo-loader\n```\n\n2. 在 webpack.config.js 中配置这两个 loader\n\n```js\n{\n  test: /\\.svg$/,\n  use: [\n    { loader: 'svg-sprite-loader', options: {} },\n    { loader: 'svgo-loader', options: {} },\n  ]\n},\n```\n\n3. 使用\n\nApp.tsx\n\n```tsx\nimport x from \"icons/apple.svg\";\n\nconsole.log(x) // 查看浏览器dom树，可以发现多了一个svg\n\n// 多出来的svg如下：\n<svg fill='red'>\n   <use xlinkHref='#apple'/>\n</svg>\n```\n\napple 就是文件名。svg 上还可以直接加 fill 属性来改变颜色。\n引入的 x 如果不使用，就是如果不打印，页面上的图标就看不到了。必须用一下图标才能生效。这是因为treeshaking，意思是，如果你用不上一个东西，我就把他从树上摇下来。react 发现你引入了 x，但是没使用，就会把它删了。\n那我怎么样既能引入也不需要打印呢？\ntreeshaking 不适用于 require，所以可以用 require导入\n\n4. 封装 svg 成 icon 组件\n\n现在每次使用 svg 都要写三句代码，还要 require 引入。避免重复，把它封装成组件。\n\n```tsx\nimport React from 'react';\n\nconst importAll = (requireContext: __WebpackModuleApi.RequireContext) => requireContext.keys().forEach(requireContext);\ntry {\n  importAll(require.context('../icons', true, /\\.svg$/));\n} catch (error) {\n  console.log(error);\n}\n\ntype Props = {\n  name: string;\n};\n\nfunction Icon(props: Props) {\n  return (\n    <svg className=\"icon\">\n      <use xlinkHref={'#' + props.name} />\n    </svg>\n  );\n}\n\nexport default Icon;\n```\n\n说明：\n\n把 require 导入也放进来。但是如果有 100 个 svg，就要写 100 次 require。所以我们选择直接导入一个目录，这个目录里存放所有的 svg。这里封装为 importAll。\n\n但是有报错，说找不到 `__WebpackModuleApi`，这是因为在 ts 里不支持这个的问题。去谷歌搜索解决方案。\n安装：`yarn add --dev @types/webpack-env` 就可以解决。\n\n其他组件想使用 Icon，一句话引入即可 `<Icon name='chart'/>` name 属性是文件名。\n\nIcon 如果想改变颜色，可以直接在 css 里用 fill 改变：\n\n```css\n.icon {\n  fill: rgb(140, 177, 253);\n}\n```\n\n可是有一些svg图标是自带颜色的，在它们的文件里会通过 fill 属性指定颜色。如果是这种情况，就改不了颜色了。我们可以选择手动去它们的 svg 文件里删除 fill 属性，但是如果有很多图标，一个个删除太慢了。\n\nsvgo-loader 有一个功能，可以删除fill属性，只需要把需要的语句添加到配置文件的 svgo-loader 后边的选项options 里边就可以。\nsvgo 就是 svg optimizer 优化器的意思。\n\n```js\n{ loader: 'svgo-loader', options: {\n  plugins:[\n      {removeAttrs: {attrs:'fill'}}\n    ]\n  }\n},\n```\n",
    "wordCount": 682
  },
  {
    "id": "76987253",
    "title": "使用 useReducer 和 Context 实现 redux 的功能",
    "date": "2020-07-24",
    "tags": [
      "react",
      "redux"
    ],
    "fileName": "使用 useReducer 和 Context 实现 redux 的功能.md",
    "content": "\n## 使用 useReducer 和 Context 实现 redux 的功能\n\n步骤：\n\n1. 将数据集中在一个 store 对象\n2. 将所有操作集中在 reducer\n3. 创建一个 Context\n4. 创建对数据的读写 API\n5. 将第4步的内容放到第 3 步的 Context 中\n6. 用 Context.Provider 将 Context 提供给所有组件\n7. 各个组件用 useContext 获取读写 API\n\n代码演示：\n\n```tsx\nimport React, { Dispatch, createContext, useContext, useEffect, useReducer } from 'react';\n\nimport './App.css';\n\ninterface IPersonState {\n  books: string[];\n  movies: string[];\n}\n\ntype IPersonAction = {\n  type: 'getBooks' | 'getMovies';\n  payload: string[];\n};\n\nconst initialState: IPersonState = {\n  books: [],\n  movies: [],\n};\n\nfunction reducer(state: IPersonState = initialState, action: IPersonAction) {\n  if (action.type === 'getBooks') {\n    return { ...state, books: action.payload };\n  }\n  if (action.type === 'getMovies') {\n    return { ...state, movies: action.payload };\n  }\n  return state;\n}\n\nexport interface IContextValue {\n  state: IPersonState;\n  dispatch: Dispatch<IPersonAction>;\n}\n\nconst Context = createContext<IContextValue | undefined>(undefined);\n\nfunction Person() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <Context.Provider value={{ state, dispatch }}>\n      <div>\n        <Books />\n        <Movies />\n      </div>\n    </Context.Provider>\n  );\n}\n\nfunction Books() {\n  const { state, dispatch } = useContext(Context)!;\n  useEffect(() => {\n    fetch('http://api.kuanglinfeng.com')\n      .then((response) => response.json())\n      .then((data) => dispatch({ type: 'getBooks', payload: data.books }));\n  }, []);\n\n  return (\n    <div>\n      <h1>我的书籍</h1>\n      <ul>\n        {state.books!.map((book) => (\n          <li key={book}>{book}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction Movies() {\n  const { state, dispatch } = useContext(Context)!;\n\n  useEffect(() => {\n    fetch('http://api.kuanglinfeng.com')\n      .then((response) => response.json())\n      .then((data) => dispatch({ type: 'getMovies', payload: data.movies }));\n  }, []);\n  return (\n    <div>\n      <h1>我的电影</h1>\n      {state.movies.map((movie) => (\n        <li key={movie}>{movie}</li>\n      ))}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Person />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n如何对 reducer 进行拆分？\n\n答：可将 reducer 写成多个对象的形式，合并所有的子 reducer 时只需要 `{...reducer1, ...reducer2, ...}` 即可\n",
    "wordCount": 121
  },
  {
    "id": "1642119396",
    "title": "Icon 的所有方案",
    "date": "2020-07-21",
    "tags": [
      "icon"
    ],
    "fileName": "Icon 的所有方案.md",
    "content": "\n## icon 的各种做法\n\n1. img 法\n2. background 法\n3. background 合一法\n4. font 法\n5. svg-symbol 法\n6. css 就是干法\n\n### img 法\n\n1. 搞一张图片\n2. 使用`<img src=\"图片路径\"/>`来使用图片\n3. 通过其它 css 属性来控制图片的大小，位置等\n\n优点：可以利用图片默认自动缩放的特性，通过仅设置宽度或者高度来改变图片的大小\n\n### background 法\n\n1. 搞一张图片\n2. 利用 css 属性`background: url(./image.png)`\n3. 通过其它 css 属性来控制图片的大小，位置等\n\n### background 合一法\n\n1. 将几张图片拼成一张图，可以用网上的 css sprites generator 工具\n2. 利用 css 属性`width，height, overflow, background-position`来显示某一张图片\n\n### font 法\n\n使用 icon-font，字体即图标，图标即字体。常用网站：http://iconfont.cn\n\n注意：一般来说，字体图标的 Entity Number 一般都以`&#xe6`开头，因为这一段范围通常不表示任何字符\n\n- inconfont 的 HTML 形式（对应 iconfont.cn 里的 unicode 功能）\n\n用法：\n\n1. 在样式里引入@font-face\n\n```css\n@font-face {\n  font-family: 'iconfont'; /* project id 1958405 */\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\n  src:\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\n}\n```\n\n2. 使用字体对应的 Entity Number（unicode）并指定 font-family\n\n```html\n<div style=\"font-family: iconfont;\">&#xe600;</div>\n```\n\n- inconfont 的 CSS 形式（对应 iconfont.cn 里的 Font class 功能）\n\n1. 在样式里引入@font-face，并使用伪类指定对应 iconfont 的 Entity Number\n\n```css\n@font-face {\n  font-family: 'iconfont'; /* project id 1958405 */\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\n  src:\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\n}\n.xxx:before {\n  content: '\\e600';\n}\n```\n\n2. 指定 font-family 和伪类\n\n```html\n<div class=\"xxx\" style=\"font-family: iconfont;\"></div>\n```\n\n### svg-symbol 法\n\n这种方式是最推荐的做法。与以上方式相比有如下特点：\n\n1. 支持多色图标，不再受单色限制\n2. 通过一些技巧，支持像字体那样，通过 font-size，color 来调样式\n3. 兼容性较差，支持 ie9+即现代浏览器\n4. 浏览器渲染 svg 的性能一般，还不如 png\n\n使用步骤：\n\n1. 从 iconfont.cn 上拷贝项目下生成的 symbol 代码\n\n```js\n//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js\n```\n\n2. 加入通用 css 代码（引入一次就行）\n\n```html\n<style type=\"text/css\">\n  .icon {\n    width: 1em;\n    height: 1em;\n    vertical-align: -0.15em;\n    fill: currentColor;\n    overflow: hidden;\n  }\n</style>\n```\n\n3. 挑选相应的图标并获取类名，应用于页面\n\n```html\n<svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-xxx\"></use>\n</svg>\n```\n\n### 「CSS 就是干」法\n\n纯 css 技巧来实现 icon。\n\n推荐一个网站，这个网站是一个设计师写的，全是用 css 实现的 icon。\n\nhttps://cssicon.space\n",
    "wordCount": 481
  }
]