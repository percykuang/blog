@date: 2021-02-24
@tag: [浏览器,http]

## 引言

在现代 Web 应用中，HTTP 协议本身是无状态的。这意味着服务器默认不会"记住"来自同一用户的连续请求。然而，许多应用场景（如用户登录、购物车、个性化设置等）都需要在用户的多次请求之间保持其状态和信息。为了解决这个问题，开发者们引入了多种机制，其中 Cookie、Session 和 JWT (JSON Web Token) 是最常用和最重要的三种。理解它们的工作原理、各自的优缺点以及适用场景，对于构建安全、高效且用户友好的 Web 应用至关重要。本文将深入探讨这三种技术，帮助你更好地在项目中做出选择。

## Cookie

### 什么是 Cookie？

Cookie 是一小段文本信息，由网站服务器发送给浏览器，并存储在用户的计算机上。当用户再次访问该网站时，浏览器会将这些 Cookie 信息发送回服务器，从而让服务器能够识别用户并记住一些信息，例如用户的登录状态、偏好设置、购物车内容等。

### Cookie 是如何工作的？

1.  **服务器发送 Cookie**：当用户首次访问一个网站时，如果服务器需要记录用户信息，它会在 HTTP 响应头中添加一个 `Set-Cookie` 字段，其中包含 Cookie 的名称、值以及其他可选属性（如过期时间、作用域等）。
2.  **浏览器存储 Cookie**：浏览器接收到响应后，会解析 `Set-Cookie` 头部，并将 Cookie 信息存储起来。
3.  **浏览器发送 Cookie**：在后续的每次请求中，只要请求的域名和路径与 Cookie 的作用域匹配，浏览器就会自动在 HTTP 请求头中添加一个 `Cookie` 字段，将之前存储的 Cookie 发送给服务器。
4.  **服务器读取 Cookie**：服务器接收到请求后，会读取请求头中的 `Cookie` 信息，并根据这些信息来识别用户、恢复会话或提供个性化服务。

### Cookie 的常见用途

- **会话管理**：跟踪用户登录状态、购物车内容、游戏得分等。
- **个性化设置**：记住用户的偏好，如语言选择、主题偏好、自定义布局等。
- **追踪和分析**：记录用户的浏览历史、点击行为等，用于广告投放和网站分析。

### Cookie 的重要属性

- **`Name=Value`**：Cookie 的名称和值。这是 Cookie 的核心部分。
- **`Expires=Date`**：Cookie 的过期时间。如果设置了此属性，Cookie 会在该时间点后被删除。如果未设置，则为会话 Cookie，浏览器关闭时即被删除。
- **`Max-Age=Seconds`**：Cookie 的生命周期，以秒为单位。优先级高于 `Expires`。
- **`Domain=domain`**：指定 Cookie 可以发送到的域名。如果未指定，则默认为当前文档的域名（不包括子域名）。
- **`Path=path`**：指定 Cookie 可以发送到的服务器路径。如果未指定，则默认为当前文档的路径。
- **`Secure`**：标记此 Cookie 只应通过 HTTPS 加密连接发送给服务器。这有助于防止 Cookie 在传输过程中被窃听。
- **`HttpOnly`**：标记此 Cookie 不能通过客户端 JavaScript (如 `document.cookie`) 访问。这有助于缓解跨站脚本攻击 (XSS)，防止恶意脚本窃取 Cookie。
- **`SameSite=Strict|Lax|None`**：控制 Cookie 是否可以随跨站请求发送，以帮助防止跨站请求伪造 (CSRF) 攻击。
  - `Strict`：完全禁止第三方 Cookie，只有在当前站点发起的请求才会携带 Cookie。
  - `Lax`：允许部分第三方请求携带 Cookie，例如通过链接导航到目标站点。
  - `None`：允许任何第三方请求携带 Cookie，但必须同时设置 `Secure` 属性 (即只能在 HTTPS 连接下使用)。

### Cookie 的优点与缺点

**优点：**

- **简单易用**：实现简单，被广泛支持。
- **持久性**：可以设置过期时间，实现长时间的用户状态保持。
- **客户端存储**：减轻了服务器的存储压力 (相对于 Session 而言)。

**缺点：**

- **大小限制**：大多数浏览器对单个 Cookie 的大小（通常为 4KB）和每个域名下的 Cookie 数量（通常为 20-50 个）有限制。
- **安全性风险**：如果 Cookie 未加密或未正确设置 `HttpOnly` 和 `Secure` 属性，容易被窃取或篡改，导致 XSS 或 CSRF 攻击。
- **性能影响**：在每次 HTTP 请求中都会携带 Cookie，即使某些请求并不需要这些 Cookie，也会增加网络流量。
- **用户可禁用**：用户可以在浏览器设置中禁用 Cookie，导致依赖 Cookie 的功能失效。

## Session

### 什么是 Session？

Session（会话）是一种在服务器端存储用户特定信息的机制。与 Cookie 不同，Session 数据本身存储在服务器上，而只将一个唯一的 Session ID（会话标识符）通过 Cookie（或 URL 参数）发送给客户端浏览器。浏览器在后续请求中带上这个 Session ID，服务器据此找到对应的 Session 数据，从而实现状态保持。

### Session 是如何工作的？

1.  **用户发起请求**：用户首次访问应用或进行需要状态管理的操作（如登录）。
2.  **服务器创建 Session**：如果服务器端启用了 Session 管理，并且当前请求没有有效的 Session ID，服务器会为该用户创建一个新的 Session 对象，并生成一个唯一的 Session ID。同时，服务器会将需要跟踪的用户信息（如用户 ID、权限、购物车内容等）存储在这个 Session 对象中。这些 Session 数据通常存储在服务器的内存、数据库或专门的 Session 存储服务（如 Redis、Memcached）中。
3.  **服务器发送 Session ID 给客户端**：服务器通过 HTTP 响应头中的 `Set-Cookie` 字段，将这个 Session ID 发送给客户端浏览器。这个 Cookie 通常是临时的（会话 Cookie），且通常命名为 `JSESSIONID` (Java)、`PHPSESSID` (PHP)、`ASPSESSIONID` (ASP) 等，具体名称取决于服务器端技术栈。
4.  **客户端存储 Session ID**：浏览器接收到包含 Session ID 的 Cookie 后，会将其存储起来。
5.  **客户端发送 Session ID**：在后续的每次请求中，浏览器会自动将这个 Session ID Cookie 发送给服务器。
6.  **服务器验证 Session ID 并检索 Session 数据**：服务器接收到请求后，会从 Cookie 中提取 Session ID，并根据这个 ID 在服务器端的 Session 存储中查找对应的 Session 数据。如果找到了有效的 Session，服务器就可以使用这些数据来处理当前请求。
7.  **Session 的销毁**：Session 通常有过期时间。当用户长时间未活动、关闭浏览器（如果 Session ID 是会话 Cookie），或者服务器主动销毁 Session 时，Session 数据会被清除。

### Session 的优点与缺点

**优点：**

- **安全性较高**：敏感数据存储在服务器端，只在客户端存储一个无意义的 Session ID，降低了数据泄露的风险。即使 Session ID 被截获，攻击者也难以直接获取到实际的用户信息，除非他们能利用这个 ID 劫持会话。
- **存储容量较大**：Session 数据存储在服务器端，理论上可以存储比 Cookie 更多的数据，不受浏览器对 Cookie 大小的限制。
- **数据类型灵活**：可以在 Session 中存储各种类型的数据，如对象、数组等，而不仅仅是字符串。

**缺点：**

- **服务器压力**：每个用户的 Session 数据都需要在服务器端存储，当并发用户量较大时，会占用较多的服务器资源（内存或存储空间），增加服务器的压力。
- **可扩展性问题**：在分布式或集群环境下，Session 共享和同步是一个挑战。如果用户请求被负载均衡到不同的服务器，需要确保这些服务器都能访问到同一个用户的 Session 数据。常见的解决方案包括 Session 复制、Session 持久化到共享存储（如数据库或 Redis）、或使用粘性 Session (Sticky Session) 将用户请求固定到同一台服务器。
- **依赖 Cookie（通常）**：虽然 Session ID 也可以通过 URL 重写等方式传递，但最常见和推荐的方式还是通过 Cookie。如果客户端禁用了 Cookie，Session 机制也会受影响。
- **CSRF 风险**：如果仅依赖 Session ID Cookie 进行认证，仍然存在跨站请求伪造 (CSRF) 的风险，需要配合其他 CSRF 防御措施。

## JWT (JSON Web Token)

### 什么是 JWT？

JWT (JSON Web Token) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息（声明，Claims）。这些信息可以被验证和信任，因为它们是数字签名的。JWT 可以使用密钥（使用 HMAC 算法）或公钥/私钥对（使用 RSA 或 ECDSA）进行签名。

与 Session 不同，JWT 本身就包含了用户信息（或其他声明），而不是在服务器上存储这些信息然后通过 ID 引用。这意味着服务器不需要在后端存储用户会话状态，从而使得应用更具可伸缩性和无状态性。

### JWT 的结构

JWT 通常由三部分组成，用点 (`.`) 分隔：

1.  **Header (头部)**：包含关于如何处理令牌的元数据，通常由两部分组成：

    - `typ` (Type)：令牌的类型，通常是 `JWT`。
    - `alg` (Algorithm)：用于签名的算法，例如 `HS256` (HMAC SHA256) 或 `RS256` (RSA SHA256)。
      头部会进行 Base64Url 编码形成 JWT 的第一部分。

    ```json
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```

2.  **Payload (负载/声明)**：包含实际要传输的信息，即声明 (Claims)。声明是关于实体（通常是用户）和附加数据的陈述。有三种类型的声明：

    - **Registered Claims (注册声明)**：这些是一组预定义的声明，非强制性的，但推荐使用，以提供一组有用的、可互操作的声明。例如：
      - `iss` (Issuer)：令牌签发者。
      - `sub` (Subject)：令牌主题（通常是用户 ID）。
      - `aud` (Audience)：令牌接收者。
      - `exp` (Expiration Time)：令牌过期时间戳。
      - `nbf` (Not Before)：令牌生效时间戳。
      - `iat` (Issued At)：令牌签发时间戳。
      - `jti` (JWT ID)：令牌的唯一标识符。
    - **Public Claims (公共声明)**：可以随意定义，但为了避免冲突，应该在 IANA JSON Web Token Registry 中定义它们，或者使用包含防冲突命名空间的 URI。
    - **Private Claims (私有声明)**：这些是创建它们的应用的特定声明，既非注册声明也非公共声明。是令牌的签发者和使用者共同定义的声明。
      负载也会进行 Base64Url 编码形成 JWT 的第二部分。

    ```json
    {
      "sub": "1234567890",
      "name": "John Doe",
      "admin": true,
      "iat": 1516239022
    }
    ```

3.  **Signature (签名)**：用于验证消息在传递过程中没有被篡改，并且对于使用私钥签名的令牌，它还可以验证 JWT 的发送者是谁。
    签名是通过将编码后的头部、编码后的负载、一个密钥（secret）、头部中指定的签名算法（如 HMAC SHA256）组合计算得出的。
    例如，如果使用 HMAC SHA256 算法，签名的创建方式如下：
    ```
    HMACSHA256(
      base64UrlEncode(header) + "." +
      base64UrlEncode(payload),
      secret
    )
    ```
    签名部分用于确保 JWT 的完整性。只有持有密钥的一方才能生成有效的签名，也只有持有密钥（或公钥，取决于算法）的一方才能验证签名。

将这三部分用点 (`.`) 连接起来就构成了完整的 JWT：`xxxxx.yyyyy.zzzzz`

### JWT 是如何工作的？

1.  **用户认证**：用户使用其凭据（例如，用户名和密码）登录。
2.  **服务器生成并签发 JWT**：服务器验证凭据。如果凭据有效，服务器会创建一个 JWT，其中包含用户的身份信息和其他必要的声明，并使用密钥对其进行签名。然后将此 JWT 返回给客户端。
3.  **客户端存储 JWT**：客户端（通常是 Web 浏览器或移动应用）接收到 JWT 后，通常会将其存储在本地，例如浏览器的 Local Storage、Session Storage 或 Cookie 中。
4.  **客户端发送 JWT**：当客户端需要访问受保护的路由或资源时，它会在请求的 `Authorization` 头部中以 `Bearer <token>` 的形式附带 JWT。
    ```
    Authorization: Bearer <token>
    ```
5.  **服务器验证 JWT**：服务器接收到请求后，会检查 `Authorization` 头部中的 JWT。
    - **验证签名**：服务器使用之前签发 JWT 时使用的密钥（或公钥）来验证 JWT 的签名。如果签名无效，说明令牌已被篡改或不是由可信方签发的，请求将被拒绝。
    - **验证声明**：如果签名有效，服务器会进一步检查 JWT 中的声明，例如 `exp` (过期时间) 是否已过，`iss` (签发者) 和 `aud` (接收者) 是否符合预期等。
6.  **处理请求**：如果 JWT 有效且声明通过验证，服务器将信任 JWT 中的信息，并根据这些信息处理用户的请求，授权其访问相应的资源。

### JWT 的优点与缺点

**优点：**

- **无状态与可扩展性**：由于用户信息和声明都存储在 JWT 本身，服务器端不需要存储会话信息。这使得应用更容易实现无状态架构，从而提高了可伸缩性。在分布式系统中，任何一台服务器只要拥有相同的密钥（或公钥），都可以验证 JWT 并处理请求，无需 Session 同步。
- **自包含性**：JWT 中包含了所有必要的用户信息，避免了多次查询数据库来获取用户信息。
- **解耦和跨域友好**：JWT 不依赖于 Cookie，因此在跨域认证 (CORS) 和移动应用场景中非常方便。令牌可以直接在 HTTP 头部或请求体中传递。
- **安全性**：通过签名机制，可以保证 JWT 在传输过程中不被篡改。可以使用 HTTPS 来进一步保证传输安全。
- **适用性广**：可用于身份验证、授权、信息交换等多种场景。

**缺点：**

- **令牌体积较大**：由于包含了用户信息和声明，JWT 的体积通常比 Session ID 要大，如果包含的声明过多，可能会增加网络传输的开销。
- **无法主动吊销**：一旦 JWT 签发，在它过期之前会一直有效，除非采取额外的措施。如果用户的权限发生变更或账户被盗，无法像 Session 那样在服务器端立即将其作废。常见的缓解方案包括：
  - 设置较短的过期时间，并配合刷新令牌 (Refresh Token) 机制。
  - 维护一个已吊销令牌的黑名单，每次验证 JWT 时查询黑名单 (但这又引入了状态)。
- **安全性依赖密钥**：用于签名的密钥 (secret) 至关重要。如果密钥泄露，攻击者就可以伪造有效的 JWT。因此，密钥必须妥善保管。
- **不应存储敏感数据**：JWT 的负载部分是 Base64Url 编码的，可以被轻易解码。因此，不应在 JWT 的负载中存储任何敏感信息，除非对负载本身也进行了加密 (JWE - JSON Web Encryption)。签名只保证完整性，不保证机密性。
- **续签问题**：如果 JWT 过期时间设置得较短，用户可能需要频繁重新登录。使用刷新令牌可以缓解此问题，但会增加实现的复杂性。

## Cookie vs. Session vs. JWT：详细对比

| 特性           | Cookie                                                               | Session                                 | JWT (JSON Web Token)                               |
| -------------- | -------------------------------------------------------------------- | --------------------------------------- | -------------------------------------------------- |
| **存储位置**   | 客户端 (浏览器)                                                      | 服务器端 (客户端存 Session ID)          | 客户端 (如 Local Storage, Session Storage, Cookie) |
| **状态管理**   | 客户端存储状态                                                       | 服务器端存储状态                        | 客户端存储状态 (令牌自包含信息)                    |
| **数据大小**   | 较小 (约 4KB/个, 域名下数量有限)                                     | 较大 (理论上仅受服务器资源限制)         | 可能较大 (取决于声明内容)                          |
| **安全性**     | 较低 (易被 XSS, CSRF 攻击，需 `HttpOnly`, `Secure`, `SameSite` 防护) | 较高 (敏感数据在服务端，ID 被盗有风险)  | 中高 (签名防篡改，依赖密钥安全，不加密则内容可见)  |
| **服务器压力** | 较小                                                                 | 较大 (存储和管理 Session 数据)          | 较小 (无状态，仅需验证签名和声明)                  |
| **可扩展性**   | -                                                                    | 较低 (分布式环境下需 Session 共享机制)  | 较高 (无状态，易于水平扩展)                        |
| **跨域支持**   | 有限 (受同源策略限制，可通过配置支持)                                | 有限 (通常依赖 Cookie 传递 Session ID)  | 良好 (不依赖 Cookie，可在头部或请求体传递)         |
| **数据类型**   | 字符串                                                               | 多种数据类型 (对象、数组等)             | JSON 对象 (声明)                                   |
| **吊销机制**   | 可通过设置过期时间或服务器端逻辑间接实现                             | 服务器端可主动销毁 Session              | 较难 (默认无法主动吊销，需黑名单或短时效+刷新令牌) |
| **依赖性**     | 客户端支持 Cookie                                                    | 通常依赖客户端 Cookie (传递 Session ID) | -                                                  |

### 存储位置

- **Cookie**：数据直接存储在客户端浏览器中。
- **Session**：数据存储在服务器端，客户端仅存储一个 Session ID (通常通过 Cookie)。
- **JWT**：令牌本身存储在客户端（例如，浏览器的 Local Storage、Session Storage，或者也可以放在 Cookie 中）。JWT 包含了所有必要的信息，服务器端不需要存储任何与令牌直接相关的会话数据。

### 状态管理

- **Cookie**：由于数据在客户端，一定程度上可以说是客户端管理状态，但服务器通过读取 Cookie 来识别用户。
- **Session**：完全由服务器端管理状态。服务器根据客户端传来的 Session ID 查找对应的会话数据。
- **JWT**：服务器是无状态的。所有必要的状态信息（声明）都包含在 JWT 中，由客户端在每次请求时提供给服务器。服务器只需验证令牌的有效性即可。

### 安全性

- **Cookie**：安全性相对较低。如果未正确配置 `HttpOnly`、`Secure` 和 `SameSite` 属性，容易受到 XSS 和 CSRF 攻击。数据直接暴露在客户端。
- **Session**：安全性相对较高，因为敏感数据存储在服务器端。客户端只有一个无意义的 Session ID。但 Session ID 如果被劫持，攻击者可能冒充用户。仍需防范 CSRF。
- **JWT**：安全性取决于实现。签名机制可以防止数据篡改。如果密钥泄露，则 JWT 可以被伪造。JWT 的负载部分是 Base64Url 编码的，不是加密的，因此不应在负载中存储敏感信息，除非对 JWT 进行了加密（JWE）。传输时应使用 HTTPS。

### 可扩展性

- **Cookie**：本身与服务器可扩展性关系不大，但由于其无状态特性，通常用于配合无状态的服务器架构。
- **Session**：在分布式或集群环境中，Session 管理会变得复杂。需要额外的机制（如 Session 共享、粘性会话）来确保不同服务器能访问同一用户的 Session 数据，这可能影响可扩展性。
- **JWT**：具有良好的可扩展性。由于服务器是无状态的（不需要存储 Session 数据），可以轻松地对应用进行水平扩展。任何一台服务器只要拥有用于验证签名的密钥（或公钥），就可以处理来自客户端的请求。

### 跨域支持

- **Cookie**：受到浏览器同源策略的限制。跨域发送 Cookie 需要服务器进行正确的 CORS 配置 (如 `Access-Control-Allow-Credentials`)，并且 Cookie 本身也可能需要设置 `SameSite=None; Secure`。
- **Session**：通常依赖 Cookie 来传递 Session ID，因此也间接受到 Cookie 跨域问题的制约。
- **JWT**：非常适合跨域场景。JWT 可以放在 HTTP 请求的 `Authorization` 头部（作为 Bearer Token）或请求体中发送，不依赖于 Cookie，因此可以轻松绕过 Cookie 的跨域限制。

## 何时选择哪种技术？

选择哪种技术取决于具体的应用需求、架构以及安全考虑。

**选择 Cookie 的场景：**

- **简单状态保持**：如果只需要存储少量非敏感信息，例如用户偏好（主题、语言）、"记住我"功能（存储一个长期有效的令牌）、或简单的追踪分析。
- **兼容性要求高**：几乎所有浏览器都支持 Cookie，且实现简单。
- **与传统 Session 机制配合**：即使使用 Session，通常也需要 Cookie 来存储 Session ID。

**不宜单独使用 Cookie 的场景：**

- 存储大量或敏感数据。
- 对安全性要求极高，且没有充分的 XSS/CSRF 防护措施。

**选择 Session 的场景：**

- **需要存储敏感或复杂数据**：用户身份信息、权限、购物车详情等，这些数据不适合直接暴露在客户端。
- **服务器端状态管理**：希望由服务器完全控制用户会话的状态和生命周期。
- **传统单体应用或小型应用**：在非分布式或小型集群环境中，Session 管理相对简单直接。
- **需要主动使会话失效**：例如用户修改密码或登出后，服务器可以立即销毁对应的 Session。

**使用 Session 时需要注意：**

- **服务器资源消耗**：大量并发用户会增加服务器内存或存储压力。
- **分布式环境下的扩展性**：需要考虑 Session 共享或同步的解决方案。

**选择 JWT 的场景：**

- **无状态 API 和微服务**：JWT 的核心优势在于无状态性，非常适合构建可水平扩展的 API 和微服务架构。
- **跨域认证 (CORS)**：JWT 不依赖 Cookie，可以轻松用于跨不同域名的服务之间的认证。
- **移动应用 (App)**：移动应用通常不使用 Cookie 进行会话管理，JWT 是一个很好的选择。
- **单点登录 (SSO)**：JWT 可以在多个相关应用之间安全地传递用户信息，实现单点登录。
- **信息交换**：JWT 可以作为一种安全的方式在不同系统或服务之间交换信息，利用其签名机制保证信息未被篡改。
- **希望将认证逻辑与应用服务器解耦**：可以使用专门的认证服务器来签发和验证 JWT。

**使用 JWT 时需要注意：**

- **令牌吊销的复杂性**：需要额外的机制（如黑名单或短有效期+刷新令牌）来处理令牌吊销。
- **密钥安全**：签发 JWT 的密钥必须妥善保管，一旦泄露，系统安全性将受到严重威胁。
- **令牌体积**：不要在 JWT 中存放过多非必要信息，以免令牌过大影响性能。
- **不要存放敏感信息**：JWT 的负载部分默认是可读的，敏感信息需要额外加密（JWE）或不应放入 JWT。

**总结选择思路：**

1.  **简单、非敏感、客户端信息** -> 优先考虑 Cookie。
2.  **敏感信息、服务器端控制、传统应用** -> Session 是经典选择。
3.  **无状态、可扩展、API、微服务、跨域、移动端** -> JWT 通常是更现代和灵活的选择。

在实际应用中，这些技术也可能组合使用。例如，使用 Session 进行 Web 应用的会话管理，同时使用 JWT 为移动 App 或第三方应用提供 API 认证。或者使用 Cookie 来存储 JWT（但要注意设置 `HttpOnly` 以增强安全性）。

## 总结

Cookie、Session 和 JWT 是 Web 开发中用于管理用户状态和实现认证授权的三种核心技术。它们各有特点，适用于不同的场景：

- **Cookie** 以其简单性和广泛的浏览器支持，在存储少量非敏感数据和基本的用户偏好设置方面非常有用。然而，其安全性较低和大小限制使其不适合存储敏感信息或大量数据。

- **Session** 通过在服务器端存储用户数据，提供了更高的安全性，适合管理敏感的用户会话信息。但它给服务器带来了存储和管理开销，并且在分布式环境下存在扩展性挑战。

- **JWT** 作为一种现代的、基于令牌的无状态认证机制，凭借其自包含性、可扩展性和跨域友好性，在 API 认证、微服务架构和移动应用中表现出色。其主要挑战在于令牌的吊销管理和密钥的安全性。

理解这三种技术的内在机制、权衡它们的优缺点，并根据应用的具体需求（如安全性要求、系统架构、可扩展性、用户体验等）做出明智的选择，是每一位 Web 开发者的必备技能。没有一种技术是万能的，合适的才是最好的。希望本文能帮助你更清晰地认识 Cookie、Session 和 JWT，并在你的项目中做出更优的技术选型。
