const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/LazyFancybox-BSCIBjqy.js","assets/react-CVYtF6D5.js","assets/ui-Cc7-XuPu.js","assets/utils-BCXp12gC.js","assets/markdown-vAHLFhfp.js"])))=>i.map(i=>d[i]);
import{r as n,a as e,L as t,g as o,b as s,u as r,H as a,R as i,d as c}from"./react-CVYtF6D5.js";import{r as l,a as u,p as d}from"./utils-BCXp12gC.js";import"./ui-Cc7-XuPu.js";import{r as p,a as m,b as h,c as f,d as g,e as b,f as k,g as v,h as S,i as y,j as w,k as C,l as x,m as j,n as T,o as P,p as R,q as M,s as I,t as E,u as H,v as D,w as W,x as A,y as L,z as N,A as F,B as O,C as V,D as U,E as J,F as q,G as B,H as z,I as G,J as _,K as $,L as X,M as Q}from"./markdown-vAHLFhfp.js";!function(){const n=document.createElement("link").relList;if(!(n&&n.supports&&n.supports("modulepreload"))){for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver((n=>{for(const t of n)if("childList"===t.type)for(const n of t.addedNodes)"LINK"===n.tagName&&"modulepreload"===n.rel&&e(n)})).observe(document,{childList:!0,subtree:!0})}function e(n){if(n.ep)return;n.ep=!0;const e=function(n){const e={};return n.integrity&&(e.integrity=n.integrity),n.referrerPolicy&&(e.referrerPolicy=n.referrerPolicy),"use-credentials"===n.crossOrigin?e.credentials="include":"anonymous"===n.crossOrigin?e.credentials="omit":e.credentials="same-origin",e}(n);fetch(n.href,e)}}();var K,Y,Z={exports:{}},nn={};var en,tn=(Y||(Y=1,Z.exports=function(){if(K)return nn;K=1;var e=n(),t=Symbol.for("react.element"),o=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a={key:!0,ref:!0,__self:!0,__source:!0};function i(n,e,o){var i,c={},l=null,u=null;for(i in void 0!==o&&(l=""+o),void 0!==e.key&&(l=""+e.key),void 0!==e.ref&&(u=e.ref),e)s.call(e,i)&&!a.hasOwnProperty(i)&&(c[i]=e[i]);if(n&&n.defaultProps)for(i in e=n.defaultProps)void 0===c[i]&&(c[i]=e[i]);return{$$typeof:t,type:n,key:l,ref:u,props:c,_owner:r.current}}return nn.Fragment=o,nn.jsx=i,nn.jsxs=i,nn}()),Z.exports),on={};var sn=function(){if(en)return on;en=1;var n=e();return on.createRoot=n.createRoot,on.hydrateRoot=n.hydrateRoot,on}();const rn={},an=function(n,e,t){let o=Promise.resolve();if(e&&e.length>0){let n=function(n){return Promise.all(n.map((n=>Promise.resolve(n).then((n=>({status:"fulfilled",value:n})),(n=>({status:"rejected",reason:n}))))))};document.getElementsByTagName("link");const t=document.querySelector("meta[property=csp-nonce]"),s=(null==t?void 0:t.nonce)||(null==t?void 0:t.getAttribute("nonce"));o=n(e.map((n=>{if((n=function(n){return"/"+n}(n))in rn)return;rn[n]=!0;const e=n.endsWith(".css"),t=e?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${n}"]${t}`))return;const o=document.createElement("link");return o.rel=e?"stylesheet":"modulepreload",e||(o.as="script"),o.crossOrigin="",o.href=n,s&&o.setAttribute("nonce",s),document.head.appendChild(o),e?new Promise(((e,t)=>{o.addEventListener("load",e),o.addEventListener("error",(()=>t(new Error(`Unable to preload CSS for ${n}`))))})):void 0})))}function s(n){const e=new Event("vite:preloadError",{cancelable:!0});if(e.payload=n,window.dispatchEvent(e),!e.defaultPrevented)throw n}return o.then((e=>{for(const n of e||[])"rejected"===n.status&&s(n.reason);return n().catch(s)}))},cn=()=>tn.jsx("div",{className:"flex flex-row-reverse max-md:mx-4 max-md:my-0 max-md:flex-row",children:tn.jsxs("div",{className:"flex text-slate-600",children:[tn.jsx(t,{to:"/",children:tn.jsx("span",{className:"ml-5 hover:text-[#3370FF] active:text-[#3370FF] max-md:m-0 max-md:mr-5",children:"文章"})}),tn.jsx(t,{to:"/tags",children:tn.jsx("span",{className:"ml-5 hover:text-[#3370FF] active:text-[#3370FF] max-md:m-0 max-md:mr-5",children:"标签"})}),tn.jsx(t,{to:"/about-me",children:tn.jsx("span",{className:"ml-5 hover:text-[#3370FF] active:text-[#3370FF] max-md:m-0 max-md:mr-5",children:"关于我"})})]})}),ln=()=>tn.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:14,height:14,style:{fill:"#999",verticalAlign:"middle"},children:[tn.jsx("path",{fill:"none",d:"M0 0h24v24H0z"}),tn.jsx("path",{d:"M7.784 14l.42-4H4V8h4.415l.525-5h2.011l-.525 5h3.989l.525-5h2.011l-.525 5H20v2h-3.784l-.42 4H20v2h-4.415l-.525 5h-2.011l.525-5H9.585l-.525 5H7.049l.525-5H4v-2h3.784zm2.011.0h3.99l.42-4h-3.99l-.42 4z"})]});const un=o(l()),dn=s.memo((({article:n})=>tn.jsxs("div",{className:"flex justify-between justify-items-center pb-1",children:[tn.jsx(t,{to:`/articles/${n.id}`,children:tn.jsx("span",{className:"hover:text-[#3370FF] active:text-[#3370FF]",children:n.title})}),tn.jsx("span",{className:"inline-block w-20 text-right text-sm opacity-30",children:un(n.date).format("MM.DD")})]}))),pn=s.memo((({year:n,articles:e})=>tn.jsxs("div",{children:[tn.jsx("div",{className:"mx-0 mb-3 mt-8 text-2xl font-bold",children:n}),tn.jsx("div",{className:"mt-5 p-0 leading-[1.8]",children:e.map((n=>tn.jsx(dn,{article:n},n.id)))})]},n))),mn=s.memo((({articles:n})=>{const e=s.useMemo((()=>{const e={};return n.forEach((n=>{const t=un(n.date).format("YYYY");e[t]||(e[t]=[]),e[t].push(n)})),Object.entries(e).sort((([n],[e])=>Number(e)-Number(n)))}),[n]);return tn.jsx("div",{className:"mt-10",children:e.map((([n,e])=>tn.jsx(pn,{year:n,articles:e},n)))})})),hn=({message:n="抱歉，页面不见了"})=>tn.jsxs("div",{className:"flex min-h-[50vh] flex-col items-center justify-center",children:[tn.jsx("h1",{className:"mb-4 text-6xl font-bold text-gray-300",children:"404"}),tn.jsx("p",{className:"mb-8 text-lg text-gray-500",children:n}),tn.jsx(t,{to:"/",className:"rounded-md bg-blue-50 px-4 py-2 text-sm text-[#3370ff] transition-colors hover:bg-blue-100",children:"返回首页"})]});var fn=u();const gn=({headings:n,title:e})=>{const[t,o]=s.useState(""),[r,a]=s.useState(!1),i="article-title",c=s.useCallback((()=>{var e;return[{id:i,top:(null==(e=document.getElementById(i))?void 0:e.getBoundingClientRect().top)??0},...n.map((({id:n})=>{const e=document.getElementById(n);return e?{id:n,top:e.getBoundingClientRect().top}:null})).filter((n=>null!==n))]}),[n,i]),l=s.useMemo((()=>fn.throttle((()=>{const n=window.scrollY;a(n>120);const e=c(),t=e.find((n=>n.top>=96));t?o(t.id):e.length>0&&o(e[e.length-1].id)}),100)),[c,96]);s.useEffect((()=>(window.addEventListener("scroll",l),l(),()=>{window.removeEventListener("scroll",l)})),[l]);return tn.jsx("nav",{className:"fixed left-8 hidden w-64 transition-all duration-300 xl:block "+(r?"top-4":"top-[7.5rem]"),children:tn.jsxs("div",{className:"p-4",children:[tn.jsx("h3",{className:"mb-2 cursor-pointer text-base font-medium transition-colors hover:text-[#3370ff] "+(t===i?"text-[#3370ff]":"text-gray-500"),onClick:()=>{window.scrollTo({top:0})},children:e}),tn.jsx("ul",{className:"scrollbar-custom max-h-[calc(100vh-4rem)] overflow-auto",children:n.map((n=>tn.jsx("li",{className:"my-2 "+(2===n.level?"pl-0":3===n.level?"pl-4":"pl-8"),children:tn.jsx("a",{href:`#${n.id}`,className:"block text-sm transition-colors "+(t===n.id?"text-[#3370ff]":"text-gray-500 hover:text-[#3370ff]"),onClick:e=>((n,e)=>{n.preventDefault();const t=document.getElementById(e);if(t){const n=t.getBoundingClientRect().top+window.pageYOffset-96;window.scrollTo({top:n})}})(e,n.id),children:n.text})},n.id)))})]})})},bn=({size:n=24,className:e=""})=>tn.jsx("div",{className:`inline-block animate-spin rounded-full border-2 border-solid border-[#3370ff] border-r-transparent ${e}`,style:{width:n,height:n}}),kn=JSON.parse("[{\"id\":\"31888fa3\",\"title\":\"v-model 详解\",\"date\":\"# v-model 详解\",\"tags\":[],\"fileName\":\"v-model 详解.md\",\"content\":\"## 一、v-model 是什么？\\n\\n`v-model` 是 Vue 提供的一个**双向数据绑定**的语法糖，常用于表单控件（如 input、select、textarea）上，实现数据和视图的自动同步。\\n\\n**简单例子：**\\n\\n```vue\\n<template>\\n  <input v-model=\\\"msg\\\" />\\n  <p>{{ msg }}</p>\\n</template>\\n\\n<script setup>\\nimport { ref } from 'vue'\\nconst msg = ref('hello')\\n<\/script>\\n```\\n\\n- 当你输入内容时，`msg` 的值会自动更新。\\n- 当你在 JS 里修改 `msg`，input 框的内容也会自动变化。\\n\\n---\\n\\n## 二、v-model 的底层原理\\n\\n### 1. 在 Vue2 中\\n\\n- `v-model` 实际上是 `:value` + `@input` 的语法糖。\\n\\n等价于：\\n\\n```vue\\n<input :value=\\\"msg\\\" @input=\\\"msg = $event.target.value\\\" />\\n```\\n\\n- `:value=\\\"msg\\\"` 负责把数据渲染到视图\\n- `@input=\\\"msg = $event.target.value\\\"` 负责把视图的变化同步到数据\\n\\n### 2. 在 Vue3 中\\n\\n- Vue3 的 v-model 更加灵活，支持多个 v-model，底层是 `modelValue` 和 `update:modelValue` 事件。\\n\\n等价于：\\n\\n```vue\\n<input :value=\\\"msg\\\" @input=\\\"$emit('update:modelValue', $event.target.value)\\\" />\\n```\\n\\n---\\n\\n## 三、自定义组件中的 v-model\\n\\n### 1. Vue2 自定义组件\\n\\n```vue\\n<MyInput v-model=\\\"msg\\\" />\\n\\n// MyInput 组件内部\\nprops: ['value'],\\nmethods: {\\n  onInput(e) {\\n    this.$emit('input', e.target.value)\\n  }\\n}\\n```\\n\\n### 2. Vue3 自定义组件\\n\\n```vue\\n<MyInput v-model=\\\"msg\\\" />\\n\\n// MyInput 组件内部\\nprops: {\\n  modelValue: String\\n},\\nemits: ['update:modelValue'],\\nsetup(props, { emit }) {\\n  const onInput = (e) => {\\n    emit('update:modelValue', e.target.value)\\n  }\\n  return { onInput }\\n}\\n```\\n\\n---\\n\\n## 四、v-model 的高级用法\\n\\n### 1. 修饰符\\n\\n- `.lazy`：失去焦点时才同步数据\\n- `.number`：自动将输入值转为数字\\n- `.trim`：自动去除首尾空格\\n\\n```vue\\n<input v-model.lazy=\\\"msg\\\" />\\n<input v-model.number=\\\"age\\\" />\\n<input v-model.trim=\\\"name\\\" />\\n```\\n\\n### 2. 多个 v-model（Vue3）\\n\\n```vue\\n<MyInput v-model:title=\\\"title\\\" v-model:content=\\\"content\\\" />\\n// 组件内部 props: { title: String, content: String }\\n// emits: ['update:title', 'update:content']\\n```\\n\\n---\\n\\n## 五、v-model 的实现流程图\\n\\n```mermaid\\ngraph TD\\n    A[数据变化] --\x3e B[视图自动更新]\\n    B --\x3e C[用户输入]\\n    C --\x3e D[触发 input 事件]\\n    D --\x3e E[数据自动更新]\\n```\\n\\n---\\n\\n## 六、常见问题\\n\\n1. **v-model 只能用于表单吗？**\\n\\n   - 不是。自定义组件也可以用，只要实现对应的 props 和事件。\\n\\n2. **v-model 和 watch 有什么区别？**\\n\\n   - v-model 是数据和视图的双向绑定，watch 是监听数据变化做额外处理。\\n\\n3. **v-model 支持对象/数组吗？**\\n   - 支持，和普通数据一样。\\n\\n---\\n\\n## 七、总结\\n\\n- v-model 是 Vue 的双向绑定语法糖\\n- Vue2 本质是 `:value` + `@input`\\n- Vue3 本质是 `modelValue` + `update:modelValue`\\n- 支持自定义组件、修饰符和多 v-model\\n- Proxy 和响应式系统保证了数据和视图的自动同步\\n\",\"wordCount\":375},{\"id\":\"42a76ceb\",\"title\":\"前端开发常见的库和工具\",\"date\":\"2024-09-28\",\"tags\":[\"工具\"],\"fileName\":\"前端开发常见的库和工具.md\",\"content\":\"\\n## 前言\\n\\n前端开发领域发展迅速，各种库和工具层出不穷。本文将介绍当前前端开发中最常用的库和工具，帮助开发者了解现代前端技术栈。\\n\\n## UI 框架与库\\n\\n### React\\n\\n> React 是由 Facebook 开发的用于构建用户界面的 JavaScript 库，以组件化开发和虚拟 DOM 为核心特性。\\n\\n- 特点：组件化、声明式编程、虚拟 DOM、单向数据流\\n- 生态：React Router、Redux、MobX、Next.js\\n- 链接：[官方文档](https://reactjs.org/) | [GitHub](https://github.com/facebook/react)\\n\\n### Vue\\n\\n> Vue 是一个渐进式 JavaScript 框架，易于上手且灵活。\\n\\n- 特点：响应式数据绑定、组件化、模板语法、双向绑定\\n- 生态：Vue Router、Vuex/Pinia、Nuxt.js\\n- 链接：[官方文档](https://vuejs.org/) | [GitHub](https://github.com/vuejs/core)\\n\\n### Angular\\n\\n> 由 Google 维护的完整前端框架，提供了从开发到测试的全套解决方案。\\n\\n- 特点：TypeScript 支持、依赖注入、双向绑定、完整的 MVC 架构\\n- 生态：Angular Material、NgRx、Angular Universal\\n- 链接：[官方文档](https://angular.io/) | [GitHub](https://github.com/angular/angular)\\n\\n### Svelte\\n\\n> 编译时框架，将组件编译为高效的命令式代码。\\n\\n- 特点：无虚拟 DOM、更少的样板代码、真正的反应性\\n- 生态：SvelteKit、Svelte Store\\n- 链接：[官方文档](https://svelte.dev/) | [GitHub](https://github.com/sveltejs/svelte)\\n\\n## UI 组件库\\n\\n### Ant Design\\n\\n> 阿里巴巴开发的企业级 UI 设计语言和 React 组件库。\\n\\n- 特点：丰富的组件、企业级设计、可定制主题\\n- 生态：Ant Design Pro、Ant Design Mobile、Ant Design Charts\\n- 链接：[官方文档](https://ant.design/) | [GitHub](https://github.com/ant-design/ant-design)\\n\\n### Element UI / Element Plus\\n\\n> 基于 Vue 的桌面端组件库，Element Plus 是 Vue 3 版本。\\n\\n- 特点：完整的设计系统、国际化支持、主题定制\\n- 生态：Element Admin、Element Theme\\n- 链接：[Element Plus 官方文档](https://element-plus.org/) | [GitHub](https://github.com/element-plus/element-plus)\\n\\n### Material-UI (MUI)\\n\\n> 实现 Google Material Design 的 React 组件库。\\n\\n- 特点：遵循 Material Design、响应式设计、可定制\\n- 链接：[官方文档](https://mui.com/) | [GitHub](https://github.com/mui/material-ui)\\n\\n### Chakra UI\\n\\n> 基于 React 的简洁、模块化和可访问的组件库。\\n\\n- 特点：可访问性、主题系统、开箱即用\\n- 链接：[官方文档](https://chakra-ui.com/) | [GitHub](https://github.com/chakra-ui/chakra-ui)\\n\\n### TailwindUI\\n\\n> 基于 Tailwind CSS 的精美 UI 组件集合。\\n\\n- 特点：响应式设计、现代美观、易于集成\\n- 链接：[官方网站](https://tailwindui.com/)\\n\\n## 表单处理与验证\\n\\n### Formik\\n\\n> React 表单管理库，简化表单处理、验证和提交。\\n\\n- 特点：减少样板代码、内置验证、错误处理\\n- 链接：[官方文档](https://formik.org/) | [GitHub](https://github.com/jaredpalmer/formik)\\n\\n### React Hook Form\\n\\n> 基于 React Hooks 的高性能表单库。\\n\\n- 特点：性能优化、无依赖、易于集成\\n- 链接：[官方文档](https://react-hook-form.com/) | [GitHub](https://github.com/react-hook-form/react-hook-form)\\n\\n### Yup\\n\\n> JavaScript 模式验证库，常与 Formik 配合使用。\\n\\n- 特点：声明式 API、类型转换、自定义错误消息\\n- 链接：[GitHub](https://github.com/jquense/yup)\\n\\n### Zod\\n\\n> TypeScript 优先的模式验证库。\\n\\n- 特点：类型推断、运行时验证、错误处理\\n- 链接：[官方文档](https://zod.dev/) | [GitHub](https://github.com/colinhacks/zod)\\n\\n### Vee-validate\\n\\n> Vue 的表单验证库，支持 Vue 2 和 Vue 3。\\n\\n- 特点：基于模板的验证、自定义规则、国际化\\n- 链接：[官方文档](https://vee-validate.logaretm.com/) | [GitHub](https://github.com/logaretm/vee-validate)\\n\\n### Final Form\\n\\n> 框架无关的高性能表单状态管理。\\n\\n- 特点：订阅模型、性能优化、可扩展\\n- 链接：[官方文档](https://final-form.org/) | [GitHub](https://github.com/final-form/final-form)\\n\\n## 图表库\\n\\n### Chart.js\\n\\n> 简单灵活的 JavaScript 图表库。\\n\\n- 特点：响应式、8 种图表类型、动画\\n- 链接：[官方文档](https://www.chartjs.org/) | [GitHub](https://github.com/chartjs/Chart.js)\\n\\n### D3.js\\n\\n> 强大的数据可视化库，用于创建动态交互式数据可视化。\\n\\n- 特点：灵活性高、数据驱动、DOM 操作\\n- 链接：[官方文档](https://d3js.org/) | [GitHub](https://github.com/d3/d3)\\n\\n### ECharts\\n\\n> 百度开发的功能丰富的图表库。\\n\\n- 特点：丰富的图表类型、大数据渲染、交互性\\n- 链接：[官方文档](https://echarts.apache.org/) | [GitHub](https://github.com/apache/echarts)\\n\\n### Highcharts\\n\\n> 商业级图表库，提供多种交互式图表。\\n\\n- 特点：兼容性好、交互性强、导出功能\\n- 链接：[官方文档](https://www.highcharts.com/) | [GitHub](https://github.com/highcharts/highcharts)\\n\\n### Recharts\\n\\n> 基于 React 和 D3 的可组合图表库。\\n\\n- 特点：声明式组件、自定义能力、响应式\\n- 链接：[官方文档](https://recharts.org/) | [GitHub](https://github.com/recharts/recharts)\\n\\n### Ant Design Charts\\n\\n> 基于 G2Plot 的 React 图表库，是 Ant Design 生态的一部分。\\n\\n- 特点：简单易用、主题定制、与 Ant Design 集成\\n- 链接：[官方文档](https://charts.ant.design/) | [GitHub](https://github.com/ant-design/ant-design-charts)\\n\\n### Visx\\n\\n> Airbnb 开发的低级别 React 可视化组件集合。\\n\\n- 特点：模块化、灵活性高、性能优化\\n- 链接：[官方文档](https://airbnb.io/visx/) | [GitHub](https://github.com/airbnb/visx)\\n\\n## 富文本编辑器\\n\\n### TinyMCE\\n\\n> 功能齐全的 WYSIWYG 编辑器。\\n\\n- 特点：插件系统、主题支持、自定义工具栏\\n- 链接：[官方文档](https://www.tiny.cloud/docs/) | [GitHub](https://github.com/tinymce/tinymce)\\n\\n### CKEditor\\n\\n> 专业级富文本编辑器，有多个版本可选。\\n\\n- 特点：模块化架构、协作编辑、实时预览\\n- 链接：[官方文档](https://ckeditor.com/docs/) | [GitHub](https://github.com/ckeditor/ckeditor5)\\n\\n### Quill\\n\\n> 现代化的富文本编辑器，API 驱动。\\n\\n- 特点：自定义格式、模块化、主题支持\\n- 链接：[官方文档](https://quilljs.com/) | [GitHub](https://github.com/quilljs/quill)\\n\\n### Draft.js\\n\\n> Facebook 开发的 React 富文本编辑器框架。\\n\\n- 特点：不可变模型、可定制性高、React 集成\\n- 链接：[官方文档](https://draftjs.org/) | [GitHub](https://github.com/facebook/draft-js)\\n\\n### ProseMirror\\n\\n> 模块化的富文本编辑器工具包。\\n\\n- 特点：文档模型、协作编辑、模块化设计\\n- 链接：[官方文档](https://prosemirror.net/) | [GitHub](https://github.com/ProseMirror/prosemirror)\\n\\n### Slate\\n\\n> 完全可定制的富文本编辑框架。\\n\\n- 特点：React 集成、插件系统、不可变数据\\n- 链接：[官方文档](https://docs.slatejs.org/) | [GitHub](https://github.com/ianstormtaylor/slate)\\n\\n### Tiptap\\n\\n> 基于 ProseMirror 的无头编辑器框架。\\n\\n- 特点：可扩展、协作编辑、Vue/React 支持\\n- 链接：[官方文档](https://tiptap.dev/) | [GitHub](https://github.com/ueberdosis/tiptap)\\n\\n### Lexical\\n\\n> Facebook 开发的可扩展的 Web 文本编辑器框架。\\n\\n- 特点：可访问性、性能优化、React 集成\\n- 链接：[官方文档](https://lexical.dev/) | [GitHub](https://github.com/facebook/lexical)\\n\\n## 拖拽库\\n\\n### React DnD\\n\\n> React 的拖放功能实现库。\\n\\n- 特点：声明式 API、基于 HTML5 拖放 API、高度可定制\\n- 链接：[官方文档](https://react-dnd.github.io/react-dnd/) | [GitHub](https://github.com/react-dnd/react-dnd)\\n\\n### react-beautiful-dnd\\n\\n> Atlassian 开发的 React 拖放库，专注于列表和看板。\\n\\n- 特点：流畅的动画、可访问性、性能优化\\n- 链接：[官方文档](https://github.com/atlassian/react-beautiful-dnd) | [GitHub](https://github.com/atlassian/react-beautiful-dnd)\\n\\n### SortableJS\\n\\n> 功能强大的 JavaScript 拖拽排序库。\\n\\n- 特点：多种排序模式、触摸支持、框架无关\\n- 链接：[官方文档](https://github.com/SortableJS/Sortable) | [GitHub](https://github.com/SortableJS/Sortable)\\n\\n### Draggable\\n\\n> Shopify 开发的轻量级模块化拖拽库。\\n\\n- 特点：模块化设计、事件系统、多种传感器\\n- 链接：[官方文档](https://github.com/Shopify/draggable) | [GitHub](https://github.com/Shopify/draggable)\\n\\n### react-grid-layout\\n\\n> React 的可拖拽、可调整大小的网格布局。\\n\\n- 特点：响应式、可保存布局、自动布局\\n- 链接：[官方文档](https://github.com/react-grid-layout/react-grid-layout) | [GitHub](https://github.com/react-grid-layout/react-grid-layout)\\n\\n### vue-draggable\\n\\n> 基于 SortableJS 的 Vue 组件，实现拖拽功能。\\n\\n- 特点：与 Vue 集成、动画效果、事件系统\\n- 链接：[GitHub](https://github.com/SortableJS/Vue.Draggable)\\n\\n## 存储库\\n\\n### localforage\\n\\n> 改进的离线存储 API，使用 IndexedDB、WebSQL 或 localStorage。\\n\\n- 特点：异步 API、Promise 支持、大容量存储\\n- 链接：[官方文档](https://localforage.github.io/localForage/) | [GitHub](https://github.com/localForage/localForage)\\n\\n### store.js\\n\\n> 跨浏览器存储，自动使用最佳可用存储机制。\\n\\n- 特点：简单 API、跨浏览器兼容、插件系统\\n- 链接：[GitHub](https://github.com/marcuswestin/store.js)\\n\\n### idb\\n\\n> IndexedDB 的轻量级包装器，使其更易于使用。\\n\\n- 特点：Promise 接口、简化 API、类型安全\\n- 链接：[GitHub](https://github.com/jakearchibald/idb)\\n\\n### Dexie.js\\n\\n> IndexedDB 的包装库，提供更友好的 API。\\n\\n- 特点：简洁语法、Promise 支持、复杂查询\\n- 链接：[官方文档](https://dexie.org/) | [GitHub](https://github.com/dexie/Dexie.js)\\n\\n### PouchDB\\n\\n> 受 CouchDB 启发的客户端数据库，支持离线同步。\\n\\n- 特点：离线优先、数据同步、跨浏览器\\n- 链接：[官方文档](https://pouchdb.com/) | [GitHub](https://github.com/pouchdb/pouchdb)\\n\\n### rxdb\\n\\n> 实时、离线优先的数据库，基于 RxJS。\\n\\n- 特点：响应式查询、数据复制、离线优先\\n- 链接：[官方文档](https://rxdb.info/) | [GitHub](https://github.com/pubkey/rxdb)\\n\\n## 国际化\\n\\n### i18next\\n\\n> 功能丰富的国际化框架。\\n\\n- 特点：插件系统、嵌套翻译、复数处理\\n- 链接：[官方文档](https://www.i18next.com/) | [GitHub](https://github.com/i18next/i18next)\\n\\n### react-i18next\\n\\n> i18next 的 React 集成。\\n\\n- 特点：组件、Hooks、高阶组件\\n- 链接：[官方文档](https://react.i18next.com/) | [GitHub](https://github.com/i18next/react-i18next)\\n\\n### vue-i18n\\n\\n> Vue.js 的国际化插件。\\n\\n- 特点：与 Vue 深度集成、日期/数字本地化、复数处理\\n- 链接：[官方文档](https://kazupon.github.io/vue-i18n/) | [GitHub](https://github.com/intlify/vue-i18n-next)\\n\\n### FormatJS\\n\\n> 国际化库集合，包括 React Intl。\\n\\n- 特点：格式化消息、相对时间、数字格式化\\n- 链接：[官方文档](https://formatjs.io/) | [GitHub](https://github.com/formatjs/formatjs)\\n\\n### Lingui\\n\\n> 基于 ICU 消息格式的国际化库。\\n\\n- 特点：类型安全、提取消息、编译时优化\\n- 链接：[官方文档](https://lingui.js.org/) | [GitHub](https://github.com/lingui/js-lingui)\\n\\n## 自定义 Hooks 库\\n\\n### ahooks\\n\\n> 阿里巴巴开源的 React Hooks 库。\\n\\n- 特点：丰富的 Hooks 集合、稳定性高、类型安全\\n- 链接：[官方文档](https://ahooks.js.org/) | [GitHub](https://github.com/alibaba/hooks)\\n\\n### react-use\\n\\n> React Hooks 的大型集合。\\n\\n- 特点：多种功能 Hooks、轻量级、模块化\\n- 链接：[官方文档](https://github.com/streamich/react-use) | [GitHub](https://github.com/streamich/react-use)\\n\\n### use-http\\n\\n> 用于 React 的 HTTP 请求 Hook。\\n\\n- 特点：缓存、重试、并发控制\\n- 链接：[GitHub](https://github.com/ava/use-http)\\n\\n### SWR\\n\\n> 用于数据获取的 React Hooks 库。\\n\\n- 特点：缓存、自动重新验证、错误重试\\n- 链接：[官方文档](https://swr.vercel.app/) | [GitHub](https://github.com/vercel/swr)\\n\\n### react-query\\n\\n> 用于管理服务器状态的 React 库。\\n\\n- 特点：缓存管理、后台更新、分页支持\\n- 链接：[官方文档](https://tanstack.com/query/latest) | [GitHub](https://github.com/TanStack/query)\\n\\n### VueUse\\n\\n> Vue 组合式 API 的实用工具集合。\\n\\n- 特点：丰富的功能、跨版本支持、模块化\\n- 链接：[官方文档](https://vueuse.org/) | [GitHub](https://github.com/vueuse/vueuse)\\n\\n## 模拟数据\\n\\n### Mock.js\\n\\n> 生成随机数据，拦截 Ajax 请求。\\n\\n- 特点：丰富的数据模板、灵活的语法、请求拦截\\n- 链接：[官方文档](http://mockjs.com/) | [GitHub](https://github.com/nuysoft/Mock)\\n\\n### MSW (Mock Service Worker)\\n\\n> API 模拟库，使用服务工作者拦截请求。\\n\\n- 特点：浏览器和 Node.js 支持、REST/GraphQL、与测试框架集成\\n- 链接：[官方文档](https://mswjs.io/) | [GitHub](https://github.com/mswjs/msw)\\n\\n### json-server\\n\\n> 快速创建 REST API 模拟服务器。\\n\\n- 特点：零编码、支持 REST 操作、可自定义路由\\n- 链接：[GitHub](https://github.com/typicode/json-server)\\n\\n### Mirage JS\\n\\n> 前端 API 模拟库，无需后端服务器。\\n\\n- 特点：模拟完整 API、数据关系、网络延迟\\n- 链接：[官方文档](https://miragejs.com/) | [GitHub](https://github.com/miragejs/miragejs)\\n\\n### Faker.js\\n\\n> 生成大量逼真的假数据。\\n\\n- 特点：多种数据类型、本地化支持、可定制\\n- 链接：[官方文档](https://fakerjs.dev/) | [GitHub](https://github.com/faker-js/faker)\\n\\n## 路由管理\\n\\n### React Router\\n\\n> React 应用的标准路由库。\\n\\n- 特点：声明式路由、嵌套路由、路由守卫\\n- 版本：React Router v6 提供了更简洁的 API 和更好的性能\\n- 链接：[官方文档](https://reactrouter.com/) | [GitHub](https://github.com/remix-run/react-router)\\n\\n### Vue Router\\n\\n> Vue.js 的官方路由管理器。\\n\\n- 特点：动态路由匹配、导航守卫、路由元信息\\n- 链接：[官方文档](https://router.vuejs.org/) | [GitHub](https://github.com/vuejs/router)\\n\\n### TanStack Router\\n\\n> 框架无关的类型安全路由解决方案。\\n\\n- 特点：完全类型安全、搜索参数管理、路由预加载\\n- 链接：[官方文档](https://tanstack.com/router/latest) | [GitHub](https://github.com/TanStack/router)\\n\\n### Wouter\\n\\n> React 的轻量级路由库，API 类似 React Router。\\n\\n- 特点：体积小、无依赖、Hook 友好\\n- 链接：[GitHub](https://github.com/molefrog/wouter)\\n\\n## CSS 解决方案\\n\\n### Tailwind CSS\\n\\n> 功能类优先的 CSS 框架，通过组合原子类构建界面。\\n\\n- 特点：高度可定制、无需编写 CSS、响应式设计\\n- 工具：Tailwind UI、Headless UI\\n- 链接：[官方文档](https://tailwindcss.com/) | [GitHub](https://github.com/tailwindlabs/tailwindcss)\\n\\n### styled-components\\n\\n> CSS-in-JS 解决方案，允许在 JavaScript 中编写 CSS。\\n\\n- 特点：组件级样式隔离、动态样式、主题支持\\n- 链接：[官方文档](https://styled-components.com/) | [GitHub](https://github.com/styled-components/styled-components)\\n\\n### SASS/SCSS\\n\\n> CSS 预处理器，增强了 CSS 的功能。\\n\\n- 特点：变量、嵌套规则、混合器、函数\\n- 链接：[官方文档](https://sass-lang.com/) | [GitHub](https://github.com/sass/sass)\\n\\n### PostCSS\\n\\n> CSS 转换工具，通过 JavaScript 插件转换 CSS。\\n\\n- 特点：模块化、可扩展、生态丰富\\n- 插件：Autoprefixer、cssnano、postcss-preset-env\\n- 链接：[官方文档](https://postcss.org/) | [GitHub](https://github.com/postcss/postcss)\\n\\n## 状态管理\\n\\n### Redux\\n\\n> React 生态系统中流行的状态管理库。\\n\\n- 特点：单一数据源、状态不可变、纯函数 reducer\\n- 工具：Redux Toolkit、Redux Saga、Redux Thunk\\n- 链接：[官方文档](https://redux.js.org/) | [GitHub](https://github.com/reduxjs/redux)\\n\\n### Zustand\\n\\n> 轻量级状态管理库，API 简洁。\\n\\n- 特点：简单易用、Hook 友好、无样板代码\\n- 链接：[官方文档](https://zustand-demo.pmnd.rs/) | [GitHub](https://github.com/pmndrs/zustand)\\n\\n### Pinia\\n\\n> Vue 官方推荐的状态管理库，替代 Vuex。\\n\\n- 特点：TypeScript 支持、模块化设计、开发工具集成\\n- 链接：[官方文档](https://pinia.vuejs.org/) | [GitHub](https://github.com/vuejs/pinia)\\n\\n### Jotai\\n\\n> 原子化状态管理库，专为 React 设计。\\n\\n- 特点：细粒度更新、无样板代码、TypeScript 友好\\n- 链接：[官方文档](https://jotai.org/) | [GitHub](https://github.com/pmndrs/jotai)\\n\\n## 语言和类型系统\\n\\n### TypeScript\\n\\n> JavaScript 的超集，添加了静态类型系统。\\n\\n- 特点：静态类型检查、接口、泛型、装饰器\\n- 工具：TSC、TSLint、TypeDoc\\n- 链接：[官方文档](https://www.typescriptlang.org/) | [GitHub](https://github.com/microsoft/TypeScript)\\n\\n### Flow\\n\\n> Facebook 开发的 JavaScript 静态类型检查器。\\n\\n- 特点：渐进式类型检查、类型推断、可选注解\\n- 链接：[官方文档](https://flow.org/) | [GitHub](https://github.com/facebook/flow)\\n\\n### Babel\\n\\n> JavaScript 编译器，用于将新特性转换为兼容代码。\\n\\n- 特点：插件系统、预设配置、源码映射\\n- 链接：[官方文档](https://babeljs.io/) | [GitHub](https://github.com/babel/babel)\\n\\n## 工具库\\n\\n### Lodash\\n\\n> 实用工具库，提供模块化、高性能的方法。\\n\\n- 功能：数组操作、对象处理、函数式编程工具\\n- 链接：[官方文档](https://lodash.com/) | [GitHub](https://github.com/lodash/lodash)\\n\\n### Day.js\\n\\n> 轻量级日期处理库，API 与 Moment.js 兼容。\\n\\n- 特点：体积小、链式操作、国际化支持\\n- 链接：[官方文档](https://day.js.org/) | [GitHub](https://github.com/iamkun/dayjs)\\n\\n### Axios\\n\\n> 基于 Promise 的 HTTP 客户端。\\n\\n- 特点：请求/响应拦截、取消请求、自动转换 JSON\\n- 链接：[官方文档](https://axios-http.com/) | [GitHub](https://github.com/axios/axios)\\n\\n### Commander.js\\n\\n> Node.js 命令行界面工具，用于构建 CLI 应用。\\n\\n- 特点：参数解析、子命令支持、帮助信息生成\\n- 链接：[官方文档](https://github.com/tj/commander.js) | [GitHub](https://github.com/tj/commander.js)\\n\\n### Inquirer.js\\n\\n> 交互式命令行用户界面集合。\\n\\n- 特点：各种问题类型、输入验证、异步支持\\n- 链接：[GitHub](https://github.com/SBoudrias/Inquirer.js)\\n\\n### Chalk\\n\\n> 终端字符串样式库，用于美化命令行输出。\\n\\n- 特点：嵌套样式、多种颜色、链式调用\\n- 链接：[GitHub](https://github.com/chalk/chalk)\\n\\n### Ora\\n\\n> 优雅的终端加载动画。\\n\\n- 特点：多种动画样式、自定义文本、颜色支持\\n- 链接：[GitHub](https://github.com/sindresorhus/ora)\\n\\n### Progress-estimator\\n\\n> 命令行进度条，带有时间估计。\\n\\n- 特点：时间估计、多任务支持、自定义主题\\n- 链接：[GitHub](https://github.com/bvaughn/progress-estimator)\\n\\n### Simple-git\\n\\n> 在 Node.js 中使用 Git 的简单工具。\\n\\n- 特点：Promise 支持、流畅的 API、完整的 Git 命令支持\\n- 链接：[GitHub](https://github.com/steveukx/git-js)\\n\\n### DOMPurify\\n\\n> XSS 防护库，用于清理 HTML、MathML 和 SVG。\\n\\n- 特点：防止 XSS 攻击、高性能、配置灵活\\n- 链接：[GitHub](https://github.com/cure53/DOMPurify)\\n\\n## 构建工具\\n\\n### Vite\\n\\n> 现代前端构建工具，开发服务器基于原生 ES 模块。\\n\\n- 特点：快速冷启动、热模块替换、按需编译\\n- 链接：[官方文档](https://vitejs.dev/) | [GitHub](https://github.com/vitejs/vite)\\n\\n### Webpack\\n\\n> 功能强大的模块打包器。\\n\\n- 特点：代码分割、资源管理、插件系统\\n- 链接：[官方文档](https://webpack.js.org/) | [GitHub](https://github.com/webpack/webpack)\\n\\n### Rollup\\n\\n> 专注于 ES 模块的打包工具，适合库开发。\\n\\n- 特点：Tree-shaking、代码分割、插件生态\\n- 链接：[官方文档](https://rollupjs.org/) | [GitHub](https://github.com/rollup/rollup)\\n\\n### esbuild\\n\\n> 用 Go 编写的极速 JavaScript 打包器。\\n\\n- 特点：极快的构建速度、内置压缩、TypeScript 支持\\n- 链接：[官方文档](https://esbuild.github.io/) | [GitHub](https://github.com/evanw/esbuild)\\n\\n### Terser\\n\\n> JavaScript 解析器、压缩和美化工具。\\n\\n- 特点：ES6+ 支持、代码压缩、变量名混淆\\n- 链接：[官方文档](https://terser.org/) | [GitHub](https://github.com/terser/terser)\\n\\n### SWC\\n\\n> 用 Rust 编写的超快速 JavaScript/TypeScript 编译器。\\n\\n- 特点：比 Babel 快 20 倍、TypeScript 支持、插件系统\\n- 链接：[官方文档](https://swc.rs/) | [GitHub](https://github.com/swc-project/swc)\\n\\n## 代码质量工具\\n\\n### ESLint\\n\\n> JavaScript 和 TypeScript 代码检查工具。\\n\\n- 特点：可配置规则、插件系统、自动修复\\n- 链接：[官方文档](https://eslint.org/) | [GitHub](https://github.com/eslint/eslint)\\n\\n### Prettier\\n\\n> 代码格式化工具，支持多种语言。\\n\\n- 特点：固定的格式化风格、集成编辑器、支持多种语言\\n- 链接：[官方文档](https://prettier.io/) | [GitHub](https://github.com/prettier/prettier)\\n\\n### @trivago/prettier-plugin-sort-imports\\n\\n> Prettier 插件，用于自动排序导入语句。\\n\\n- 特点：自定义导入顺序、分组导入、排序规范\\n- 链接：[GitHub](https://github.com/trivago/prettier-plugin-sort-imports)\\n\\n### Husky\\n\\n> Git hooks 工具，用于在 Git 事件触发时执行脚本。\\n\\n- 特点：提交前检查、推送前验证、简单配置\\n- 链接：[官方文档](https://typicode.github.io/husky/) | [GitHub](https://github.com/typicode/husky)\\n\\n### lint-staged\\n\\n> 在 Git 暂存文件上运行 linters 的工具。\\n\\n- 特点：只检查修改的文件、与 Husky 配合使用\\n- 链接：[GitHub](https://github.com/okonet/lint-staged)\\n\\n### Commitlint\\n\\n> 检查 Git 提交消息是否符合约定式提交规范。\\n\\n- 特点：强制规范提交信息、可自定义规则\\n- 链接：[官方文档](https://commitlint.js.org/) | [GitHub](https://github.com/conventional-changelog/commitlint)\\n\\n### Standard-version\\n\\n> 自动版本控制和 CHANGELOG 生成工具。\\n\\n- 特点：语义化版本控制、自动生成 CHANGELOG、Git 标签\\n- 链接：[GitHub](https://github.com/conventional-changelog/standard-version)\\n\\n## 包管理工具\\n\\n### npm\\n\\n> Node.js 默认的包管理器。\\n\\n- 特点：庞大的生态系统、脚本运行、依赖管理\\n- 链接：[官方文档](https://docs.npmjs.com/) | [GitHub](https://github.com/npm/cli)\\n\\n### Yarn\\n\\n> Facebook 开发的 npm 替代品。\\n\\n- 特点：并行安装、离线模式、工作区支持\\n- 链接：[官方文档](https://yarnpkg.com/) | [GitHub](https://github.com/yarnpkg/berry)\\n\\n### pnpm\\n\\n> 高效的 npm 替代品，使用硬链接节省磁盘空间。\\n\\n- 特点：节省磁盘空间、严格的依赖管理、快速安装\\n- 链接：[官方文档](https://pnpm.io/) | [GitHub](https://github.com/pnpm/pnpm)\\n\\n## 开发工具\\n\\n### Storybook\\n\\n> UI 组件开发和文档工具。\\n\\n- 特点：独立开发组件、交互式文档、插件生态\\n- 链接：[官方文档](https://storybook.js.org/) | [GitHub](https://github.com/storybookjs/storybook)\\n\\n### Nx\\n\\n> 用于管理 monorepo 的工具集。\\n\\n- 特点：增量构建、依赖图、缓存\\n- 链接：[官方文档](https://nx.dev/) | [GitHub](https://github.com/nrwl/nx)\\n\\n### Turborepo\\n\\n> 高性能的 JavaScript 和 TypeScript monorepo 构建系统。\\n\\n- 特点：增量构建、远程缓存、任务管理\\n- 链接：[官方文档](https://turbo.build/repo) | [GitHub](https://github.com/vercel/turbo)\\n\\n### Yalc\\n\\n> 本地包开发和测试工具，比 npm link 更可靠。\\n\\n- 特点：模拟真实安装、多项目支持、版本管理\\n- 链接：[GitHub](https://github.com/wclr/yalc)\\n\\n## 测试工具\\n\\n### Jest\\n\\n> JavaScript 测试框架，专注于简单性。\\n\\n- 特点：零配置、快照测试、模拟功能\\n- 链接：[官方文档](https://jestjs.io/) | [GitHub](https://github.com/facebook/jest)\\n\\n### Vitest\\n\\n> 基于 Vite 的测试框架。\\n\\n- 特点：与 Vite 配置共享、兼容 Jest API、快速执行\\n- 链接：[官方文档](https://vitest.dev/) | [GitHub](https://github.com/vitest-dev/vitest)\\n\\n## 移动端开发\\n\\n### React Native\\n\\n> 使用 React 构建原生移动应用。\\n\\n- 特点：跨平台、热重载、原生组件\\n- 链接：[官方文档](https://reactnative.dev/) | [GitHub](https://github.com/facebook/react-native)\\n\\n### Flutter\\n\\n> Google 的 UI 工具包，用于构建跨平台应用。\\n\\n- 特点：高性能、丰富的组件、热重载\\n- 链接：[官方文档](https://flutter.dev/) | [GitHub](https://github.com/flutter/flutter)\\n\\n## Node.js 开发\\n\\n### Express\\n\\n> 流行的 Node.js Web 应用框架。\\n\\n- 特点：简洁的 API、中间件支持、路由系统\\n- 链接：[官方文档](https://expressjs.com/) | [GitHub](https://github.com/expressjs/express)\\n\\n### Nest.js\\n\\n> 基于 Node.js 的渐进式框架，用于构建高效的、可扩展的服务器端应用。\\n\\n- 特点：模块化设计、依赖注入、自动路由\\n- 链接：[官方文档](https://nestjs.com/) | [GitHub](https://github.com/nestjs/nest)\\n\\n### Koa\\n\\n> 下一代的 Web 框架，基于 async/await。\\n\\n- 特点：轻量级、中间件支持、异步编程\\n- 链接：[官方文档](https://koajs.com/) | [GitHub](https://github.com/koajs/koa)\\n\\n## 安全工具\\n\\n### Helmet\\n\\n> Express 应用的安全中间件集合。\\n\\n- 特点：设置各种 HTTP 头、防止常见攻击\\n- 链接：[官方文档](https://helmetjs.github.io/) | [GitHub](https://github.com/helmetjs/helmet)\\n\\n### JWT\\n\\n> JSON Web Token 实现，用于安全传输信息。\\n\\n- 特点：无状态认证、跨域支持、防篡改\\n- 链接：[官方文档](https://jwt.io/) | [GitHub](https://github.com/auth0/node-jsonwebtoken)\\n\\n### Crypto-js\\n\\n> JavaScript 加密库，提供各种加密算法。\\n\\n- 特点：多种加密算法、哈希函数、编码工具\\n- 链接：[GitHub](https://github.com/brix/crypto-js)\\n\\n## 性能优化\\n\\n### Lighthouse\\n\\n> Google 开发的网站性能分析工具。\\n\\n- 特点：性能评分、最佳实践检查、SEO 分析\\n- 链接：[官方文档](https://developers.google.com/web/tools/lighthouse) | [GitHub](https://github.com/GoogleChrome/lighthouse)\\n\\n### Web Vitals\\n\\n> Google 的网站核心性能指标库。\\n\\n- 特点：测量 CLS、FID、LCP 等关键指标\\n- 链接：[官方文档](https://web.dev/vitals/) | [GitHub](https://github.com/GoogleChrome/web-vitals)\\n\\n### Webpack Bundle Analyzer\\n\\n> Webpack 打包分析工具，可视化包大小。\\n\\n- 特点：交互式可视化、体积分析、依赖关系图\\n- 链接：[GitHub](https://github.com/webpack-contrib/webpack-bundle-analyzer)\\n\\n## 微前端框架\\n\\n### qiankun\\n\\n> 基于 single-spa 的微前端实现，由蚂蚁金服开发。\\n\\n- 特点：HTML Entry 接入方式、样式隔离、JS 沙箱\\n- 链接：[官方文档](https://qiankun.umijs.org/zh) | [GitHub](https://github.com/umijs/qiankun)\\n\\n### Garfish\\n\\n> 字节跳动开源的微前端框架。\\n\\n- 特点：性能优化、预加载机制、多实例沙箱\\n- 链接：[官方文档](https://garfish.top/) | [GitHub](https://github.com/modern-js-dev/garfish)\\n\\n### single-spa\\n\\n> 一个用于前端微服务的 JavaScript 框架。\\n\\n- 特点：框架无关、独立部署、懒加载\\n- 链接：[官方文档](https://single-spa.js.org/) | [GitHub](https://github.com/single-spa/single-spa)\\n\\n### Micro-app\\n\\n> 京东开源的微前端框架，使用 Web Components 技术。\\n\\n- 特点：去中心化、组件式 API、预加载\\n- 链接：[官方文档](https://micro-zoe.github.io/micro-app/) | [GitHub](https://github.com/micro-zoe/micro-app)\\n\\n### Module Federation\\n\\n> Webpack 5 内置的模块联邦功能，用于跨应用共享模块。\\n\\n- 特点：运行时共享代码、独立构建、动态远程加载\\n- 链接：[官方文档](https://webpack.js.org/concepts/module-federation/) | [GitHub](https://github.com/module-federation/module-federation-examples)\\n\\n## Webpack 生态\\n\\n### style-loader\\n\\n> 将 CSS 注入到 DOM 中。\\n\\n- 特点：开发环境热更新、可配置注入位置\\n- 链接：[GitHub](https://github.com/webpack-contrib/style-loader)\\n\\n### css-loader\\n\\n> 解析 CSS 文件中的 @import 和 url()。\\n\\n- 特点：处理 CSS 依赖、支持模块化 CSS\\n- 链接：[GitHub](https://github.com/webpack-contrib/css-loader)\\n\\n### less-loader\\n\\n> 将 Less 编译为 CSS。\\n\\n- 特点：支持 Less 语法、可配置 Less 选项\\n- 链接：[GitHub](https://github.com/webpack-contrib/less-loader)\\n\\n### sass-loader\\n\\n> 将 Sass/SCSS 编译为 CSS。\\n\\n- 特点：支持 Sass 语法、可配置 Sass 选项\\n- 链接：[GitHub](https://github.com/webpack-contrib/sass-loader)\\n\\n### postcss-loader\\n\\n> 使用 PostCSS 处理 CSS。\\n\\n- 特点：支持 CSS 转换、可配合插件使用\\n- 链接：[GitHub](https://github.com/webpack-contrib/postcss-loader)\\n\\n### babel-loader\\n\\n> 使用 Babel 转换 JavaScript 文件。\\n\\n- 特点：ES6+ 转 ES5、支持 TypeScript、支持 JSX\\n- 链接：[GitHub](https://github.com/babel/babel-loader)\\n\\n### ts-loader\\n\\n> 将 TypeScript 编译为 JavaScript。\\n\\n- 特点：类型检查、与 TypeScript 编译器集成\\n- 链接：[GitHub](https://github.com/TypeStrong/ts-loader)\\n\\n### file-loader\\n\\n> 将文件输出到输出目录，并返回相对 URL。\\n\\n- 特点：处理静态资源、可配置输出路径\\n- 链接：[GitHub](https://github.com/webpack-contrib/file-loader)\\n\\n### url-loader\\n\\n> 将文件转换为 base64 URI 或使用 file-loader。\\n\\n- 特点：小文件内联、大文件外部引用、减少 HTTP 请求\\n- 链接：[GitHub](https://github.com/webpack-contrib/url-loader)\\n\\n### svg-inline-loader\\n\\n> 将 SVG 作为字符串内联。\\n\\n- 特点：移除 SVG 中不必要的属性、优化 SVG 大小\\n- 链接：[GitHub](https://github.com/webpack-contrib/svg-inline-loader)\\n\\n### raw-loader\\n\\n> 将文件作为字符串导入。\\n\\n- 特点：适用于文本文件、模板文件\\n- 链接：[GitHub](https://github.com/webpack-contrib/raw-loader)\\n\\n### HtmlWebpackPlugin\\n\\n> 简化 HTML 文件的创建，自动引入打包后的资源。\\n\\n- 特点：自动生成 HTML、注入打包资源、支持模板\\n- 链接：[GitHub](https://github.com/jantimon/html-webpack-plugin)\\n\\n### MiniCssExtractPlugin\\n\\n> 将 CSS 提取到单独的文件中。\\n\\n- 特点：CSS 代码分割、按需加载、缓存优化\\n- 链接：[GitHub](https://github.com/webpack-contrib/mini-css-extract-plugin)\\n\\n### CssMinimizerWebpackPlugin\\n\\n> 优化和压缩 CSS 资源。\\n\\n- 特点：CSS 压缩、去重、优化\\n- 链接：[GitHub](https://github.com/webpack-contrib/css-minimizer-webpack-plugin)\\n\\n### TerserWebpackPlugin\\n\\n> 使用 Terser 压缩 JavaScript 代码。\\n\\n- 特点：代码压缩、去除注释、变量名混淆\\n- 链接：[GitHub](https://github.com/webpack-contrib/terser-webpack-plugin)\\n\\n### DefinePlugin\\n\\n> 在编译时创建全局常量。\\n\\n- 特点：环境变量注入、条件编译\\n- 链接：[官方文档](https://webpack.js.org/plugins/define-plugin/)\\n\\n### CopyWebpackPlugin\\n\\n> 将单个文件或整个目录复制到构建目录。\\n\\n- 特点：静态资源复制、保持目录结构\\n- 链接：[GitHub](https://github.com/webpack-contrib/copy-webpack-plugin)\\n\\n### CleanWebpackPlugin\\n\\n> 在构建前清理构建目录。\\n\\n- 特点：自动清理旧文件、可配置排除项\\n- 链接：[GitHub](https://github.com/johnagan/clean-webpack-plugin)\\n\\n### BundleAnalyzerPlugin\\n\\n> 可视化 Webpack 输出文件的大小。\\n\\n- 特点：交互式可视化、体积分析、依赖关系图\\n- 链接：[GitHub](https://github.com/webpack-contrib/webpack-bundle-analyzer)\\n\\n### CompressionWebpackPlugin\\n\\n> 预先压缩资源，生成 gzip 文件。\\n\\n- 特点：静态 gzip 压缩、减少服务器负担\\n- 链接：[GitHub](https://github.com/webpack-contrib/compression-webpack-plugin)\\n\\n### SpeedMeasurePlugin\\n\\n> 分析 Webpack 构建速度。\\n\\n- 特点：构建时间分析、插件耗时统计\\n- 链接：[GitHub](https://github.com/stephencookdev/speed-measure-webpack-plugin)\\n\\n### resolve.alias\\n\\n> Webpack 配置中用于创建导入路径别名。\\n\\n- 特点：简化导入路径、避免相对路径\\n- 链接：[官方文档](https://webpack.js.org/configuration/resolve/#resolvealias)\\n\\n### tsconfig-paths-webpack-plugin\\n\\n> 使用 TypeScript 的路径映射来解析模块。\\n\\n- 特点：与 TypeScript 路径映射集成、支持绝对导入\\n- 链接：[GitHub](https://github.com/dividab/tsconfig-paths-webpack-plugin)\\n\",\"wordCount\":4788},{\"id\":\"e8d1c458\",\"title\":\"React Hooks 完全指南\",\"date\":\"2024-09-06\",\"tags\":[\"react\"],\"fileName\":\"React Hooks 完全指南.md\",\"content\":\"\\nReact Hooks 是 React 16.8 版本引入的特性，它让我们可以在不编写 class 组件的情况下使用状态和其他 React 特性。Hooks 的出现彻底改变了 React 的开发模式，使代码更简洁、更易于理解和测试。本文将全面解析 React 内置的各种 Hooks，包括它们的用法、应用场景以及最佳实践。\\n\\n## 1. useState - 状态管理的基础\\n\\n`useState` 是最基础的 Hook，它让函数组件能够拥有自己的状态。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useState } from 'react';\\n\\nfunction Counter() {\\n  // 声明一个叫 count 的 state 变量，初始值为 0\\n  const [count, setCount] = useState(0);\\n\\n  return (\\n    <div>\\n      <p>你点击了 {count} 次</p>\\n      <button onClick={() => setCount(count + 1)}>点击我</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 函数式更新\\n\\n当新的状态需要基于之前的状态计算得出时，可以使用函数式更新：\\n\\n```jsx\\nfunction Counter() {\\n  const [count, setCount] = useState(0);\\n\\n  return (\\n    <div>\\n      <p>你点击了 {count} 次</p>\\n      {/* 使用函数式更新，确保使用的是最新的状态值 */}\\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>点击我</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 使用对象或数组作为状态\\n\\n当状态是对象或数组时，需要注意不能直接修改状态，而是要创建新的对象或数组：\\n\\n```jsx\\nfunction UserForm() {\\n  const [user, setUser] = useState({ name: '', age: 0 });\\n\\n  const handleNameChange = (e) => {\\n    // 创建新对象，保留其他字段不变\\n    setUser({ ...user, name: e.target.value });\\n  };\\n\\n  return (\\n    <form>\\n      <input value={user.name} onChange={handleNameChange} placeholder=\\\"姓名\\\" />\\n      {/* 其他表单元素 */}\\n    </form>\\n  );\\n}\\n```\\n\\n### 惰性初始化\\n\\n如果初始状态需要通过复杂计算获得，可以传入一个函数来惰性初始化状态：\\n\\n```jsx\\nfunction ExpensiveInitialState() {\\n  // 这个函数只会在组件首次渲染时执行一次\\n  const [state, setState] = useState(() => {\\n    const initialState = performExpensiveCalculation();\\n    return initialState;\\n  });\\n\\n  // 组件其余部分\\n}\\n```\\n\\n### 应用场景\\n\\n- 表单控件状态管理\\n- 切换组件可见性\\n- 计数器、定时器状态\\n- 用户输入处理\\n- 简单的组件本地状态管理\\n\\n## 2. useEffect - 处理副作用\\n\\n`useEffect` 让你在函数组件中执行副作用操作，如数据获取、订阅、手动修改 DOM 等。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useEffect, useState } from 'react';\\n\\nfunction Example() {\\n  const [count, setCount] = useState(0);\\n\\n  // 类似于 componentDidMount 和 componentDidUpdate\\n  useEffect(() => {\\n    // 更新文档标题\\n    document.title = `你点击了 ${count} 次`;\\n  });\\n\\n  return (\\n    <div>\\n      <p>你点击了 {count} 次</p>\\n      <button onClick={() => setCount(count + 1)}>点击我</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 依赖数组\\n\\n通过提供依赖数组，可以控制 effect 的执行时机：\\n\\n```jsx\\n// 仅在 count 变化时执行\\nuseEffect(() => {\\n  document.title = `你点击了 ${count} 次`;\\n}, [count]);\\n\\n// 仅在组件挂载时执行一次\\nuseEffect(() => {\\n  console.log('组件已挂载');\\n}, []);\\n```\\n\\n### 清除副作用\\n\\n有些副作用需要清除，比如订阅或定时器，可以通过返回一个函数来实现：\\n\\n```jsx\\nuseEffect(() => {\\n  // 设置订阅\\n  const subscription = dataSource.subscribe();\\n\\n  // 清除副作用\\n  return () => {\\n    subscription.unsubscribe();\\n  };\\n}, [dataSource]); // 仅在 dataSource 变化时重新订阅\\n```\\n\\n### 异步数据获取\\n\\n```jsx\\nfunction UserProfile({ userId }) {\\n  const [user, setUser] = useState(null);\\n  const [loading, setLoading] = useState(true);\\n  const [error, setError] = useState(null);\\n\\n  useEffect(() => {\\n    // 重置状态\\n    setLoading(true);\\n    setError(null);\\n\\n    // 定义异步函数\\n    const fetchUser = async () => {\\n      try {\\n        const response = await fetch(`/api/users/${userId}`);\\n        if (!response.ok) throw new Error('获取用户数据失败');\\n        const data = await response.json();\\n        setUser(data);\\n      } catch (err) {\\n        setError(err.message);\\n      } finally {\\n        setLoading(false);\\n      }\\n    };\\n\\n    fetchUser();\\n  }, [userId]); // 仅在 userId 变化时重新获取\\n\\n  if (loading) return <div>加载中...</div>;\\n  if (error) return <div>错误: {error}</div>;\\n  if (!user) return null;\\n\\n  return (\\n    <div>\\n      <h1>{user.name}</h1>\\n      <p>邮箱: {user.email}</p>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 数据获取\\n- 订阅外部数据源\\n- 手动 DOM 操作\\n- 记录日志\\n- 定时器和间隔器\\n- 与第三方库集成\\n\\n## 3. useContext - 跨组件共享数据\\n\\n`useContext` 让你可以订阅 React 的 Context，而不必使用嵌套的 Consumer 组件。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { createContext, useContext, useState } from 'react';\\n\\n// 创建一个 Context\\nconst ThemeContext = createContext('light');\\n\\nfunction App() {\\n  const [theme, setTheme] = useState('light');\\n\\n  return (\\n    <ThemeContext.Provider value={theme}>\\n      <div>\\n        <ThemedButton />\\n        <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>切换主题</button>\\n      </div>\\n    </ThemeContext.Provider>\\n  );\\n}\\n\\nfunction ThemedButton() {\\n  // 使用 useContext 获取当前主题\\n  const theme = useContext(ThemeContext);\\n\\n  return (\\n    <button style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#333' }}>\\n      我是一个主题按钮\\n    </button>\\n  );\\n}\\n```\\n\\n### 避免不必要的重渲染\\n\\n当 Context 值变化时，所有使用该 Context 的组件都会重新渲染。为了避免不必要的重渲染，可以：\\n\\n1. 拆分 Context\\n2. 使用 `useMemo` 记忆化 Context 值\\n\\n```jsx\\nfunction App() {\\n  const [theme, setTheme] = useState('light');\\n  const [user, setUser] = useState({ name: '张三' });\\n\\n  // 使用 useMemo 记忆化 Context 值\\n  const themeContextValue = useMemo(() => ({ theme, setTheme }), [theme]);\\n  const userContextValue = useMemo(() => ({ user, setUser }), [user]);\\n\\n  return (\\n    <ThemeContext.Provider value={themeContextValue}>\\n      <UserContext.Provider value={userContextValue}>\\n        <MainContent />\\n      </UserContext.Provider>\\n    </ThemeContext.Provider>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 主题切换\\n- 用户认证状态\\n- 语言偏好设置\\n- 全局状态管理\\n- 路由参数共享\\n\\n## 4. useReducer - 复杂状态管理\\n\\n`useReducer` 是 `useState` 的替代方案，适用于复杂的状态逻辑，特别是当下一个状态依赖于之前的状态时。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useReducer } from 'react';\\n\\n// 定义 reducer 函数\\nfunction counterReducer(state, action) {\\n  switch (action.type) {\\n    case 'increment':\\n      return { count: state.count + 1 };\\n    case 'decrement':\\n      return { count: state.count - 1 };\\n    case 'reset':\\n      return { count: 0 };\\n    default:\\n      throw new Error(`未知的 action 类型: ${action.type}`);\\n  }\\n}\\n\\nfunction Counter() {\\n  // 使用 useReducer\\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\\n\\n  return (\\n    <div>\\n      <p>计数: {state.count}</p>\\n      <button onClick={() => dispatch({ type: 'increment' })}>增加</button>\\n      <button onClick={() => dispatch({ type: 'decrement' })}>减少</button>\\n      <button onClick={() => dispatch({ type: 'reset' })}>重置</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 惰性初始化\\n\\n与 `useState` 类似，`useReducer` 也支持惰性初始化：\\n\\n```jsx\\nfunction init(initialCount) {\\n  return { count: initialCount };\\n}\\n\\nfunction Counter({ initialCount = 0 }) {\\n  const [state, dispatch] = useReducer(counterReducer, initialCount, init);\\n\\n  // 组件其余部分\\n}\\n```\\n\\n### 结合 Context 进行全局状态管理\\n\\n```jsx\\nimport React, { createContext, useContext, useReducer } from 'react';\\n\\n// 创建 Context\\nconst TodoContext = createContext();\\n\\n// 定义 reducer\\nfunction todoReducer(state, action) {\\n  switch (action.type) {\\n    case 'add':\\n      return [...state, { id: Date.now(), text: action.text, completed: false }];\\n    case 'toggle':\\n      return state.map((todo) => (todo.id === action.id ? { ...todo, completed: !todo.completed } : todo));\\n    case 'delete':\\n      return state.filter((todo) => todo.id !== action.id);\\n    default:\\n      return state;\\n  }\\n}\\n\\n// 创建 Provider 组件\\nfunction TodoProvider({ children }) {\\n  const [todos, dispatch] = useReducer(todoReducer, []);\\n\\n  return <TodoContext.Provider value={{ todos, dispatch }}>{children}</TodoContext.Provider>;\\n}\\n\\n// 使用 Context\\nfunction TodoList() {\\n  const { todos, dispatch } = useContext(TodoContext);\\n\\n  return (\\n    <ul>\\n      {todos.map((todo) => (\\n        <li key={todo.id}>\\n          <input type=\\\"checkbox\\\" checked={todo.completed} onChange={() => dispatch({ type: 'toggle', id: todo.id })} />\\n          <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>{todo.text}</span>\\n          <button onClick={() => dispatch({ type: 'delete', id: todo.id })}>删除</button>\\n        </li>\\n      ))}\\n    </ul>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 复杂的表单状态管理\\n- 多步骤流程控制\\n- 购物车功能\\n- 游戏状态管理\\n- 全局状态管理（结合 Context）\\n\\n## 5. useCallback - 记忆化回调函数\\n\\n`useCallback` 返回一个记忆化的回调函数，只有当依赖项变化时，该回调函数才会更新。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useCallback, useState } from 'react';\\n\\nfunction ParentComponent() {\\n  const [count, setCount] = useState(0);\\n  const [otherState, setOtherState] = useState(0);\\n\\n  // 只有当 count 变化时，handleClick 才会更新\\n  const handleClick = useCallback(() => {\\n    console.log(`当前计数: ${count}`);\\n  }, [count]);\\n\\n  return (\\n    <div>\\n      <ChildComponent onClick={handleClick} />\\n      <button onClick={() => setCount(count + 1)}>增加计数</button>\\n      <button onClick={() => setOtherState(otherState + 1)}>更新其他状态</button>\\n    </div>\\n  );\\n}\\n\\n// 使用 React.memo 包装子组件，只有当 props 变化时才重新渲染\\nconst ChildComponent = React.memo(function ChildComponent({ onClick }) {\\n  console.log('子组件渲染');\\n  return <button onClick={onClick}>点击我</button>;\\n});\\n```\\n\\n### 与 useEffect 结合使用\\n\\n```jsx\\nfunction SearchComponent({ query }) {\\n  const [results, setResults] = useState([]);\\n\\n  // 记忆化搜索函数\\n  const fetchResults = useCallback(async () => {\\n    const response = await fetch(`/api/search?q=${query}`);\\n    const data = await response.json();\\n    setResults(data);\\n  }, [query]);\\n\\n  // 当 query 或 fetchResults 变化时执行搜索\\n  useEffect(() => {\\n    fetchResults();\\n  }, [fetchResults]);\\n\\n  // 组件其余部分\\n}\\n```\\n\\n### 应用场景\\n\\n- 传递回调给子组件时避免不必要的重渲染\\n- 在依赖项列表中使用的函数\\n- 事件处理函数\\n- 防抖和节流函数的依赖\\n- API 调用函数\\n\\n## 6. useMemo - 记忆化计算结果\\n\\n`useMemo` 返回一个记忆化的值，只有当依赖项变化时，才会重新计算该值。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useMemo, useState } from 'react';\\n\\nfunction ExpensiveCalculation({ list, filter }) {\\n  // 只有当 list 或 filter 变化时，才会重新计算\\n  const filteredList = useMemo(() => {\\n    console.log('执行昂贵的计算...');\\n    return list.filter((item) => item.includes(filter));\\n  }, [list, filter]);\\n\\n  return (\\n    <ul>\\n      {filteredList.map((item) => (\\n        <li key={item}>{item}</li>\\n      ))}\\n    </ul>\\n  );\\n}\\n```\\n\\n### 避免不必要的重渲染\\n\\n```jsx\\nfunction ParentComponent() {\\n  const [count, setCount] = useState(0);\\n\\n  // 使用 useMemo 记忆化对象\\n  const userObject = useMemo(() => {\\n    return { name: 'Alice', age: 25 };\\n  }, []); // 空依赖数组，只计算一次\\n\\n  return (\\n    <div>\\n      <ChildComponent user={userObject} />\\n      <button onClick={() => setCount(count + 1)}>增加计数: {count}</button>\\n    </div>\\n  );\\n}\\n\\n// 使用 React.memo 包装子组件\\nconst ChildComponent = React.memo(function ChildComponent({ user }) {\\n  console.log('子组件渲染');\\n  return (\\n    <div>\\n      {user.name}, {user.age}\\n    </div>\\n  );\\n});\\n```\\n\\n### 与 useCallback 的区别\\n\\n- `useMemo` 记忆化计算结果（值）\\n- `useCallback` 记忆化函数本身\\n\\n```jsx\\n// 记忆化函数\\nconst memoizedCallback = useCallback(() => {\\n  doSomething(a, b);\\n}, [a, b]);\\n\\n// 等价于\\nconst memoizedCallback = useMemo(() => {\\n  return () => doSomething(a, b);\\n}, [a, b]);\\n```\\n\\n### 应用场景\\n\\n- 昂贵的计算（排序、过滤、转换大型数据集）\\n- 避免子组件不必要的重渲染\\n- 记忆化对象和数组引用\\n- 复杂的数据处理和格式化\\n- 依赖项计算\\n\\n## 7. useRef - 引用 DOM 和保存变量\\n\\n`useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数。返回的对象在组件的整个生命周期内保持不变。\\n\\n### 引用 DOM 元素\\n\\n```jsx\\nimport React, { useEffect, useRef } from 'react';\\n\\nfunction TextInputWithFocusButton() {\\n  // 创建 ref\\n  const inputRef = useRef(null);\\n\\n  // 点击按钮时聚焦输入框\\n  const focusInput = () => {\\n    inputRef.current.focus();\\n  };\\n\\n  return (\\n    <div>\\n      <input ref={inputRef} type=\\\"text\\\" />\\n      <button onClick={focusInput}>聚焦输入框</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 保存变量（不触发重渲染）\\n\\n```jsx\\nfunction Timer() {\\n  const [count, setCount] = useState(0);\\n\\n  // 使用 ref 保存定时器 ID\\n  const timerRef = useRef(null);\\n\\n  const startTimer = () => {\\n    if (timerRef.current) return; // 避免多次启动\\n\\n    timerRef.current = setInterval(() => {\\n      setCount((c) => c + 1);\\n    }, 1000);\\n  };\\n\\n  const stopTimer = () => {\\n    clearInterval(timerRef.current);\\n    timerRef.current = null;\\n  };\\n\\n  // 组件卸载时清除定时器\\n  useEffect(() => {\\n    return () => {\\n      if (timerRef.current) clearInterval(timerRef.current);\\n    };\\n  }, []);\\n\\n  return (\\n    <div>\\n      <p>计数: {count}</p>\\n      <button onClick={startTimer}>开始</button>\\n      <button onClick={stopTimer}>停止</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 保存前一个值\\n\\n```jsx\\nfunction Counter() {\\n  const [count, setCount] = useState(0);\\n\\n  // 使用 ref 保存前一个值\\n  const prevCountRef = useRef();\\n\\n  useEffect(() => {\\n    // 在渲染后更新 ref\\n    prevCountRef.current = count;\\n  });\\n\\n  const prevCount = prevCountRef.current;\\n\\n  return (\\n    <div>\\n      <p>\\n        当前值: {count}, 前一个值: {prevCount !== undefined ? prevCount : '无'}\\n      </p>\\n      <button onClick={() => setCount(count + 1)}>增加</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 访问 DOM 元素\\n- 保存定时器或订阅的 ID\\n- 保存前一个 props 或 state\\n- 存储不需要触发重渲染的值\\n- 实现命令式动画\\n\\n## 8. useImperativeHandle - 自定义暴露给父组件的实例值\\n\\n`useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { forwardRef, useImperativeHandle, useRef } from 'react';\\n\\n// 使用 forwardRef 包装组件\\nconst FancyInput = forwardRef((props, ref) => {\\n  const inputRef = useRef();\\n\\n  // 自定义暴露给父组件的实例值\\n  useImperativeHandle(ref, () => ({\\n    // 只暴露需要的方法\\n    focus: () => {\\n      inputRef.current.focus();\\n    },\\n    // 自定义方法\\n    clear: () => {\\n      inputRef.current.value = '';\\n    },\\n  }));\\n\\n  return <input ref={inputRef} />;\\n});\\n\\nfunction Parent() {\\n  const fancyInputRef = useRef();\\n\\n  const handleClick = () => {\\n    // 可以调用子组件暴露的方法\\n    fancyInputRef.current.focus();\\n  };\\n\\n  const handleClear = () => {\\n    fancyInputRef.current.clear();\\n  };\\n\\n  return (\\n    <div>\\n      <FancyInput ref={fancyInputRef} />\\n      <button onClick={handleClick}>聚焦输入框</button>\\n      <button onClick={handleClear}>清空输入框</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 自定义组件的命令式 API\\n- 限制父组件对子组件 DOM 的访问\\n- 实现复杂的表单控件\\n- 封装第三方库的命令式接口\\n- 实现自定义动画控制\\n\\n## 9. useLayoutEffect - 同步执行副作用\\n\\n`useLayoutEffect` 与 `useEffect` 的函数签名完全相同，但它会在所有 DOM 变更之后同步调用，并且会阻塞浏览器渲染。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useLayoutEffect, useRef, useState } from 'react';\\n\\nfunction Tooltip() {\\n  const [tooltipHeight, setTooltipHeight] = useState(0);\\n  const tooltipRef = useRef();\\n\\n  // 在 DOM 更新后同步测量高度\\n  useLayoutEffect(() => {\\n    const height = tooltipRef.current.getBoundingClientRect().height;\\n    setTooltipHeight(height);\\n\\n    // 根据高度调整位置，避免闪烁\\n    tooltipRef.current.style.top = `-${height}px`;\\n  }, []);\\n\\n  return (\\n    <div style={{ position: 'relative' }}>\\n      <div\\n        ref={tooltipRef}\\n        style={{\\n          position: 'absolute',\\n          backgroundColor: 'black',\\n          color: 'white',\\n          padding: '5px',\\n          borderRadius: '3px',\\n        }}\\n      >\\n        这是一个工具提示\\n      </div>\\n      <button>悬停查看提示</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 与 useEffect 的区别\\n\\n- `useEffect` 在浏览器绘制之后异步执行，不会阻塞渲染\\n- `useLayoutEffect` 在 DOM 更新之后、浏览器绘制之前同步执行，会阻塞渲染\\n- 大多数情况下应该使用 `useEffect`，只有当需要在浏览器绘制前进行 DOM 测量或修改时才使用 `useLayoutEffect`\\n\\n### 应用场景\\n\\n- 需要在渲染前测量 DOM 元素\\n- 避免闪烁或布局跳动\\n- 动画的初始化\\n- 依赖于 DOM 布局的计算\\n- 需要立即响应 DOM 变化的场景\\n\\n## 10. useDebugValue - 开发者工具中显示自定义 Hook 标签\\n\\n`useDebugValue` 可用于在 React 开发者工具中显示自定义 Hook 的标签。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useDebugValue, useEffect, useState } from 'react';\\n\\n// 自定义 Hook\\nfunction useOnlineStatus() {\\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\\n\\n  useEffect(() => {\\n    const handleOnline = () => setIsOnline(true);\\n    const handleOffline = () => setIsOnline(false);\\n\\n    window.addEventListener('online', handleOnline);\\n    window.addEventListener('offline', handleOffline);\\n\\n    return () => {\\n      window.removeEventListener('online', handleOnline);\\n      window.removeEventListener('offline', handleOffline);\\n    };\\n  }, []);\\n\\n  // 在 React 开发者工具中显示状态\\n  useDebugValue(isOnline ? '在线' : '离线');\\n\\n  return isOnline;\\n}\\n\\nfunction StatusIndicator() {\\n  const isOnline = useOnlineStatus();\\n\\n  return <div>您当前是 {isOnline ? '在线' : '离线'} 状态</div>;\\n}\\n```\\n\\n### 延迟格式化调试值\\n\\n对于可能需要昂贵格式化操作的调试值，可以传递一个格式化函数作为第二个参数：\\n\\n```jsx\\nfunction useCustomHook(data) {\\n  // ...\\n\\n  // 只有在开发者工具检查 Hook 时才会调用格式化函数\\n  useDebugValue(data, (data) => formatDataForDebug(data));\\n\\n  // ...\\n}\\n```\\n\\n### 应用场景\\n\\n- 开发自定义 Hooks 时提供调试信息\\n- 在团队协作中帮助其他开发者理解 Hook 的状态\\n- 复杂状态的可视化\\n- 开发和调试过程中的状态监控\\n\\n## 11. useSyncExternalStore - 订阅外部数据源\\n\\n`useSyncExternalStore` 是 React 18 引入的新 Hook，用于订阅外部数据源，确保在并发渲染特性下外部状态的一致性。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useSyncExternalStore } from 'react';\\n\\nfunction useWindowWidth() {\\n  // 订阅窗口宽度变化\\n  const windowWidth = useSyncExternalStore(\\n    // 订阅函数\\n    (callback) => {\\n      window.addEventListener('resize', callback);\\n      return () => window.removeEventListener('resize', callback);\\n    },\\n    // 获取当前状态的函数\\n    () => window.innerWidth,\\n    // 服务器端渲染时使用的状态（可选）\\n    () => 1024\\n  );\\n\\n  return windowWidth;\\n}\\n\\nfunction WindowSizeComponent() {\\n  const width = useWindowWidth();\\n\\n  return <div>窗口宽度: {width}px</div>;\\n}\\n```\\n\\n### 与第三方状态管理库集成\\n\\n```jsx\\nimport { useSyncExternalStore } from 'react';\\n\\nimport { createStore } from 'redux';\\n\\n// 创建 Redux store\\nconst store = createStore(reducer);\\n\\n// 自定义 Hook 连接 Redux\\nfunction useSelector(selector) {\\n  return useSyncExternalStore(\\n    // 订阅 store 变化\\n    (callback) => {\\n      const unsubscribe = store.subscribe(callback);\\n      return unsubscribe;\\n    },\\n    // 从 store 获取当前状态\\n    () => selector(store.getState())\\n  );\\n}\\n\\nfunction Counter() {\\n  // 使用自定义 Hook 获取 Redux 状态\\n  const count = useSelector((state) => state.count);\\n\\n  return (\\n    <div>\\n      <p>计数: {count}</p>\\n      <button onClick={() => store.dispatch({ type: 'INCREMENT' })}>增加</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 订阅浏览器 API（如窗口大小、网络状态）\\n- 集成第三方状态管理库（Redux、MobX 等）\\n- 订阅 WebSocket 或其他实时数据源\\n- 处理需要在并发渲染中保持一致性的外部状态\\n- 自定义事件系统\\n\\n## 12. useTransition - 非阻塞状态更新\\n\\n`useTransition` 允许将状态更新标记为非紧急的，这样其他更新可以先完成，避免界面卡顿。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useState, useTransition } from 'react';\\n\\nfunction SearchResults() {\\n  const [query, setQuery] = useState('');\\n  const [results, setResults] = useState([]);\\n  const [isPending, startTransition] = useTransition();\\n\\n  const handleChange = (e) => {\\n    // 立即更新输入框（高优先级）\\n    setQuery(e.target.value);\\n\\n    // 将搜索结果更新标记为低优先级\\n    startTransition(() => {\\n      // 假设这是一个耗时的操作\\n      const searchResults = performExpensiveSearch(e.target.value);\\n      setResults(searchResults);\\n    });\\n  };\\n\\n  return (\\n    <div>\\n      <input value={query} onChange={handleChange} />\\n\\n      {/* 显示加载状态 */}\\n      {isPending && <div>加载中...</div>}\\n\\n      {/* 显示结果 */}\\n      <ul>\\n        {results.map((item) => (\\n          <li key={item.id}>{item.name}</li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n}\\n```\\n\\n### 与 Suspense 结合使用\\n\\n```jsx\\nfunction TabContainer() {\\n  const [tab, setTab] = useState('home');\\n  const [isPending, startTransition] = useTransition();\\n\\n  const selectTab = (nextTab) => {\\n    startTransition(() => {\\n      setTab(nextTab);\\n    });\\n  };\\n\\n  return (\\n    <div>\\n      <TabButton isActive={tab === 'home'} onClick={() => selectTab('home')}>\\n        首页\\n      </TabButton>\\n      <TabButton isActive={tab === 'posts'} onClick={() => selectTab('posts')}>\\n        文章\\n      </TabButton>\\n      <TabButton isActive={tab === 'contact'} onClick={() => selectTab('contact')}>\\n        联系我们\\n      </TabButton>\\n\\n      {/* 显示加载指示器 */}\\n      {isPending && <div className=\\\"loading-indicator\\\">切换中...</div>}\\n\\n      {/* 内容区域 */}\\n      <div className=\\\"tab-content\\\">\\n        <Suspense fallback={<Spinner />}>\\n          {tab === 'home' && <HomeTab />}\\n          {tab === 'posts' && <PostsTab />}\\n          {tab === 'contact' && <ContactTab />}\\n        </Suspense>\\n      </div>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 输入框实时搜索和过滤\\n- 标签页切换\\n- 大型列表或表格的更新\\n- 复杂表单的状态更新\\n- 需要保持 UI 响应性的任何场景\\n\\n### useTransition 与防抖的比较\\n\\n在输入框实时搜索场景中，useTransition 和防抖都能解决输入框实时搜索导致的页面卡顿问题，但工作原理和适用场景不同。\\n\\nuseTransition 和防抖都能解决输入框实时搜索导致的页面卡顿问题，但工作原理和适用场景不同：\\n\\n为什么 startTransition 能解决卡顿\\nstartTransition 将状态更新标记为\\\"非紧急\\\"，React 会：\\n\\n- 优先处理输入框的更新（高优先级）\\n- 在空闲时间处理列表渲染（低优先级）\\n- 允许用户继续与页面交互，不阻塞主线程\\n- 提供 isPending 状态显示加载指示器\\n\\n```js\\nfunction SearchResults() {\\n  const [query, setQuery] = useState('');\\n  const [results, setResults] = useState([]);\\n  const [isPending, startTransition] = useTransition();\\n\\n  const handleChange = (e) => {\\n    // 立即更新输入框（高优先级）\\n    setQuery(e.target.value);\\n\\n    // 将搜索结果更新标记为低优先级\\n    startTransition(() => {\\n      // 假设这是一个耗时的操作\\n      const searchResults = performExpensiveSearch(e.target.value);\\n      setResults(searchResults);\\n    });\\n  };\\n}\\n```\\n\\n防抖方案：\\n\\n- 延迟执行搜索，直到用户停止输入\\n- 减少总请求/计算次数\\n- 完全阻止更新，直到延迟结束\\n\\nuseTransition 方案：\\n\\n- 立即开始处理，但以低优先级进行\\n- 不减少计算次数，只改变优先级\\n- 保持 UI 响应性，可被新更新中断\\n\\n选择建议\\n\\n选择 useTransition 当：\\n\\n- 需要保持 UI 响应性最重要\\n- 希望立即开始处理，但不阻塞用户交互\\n- 想要显示加载状态（通过 isPending）\\n\\n选择防抖当：\\n\\n- 需要减少 API 调用或昂贵计算的次数\\n- 用户输入非常频繁，且每次计算成本很高\\n- 网络请求需要限流\\n\\n最佳实践：结合两者使用\\n\\n```js\\nfunction SearchComponent() {\\n  const [query, setQuery] = useState('');\\n  const [results, setResults] = useState([]);\\n  const [isPending, startTransition] = useTransition();\\n\\n  // 防抖搜索函数\\n  const debouncedSearch = useCallback(\\n    debounce((searchTerm) => {\\n      startTransition(() => {\\n        const searchResults = performExpensiveSearch(searchTerm);\\n        setResults(searchResults);\\n      });\\n    }, 300),\\n    []\\n  );\\n\\n  const handleChange = (e) => {\\n    setQuery(e.target.value);\\n    debouncedSearch(e.target.value);\\n  };\\n}\\n```\\n\\n这样既减少了计算次数，又保持了 UI 的响应性。\\n\\n## 13. useDeferredValue - 延迟更新低优先级内容\\n\\n`useDeferredValue` 接收一个值，并返回该值的延迟版本。在紧急更新期间，它会保留旧值，然后在后台更新。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useDeferredValue, useState } from 'react';\\n\\nfunction SearchResults() {\\n  const [query, setQuery] = useState('');\\n\\n  // 创建查询的延迟版本\\n  const deferredQuery = useDeferredValue(query);\\n\\n  // 检查是否正在使用旧值\\n  const isStale = query !== deferredQuery;\\n\\n  return (\\n    <div>\\n      <input value={query} onChange={(e) => setQuery(e.target.value)} />\\n\\n      <div style={{ opacity: isStale ? 0.8 : 1 }}>\\n        {/* 使用延迟值渲染结果列表 */}\\n        <ResultsList query={deferredQuery} />\\n      </div>\\n    </div>\\n  );\\n}\\n\\n// 假设这是一个渲染开销很大的组件\\nfunction ResultsList({ query }) {\\n  // 模拟耗时的渲染过程\\n  const results = computeExpensiveResults(query);\\n\\n  return (\\n    <ul>\\n      {results.map((item) => (\\n        <li key={item.id}>{item.name}</li>\\n      ))}\\n    </ul>\\n  );\\n}\\n```\\n\\n### 与 memo 结合使用\\n\\n```jsx\\n// 使用 memo 包装开销大的组件\\nconst MemoizedResultsList = React.memo(ResultsList);\\n\\nfunction SearchApp() {\\n  const [query, setQuery] = useState('');\\n  const deferredQuery = useDeferredValue(query);\\n\\n  return (\\n    <div>\\n      <input value={query} onChange={(e) => setQuery(e.target.value)} />\\n\\n      {/* 只有当 deferredQuery 变化时才会重新渲染 */}\\n      <MemoizedResultsList query={deferredQuery} />\\n    </div>\\n  );\\n}\\n```\\n\\n### 与 useTransition 的区别\\n\\n- `useTransition` 用于将状态更新标记为低优先级\\n- `useDeferredValue` 用于将派生值标记为低优先级\\n- 两者都用于提高应用的响应性，但适用场景略有不同\\n\\n### 应用场景\\n\\n- 实时搜索和过滤\\n- 大型列表或表格的渲染\\n- 文本编辑器的实时预览\\n- 图表和可视化的更新\\n- 任何需要延迟渲染的场景\\n\\n### useDeferredValue 替代 startTransition + 防抖\\n\\n在输入框搜索场景中，useDeferredValue 可以替代 startTransition + 防抖的组合，提供更简洁的解决方案。\\n\\n基本实现方式\\n\\n```jsx\\nimport React, { memo, useDeferredValue, useState } from 'react';\\n\\nfunction SearchComponent() {\\n  const [query, setQuery] = useState('');\\n\\n  // 创建查询的延迟版本\\n  const deferredQuery = useDeferredValue(query);\\n\\n  // 检查是否正在使用旧值\\n  const isStale = query !== deferredQuery;\\n\\n  return (\\n    <div>\\n      <input value={query} onChange={(e) => setQuery(e.target.value)} placeholder=\\\"搜索...\\\" />\\n\\n      {/* 可选：显示加载状态 */}\\n      {isStale && <div className=\\\"loading-indicator\\\">加载中...</div>}\\n\\n      {/* 使用延迟值渲染结果列表，并添加视觉反馈 */}\\n      <div style={{ opacity: isStale ? 0.8 : 1 }}>\\n        <MemoizedResultsList query={deferredQuery} />\\n      </div>\\n    </div>\\n  );\\n}\\n\\n// 使用 memo 包装开销大的组件\\nconst MemoizedResultsList = memo(function ResultsList({ query }) {\\n  // 执行昂贵的搜索操作\\n  const results = performExpensiveSearch(query);\\n\\n  return (\\n    <ul>\\n      {results.map((item) => (\\n        <li key={item.id}>{item.name}</li>\\n      ))}\\n    </ul>\\n  );\\n});\\n```\\n\\n为什么 useDeferredValue 可以替代组合方案\\n\\n1. 自动处理优先级：useDeferredValue 内部使用了与 useTransition 相同的机制，将渲染标记为低优先级\\n2. 简化代码：不需要手动管理 startTransition 和防抖函数\\n3. 内置状态比较：通过 query !== deferredQuery 可以轻松检测是否处于\\\"stale\\\"状态\\n4. 与 memo 配合良好：结合 React.memo 使用，只有当 deferredValue 真正变化时才重新渲染昂贵组件\\n\\n使用 useDeferredValue 的最佳实践\\n\\n1. 添加视觉反馈：当使用旧值时，可以通过降低透明度等方式提供视觉反馈\\n2. 设置初始值（React 19 新特性）：\\n\\n```js\\n// 在 React 19 中可以提供初始值\\nconst deferredQuery = useDeferredValue(query, '');\\n```\\n\\n3. 与 Suspense 集成：useDeferredValue 与 Suspense 集成良好，可以优雅处理加载状态\\n4. 结合 memo 使用：确保使用 deferredValue 的组件用 memo 包装，避免不必要的重渲染\\n\\n何时选择 useDeferredValue 而非 startTransition + 防抖\\n\\n- 当你无法直接控制触发更新的代码（如第三方库）\\n- 当你想要更简洁的代码结构\\n- 当你需要对派生值而非状态更新进行优先级控制\\n- 当你想要自动处理\\\"stale\\\"状态的视觉反馈\\n\\nuseDeferredValue 提供了一种更声明式的方法来处理输入框搜索场景中的性能问题，在大多数情况下可以完全替代 startTransition + 防抖的组合方案。\\n\\n## 14. useId - 生成唯一ID\\n\\n`useId` 是 React 18 引入的新 Hook，用于生成稳定、唯一的 ID，特别适用于可访问性属性。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useId } from 'react';\\n\\nfunction FormField() {\\n  // 生成唯一 ID\\n  const id = useId();\\n\\n  return (\\n    <div>\\n      <label htmlFor={id}>邮箱</label>\\n      <input id={id} type=\\\"email\\\" />\\n    </div>\\n  );\\n}\\n```\\n\\n### 生成多个相关 ID\\n\\n```jsx\\nfunction ComplexForm() {\\n  // 生成基础 ID\\n  const baseId = useId();\\n\\n  // 派生多个相关 ID\\n  const nameId = `${baseId}-name`;\\n  const emailId = `${baseId}-email`;\\n  const passwordId = `${baseId}-password`;\\n\\n  return (\\n    <form>\\n      <div>\\n        <label htmlFor={nameId}>姓名</label>\\n        <input id={nameId} type=\\\"text\\\" />\\n      </div>\\n\\n      <div>\\n        <label htmlFor={emailId}>邮箱</label>\\n        <input id={emailId} type=\\\"email\\\" />\\n      </div>\\n\\n      <div>\\n        <label htmlFor={passwordId}>密码</label>\\n        <input id={passwordId} type=\\\"password\\\" />\\n      </div>\\n    </form>\\n  );\\n}\\n```\\n\\n### 与 ARIA 属性结合使用\\n\\n```jsx\\nfunction Accordion() {\\n  const headingId = useId();\\n  const panelId = useId();\\n  const [isExpanded, setIsExpanded] = useState(false);\\n\\n  return (\\n    <div>\\n      <h3>\\n        <button\\n          aria-expanded={isExpanded}\\n          aria-controls={panelId}\\n          id={headingId}\\n          onClick={() => setIsExpanded(!isExpanded)}\\n        >\\n          常见问题\\n        </button>\\n      </h3>\\n\\n      <div id={panelId} aria-labelledby={headingId} role=\\\"region\\\" hidden={!isExpanded}>\\n        这里是常见问题的内容...\\n      </div>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 表单标签和输入框的关联\\n- ARIA 属性（如 aria-labelledby、aria-controls）\\n- 生成唯一的 DOM ID\\n- 客户端和服务器端渲染的一致性\\n- 组件库开发\\n\\n## 15. useInsertionEffect - CSS-in-JS 库的样式注入\\n\\n`useInsertionEffect` 是 React 18 引入的新 Hook，专为 CSS-in-JS 库设计，用于在 DOM 变更之前注入样式，避免布局抖动。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useInsertionEffect } from 'react';\\n\\n// 这是一个简化的 CSS-in-JS 库示例\\nfunction useCssInJs(rule) {\\n  useInsertionEffect(() => {\\n    // 在 DOM 变更之前注入样式\\n    const style = document.createElement('style');\\n    style.textContent = rule;\\n    document.head.appendChild(style);\\n\\n    return () => {\\n      // 清理样式\\n      document.head.removeChild(style);\\n    };\\n  }, [rule]);\\n}\\n\\nfunction StyledComponent() {\\n  // 使用自定义 Hook 注入 CSS\\n  useCssInJs(`\\n    .styled-button {\\n      background-color: #3370ff;\\n      color: white;\\n      padding: 8px 16px;\\n      border-radius: 4px;\\n      border: none;\\n      cursor: pointer;\\n    }\\n\\n    .styled-button:hover {\\n      background-color: #2350cc;\\n    }\\n  `);\\n\\n  return <button className=\\\"styled-button\\\">样式化按钮</button>;\\n}\\n```\\n\\n### 与其他 Effect Hooks 的区别\\n\\n`useInsertionEffect` 的执行时机比 `useLayoutEffect` 更早，比 `useEffect` 更早：\\n\\n1. `useInsertionEffect`: DOM 变更之前执行\\n2. `useLayoutEffect`: DOM 变更之后、浏览器绘制之前执行\\n3. `useEffect`: DOM 变更之后、浏览器绘制之后执行\\n\\n### 注意事项\\n\\n- 这个 Hook 主要面向 CSS-in-JS 库的作者，而不是普通应用开发者\\n- 在 `useInsertionEffect` 内部无法访问 refs，因为 DOM 还没有更新\\n- 不应该在这个 Hook 中更新状态，因为它会在所有 DOM 变更之前运行\\n\\n### 应用场景\\n\\n- CSS-in-JS 库的实现（如 styled-components、emotion）\\n- 动态样式注入\\n- 避免样式注入导致的布局抖动\\n- 性能优化，特别是在并发渲染模式下\\n\\n## 16. useOptimistic - 乐观 UI 更新\\n\\n`useOptimistic` 是 React 的实验性 Hook，用于实现乐观更新，即在服务器响应之前立即更新 UI，提升用户体验。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useOptimistic, useState } from 'react';\\n\\nfunction TodoList() {\\n  const [todos, setTodos] = useState([\\n    { id: 1, text: '学习 React', completed: false },\\n    { id: 2, text: '学习 Hooks', completed: false },\\n  ]);\\n\\n  // 使用 useOptimistic 创建乐观状态\\n  const [optimisticTodos, addOptimisticTodo] = useOptimistic(todos, (currentTodos, newTodo) => [\\n    ...currentTodos,\\n    newTodo,\\n  ]);\\n\\n  const addTodo = async (text) => {\\n    // 创建新待办事项对象\\n    const newTodo = { id: Date.now(), text, completed: false };\\n\\n    // 乐观地更新 UI\\n    addOptimisticTodo(newTodo);\\n\\n    try {\\n      // 发送请求到服务器\\n      const response = await fetch('/api/todos', {\\n        method: 'POST',\\n        headers: { 'Content-Type': 'application/json' },\\n        body: JSON.stringify(newTodo),\\n      });\\n\\n      if (!response.ok) throw new Error('添加待办事项失败');\\n\\n      // 服务器响应成功后，更新实际状态\\n      const savedTodo = await response.json();\\n      setTodos([...todos, savedTodo]);\\n    } catch (error) {\\n      // 处理错误，可能需要回滚乐观更新\\n      console.error(error);\\n      // 这里可以显示错误通知\\n    }\\n  };\\n\\n  return (\\n    <div>\\n      <h2>待办事项列表</h2>\\n      <ul>\\n        {optimisticTodos.map((todo) => (\\n          <li key={todo.id}>{todo.text}</li>\\n        ))}\\n      </ul>\\n      <button onClick={() => addTodo('新待办事项')}>添加待办事项</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 与表单提交结合使用\\n\\n```jsx\\nfunction CommentForm({ postId }) {\\n  const [comments, setComments] = useState([]);\\n  const [optimisticComments, addOptimisticComment] = useOptimistic(comments, (currentComments, newComment) => [\\n    ...currentComments,\\n    newComment,\\n  ]);\\n\\n  const handleSubmit = async (event) => {\\n    event.preventDefault();\\n    const formData = new FormData(event.target);\\n    const commentText = formData.get('comment');\\n\\n    // 创建乐观评论\\n    const optimisticComment = {\\n      id: `temp-${Date.now()}`,\\n      text: commentText,\\n      author: '当前用户',\\n      createdAt: new Date().toISOString(),\\n      pending: true,\\n    };\\n\\n    // 乐观更新 UI\\n    addOptimisticComment(optimisticComment);\\n\\n    // 重置表单\\n    event.target.reset();\\n\\n    try {\\n      // 发送到服务器\\n      const response = await fetch(`/api/posts/${postId}/comments`, {\\n        method: 'POST',\\n        body: formData,\\n      });\\n\\n      if (!response.ok) throw new Error('提交评论失败');\\n\\n      // 获取实际保存的评论\\n      const savedComment = await response.json();\\n      setComments([...comments, savedComment]);\\n    } catch (error) {\\n      console.error(error);\\n      // 显示错误通知\\n    }\\n  };\\n\\n  return (\\n    <div>\\n      <h3>评论</h3>\\n      <ul className=\\\"comments-list\\\">\\n        {optimisticComments.map((comment) => (\\n          <li key={comment.id} className={comment.pending ? 'pending' : ''}>\\n            <strong>{comment.author}</strong>: {comment.text}\\n          </li>\\n        ))}\\n      </ul>\\n\\n      <form onSubmit={handleSubmit}>\\n        <textarea name=\\\"comment\\\" required placeholder=\\\"写下你的评论...\\\" />\\n        <button type=\\\"submit\\\">提交评论</button>\\n      </form>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 社交媒体的点赞、评论功能\\n- 表单提交后的即时反馈\\n- 购物车添加/删除商品\\n- 任务管理应用中的任务状态更新\\n- 任何需要提高感知性能的用户交互\\n\\n## 17. useActionState - 处理异步操作状态\\n\\n`useActionState` 是 React 的实验性 Hook，用于处理异步操作的状态管理，简化加载、错误和成功状态的处理。\\n\\n### 基本用法\\n\\n```jsx\\nimport React, { useActionState } from 'react';\\n\\nfunction UserProfile({ userId }) {\\n  // 定义异步操作函数\\n  async function fetchUserData(prevState, userId) {\\n    const response = await fetch(`/api/users/${userId}`);\\n    if (!response.ok) throw new Error('获取用户数据失败');\\n    return await response.json();\\n  }\\n\\n  // 使用 useActionState 管理异步操作状态\\n  const [userData, dispatch, { status, error }] = useActionState(fetchUserData, null);\\n\\n  // 组件挂载时获取用户数据\\n  React.useEffect(() => {\\n    dispatch(userId);\\n  }, [userId, dispatch]);\\n\\n  // 根据状态渲染不同内容\\n  if (status === 'pending') {\\n    return <div>加载中...</div>;\\n  }\\n\\n  if (status === 'error') {\\n    return <div>错误: {error.message}</div>;\\n  }\\n\\n  if (!userData) {\\n    return <div>没有用户数据</div>;\\n  }\\n\\n  return (\\n    <div className=\\\"user-profile\\\">\\n      <h2>{userData.name}</h2>\\n      <p>邮箱: {userData.email}</p>\\n      <p>角色: {userData.role}</p>\\n      <button onClick={() => dispatch(userId)}>刷新</button>\\n    </div>\\n  );\\n}\\n```\\n\\n### 表单提交示例\\n\\n```jsx\\nfunction ContactForm() {\\n  // 定义表单提交函数\\n  async function submitForm(prevState, formData) {\\n    const response = await fetch('/api/contact', {\\n      method: 'POST',\\n      body: formData,\\n    });\\n\\n    if (!response.ok) {\\n      const errorData = await response.json();\\n      throw new Error(errorData.message || '提交表单失败');\\n    }\\n\\n    return { success: true, message: '消息已发送！' };\\n  }\\n\\n  // 使用 useActionState 管理表单提交状态\\n  const [result, submitAction, { status, error }] = useActionState(submitForm, null);\\n\\n  const handleSubmit = (event) => {\\n    event.preventDefault();\\n    const formData = new FormData(event.target);\\n    submitAction(formData);\\n  };\\n\\n  return (\\n    <div className=\\\"contact-form\\\">\\n      <h2>联系我们</h2>\\n\\n      {status === 'success' && <div className=\\\"success-message\\\">{result.message}</div>}\\n\\n      {status === 'error' && <div className=\\\"error-message\\\">{error.message}</div>}\\n\\n      <form onSubmit={handleSubmit}>\\n        <div className=\\\"form-group\\\">\\n          <label htmlFor=\\\"name\\\">姓名</label>\\n          <input type=\\\"text\\\" id=\\\"name\\\" name=\\\"name\\\" required />\\n        </div>\\n\\n        <div className=\\\"form-group\\\">\\n          <label htmlFor=\\\"email\\\">邮箱</label>\\n          <input type=\\\"email\\\" id=\\\"email\\\" name=\\\"email\\\" required />\\n        </div>\\n\\n        <div className=\\\"form-group\\\">\\n          <label htmlFor=\\\"message\\\">消息</label>\\n          <textarea id=\\\"message\\\" name=\\\"message\\\" required></textarea>\\n        </div>\\n\\n        <button type=\\\"submit\\\" disabled={status === 'pending'}>\\n          {status === 'pending' ? '提交中...' : '发送消息'}\\n        </button>\\n      </form>\\n    </div>\\n  );\\n}\\n```\\n\\n### 与 useOptimistic 结合使用\\n\\n```jsx\\nfunction TodoApp() {\\n  const [todos, setTodos] = useState([]);\\n\\n  // 乐观更新\\n  const [optimisticTodos, addOptimisticTodo] = useOptimistic(todos, (currentTodos, newTodo) => [\\n    ...currentTodos,\\n    newTodo,\\n  ]);\\n\\n  // 异步操作状态管理\\n  async function addTodoAction(prevState, text) {\\n    const response = await fetch('/api/todos', {\\n      method: 'POST',\\n      headers: { 'Content-Type': 'application/json' },\\n      body: JSON.stringify({ text, completed: false }),\\n    });\\n\\n    if (!response.ok) throw new Error('添加待办事项失败');\\n    const newTodo = await response.json();\\n\\n    // 更新实际状态\\n    setTodos((currentTodos) => [...currentTodos, newTodo]);\\n    return newTodo;\\n  }\\n\\n  const [, addTodo, { status, error }] = useActionState(addTodoAction, null);\\n\\n  const handleAddTodo = (text) => {\\n    // 创建乐观待办事项\\n    const optimisticTodo = {\\n      id: `temp-${Date.now()}`,\\n      text,\\n      completed: false,\\n      pending: true,\\n    };\\n\\n    // 乐观更新 UI\\n    addOptimisticTodo(optimisticTodo);\\n\\n    // 执行实际操作\\n    addTodo(text);\\n  };\\n\\n  return (\\n    <div>\\n      <h2>待办事项</h2>\\n      {error && <div className=\\\"error\\\">{error.message}</div>}\\n\\n      <ul>\\n        {optimisticTodos.map((todo) => (\\n          <li key={todo.id} className={todo.pending ? 'pending' : ''}>\\n            {todo.text}\\n          </li>\\n        ))}\\n      </ul>\\n\\n      <form\\n        onSubmit={(e) => {\\n          e.preventDefault();\\n          const text = e.target.elements.todo.value;\\n          handleAddTodo(text);\\n          e.target.reset();\\n        }}\\n      >\\n        <input name=\\\"todo\\\" placeholder=\\\"添加新待办事项...\\\" />\\n        <button type=\\\"submit\\\" disabled={status === 'pending'}>\\n          {status === 'pending' ? '添加中...' : '添加'}\\n        </button>\\n      </form>\\n    </div>\\n  );\\n}\\n```\\n\\n### 应用场景\\n\\n- 表单提交和处理\\n- 数据获取和刷新\\n- 用户认证流程\\n- 任何需要跟踪加载、错误和成功状态的异步操作\\n- 与乐观更新结合使用的复杂交互\\n\\n## 18. 自定义 Hooks - 封装和复用逻辑\\n\\n自定义 Hooks 是一种复用状态逻辑的方式，它不复用状态本身，而是复用状态逻辑。\\n\\n### 创建自定义 Hook\\n\\n```jsx\\nimport { useEffect, useState } from 'react';\\n\\n// 自定义 Hook 用于获取窗口尺寸\\nfunction useWindowSize() {\\n  const [windowSize, setWindowSize] = useState({\\n    width: window.innerWidth,\\n    height: window.innerHeight,\\n  });\\n\\n  useEffect(() => {\\n    // 处理窗口大小变化\\n    const handleResize = () => {\\n      setWindowSize({\\n        width: window.innerWidth,\\n        height: window.innerHeight,\\n      });\\n    };\\n\\n    // 添加事件监听\\n    window.addEventListener('resize', handleResize);\\n\\n    // 清除事件监听\\n    return () => {\\n      window.removeEventListener('resize', handleResize);\\n    };\\n  }, []); // 空依赖数组，只在挂载和卸载时执行\\n\\n  return windowSize;\\n}\\n\\n// 使用自定义 Hook\\nfunction ResponsiveComponent() {\\n  const { width, height } = useWindowSize();\\n\\n  return (\\n    <div>\\n      <p>窗口宽度: {width}px</p>\\n      <p>窗口高度: {height}px</p>\\n      {width < 768 ? <MobileView /> : <DesktopView />}\\n    </div>\\n  );\\n}\\n```\\n\\n### 自定义 Hook 示例：表单处理\\n\\n```jsx\\nfunction useForm(initialValues = {}) {\\n  const [values, setValues] = useState(initialValues);\\n  const [errors, setErrors] = useState({});\\n  const [touched, setTouched] = useState({});\\n\\n  const handleChange = (e) => {\\n    const { name, value } = e.target;\\n    setValues({ ...values, [name]: value });\\n  };\\n\\n  const handleBlur = (e) => {\\n    const { name } = e.target;\\n    setTouched({ ...touched, [name]: true });\\n  };\\n\\n  const reset = () => {\\n    setValues(initialValues);\\n    setErrors({});\\n    setTouched({});\\n  };\\n\\n  return {\\n    values,\\n    errors,\\n    touched,\\n    handleChange,\\n    handleBlur,\\n    reset,\\n  };\\n}\\n\\n// 使用自定义 Hook\\nfunction SignupForm() {\\n  const { values, handleChange, handleBlur, reset } = useForm({\\n    username: '',\\n    email: '',\\n    password: '',\\n  });\\n\\n  const handleSubmit = (e) => {\\n    e.preventDefault();\\n    // 提交表单逻辑\\n    console.log('表单提交', values);\\n    reset();\\n  };\\n\\n  return (\\n    <form onSubmit={handleSubmit}>\\n      <div>\\n        <label>用户名</label>\\n        <input type=\\\"text\\\" name=\\\"username\\\" value={values.username} onChange={handleChange} onBlur={handleBlur} />\\n      </div>\\n      {/* 其他表单字段 */}\\n      <button type=\\\"submit\\\">注册</button>\\n    </form>\\n  );\\n}\\n```\\n\\n### 自定义 Hook 示例：数据获取\\n\\n```jsx\\nfunction useFetch(url) {\\n  const [data, setData] = useState(null);\\n  const [loading, setLoading] = useState(true);\\n  const [error, setError] = useState(null);\\n\\n  useEffect(() => {\\n    let isMounted = true;\\n\\n    const fetchData = async () => {\\n      try {\\n        setLoading(true);\\n        setError(null);\\n\\n        const response = await fetch(url);\\n        if (!response.ok) throw new Error('请求失败');\\n\\n        const result = await response.json();\\n        if (isMounted) {\\n          setData(result);\\n        }\\n      } catch (err) {\\n        if (isMounted) {\\n          setError(err.message);\\n        }\\n      } finally {\\n        if (isMounted) {\\n          setLoading(false);\\n        }\\n      }\\n    };\\n\\n    fetchData();\\n\\n    return () => {\\n      isMounted = false;\\n    };\\n  }, [url]);\\n\\n  return { data, loading, error };\\n}\\n\\n// 使用自定义 Hook\\nfunction UserList() {\\n  const { data, loading, error } = useFetch('https://api.example.com/users');\\n\\n  if (loading) return <div>加载中...</div>;\\n  if (error) return <div>错误: {error}</div>;\\n  if (!data) return null;\\n\\n  return (\\n    <ul>\\n      {data.map((user) => (\\n        <li key={user.id}>{user.name}</li>\\n      ))}\\n    </ul>\\n  );\\n}\\n```\\n\\n## 19. Hooks 使用规则和最佳实践\\n\\n### Hooks 使用规则\\n\\n1. **只在最顶层使用 Hooks**\\n\\n   - 不要在循环、条件或嵌套函数中调用 Hooks\\n   - 确保 Hooks 在每次渲染时都以相同的顺序被调用\\n\\n2. **只在 React 函数组件和自定义 Hooks 中调用 Hooks**\\n   - 不要在普通的 JavaScript 函数中调用 Hooks\\n   - 不要在类组件中调用 Hooks\\n\\n### 最佳实践\\n\\n1. **合理拆分 Hooks**\\n\\n   - 将相关的逻辑封装到自定义 Hooks 中\\n   - 保持每个 Hook 的职责单一\\n\\n2. **正确管理依赖项**\\n\\n   - 在 `useEffect`、`useCallback` 和 `useMemo` 的依赖数组中包含所有使用的变量\\n   - 使用 ESLint 插件 `eslint-plugin-react-hooks` 检查依赖项\\n\\n3. **避免过度优化**\\n\\n   - 不要过早使用 `useMemo` 和 `useCallback`\\n   - 只在性能确实有问题时才进行优化\\n\\n4. **合理使用 Context**\\n\\n   - 将 Context 拆分为多个小的 Context，避免不必要的重渲染\\n   - 使用 `useMemo` 记忆化 Context 值\\n\\n5. **处理异步操作**\\n\\n   - 在 `useEffect` 中处理异步操作时，注意组件卸载后的状态更新\\n   - 使用清除函数防止内存泄漏\\n\\n6. **测试 Hooks**\\n   - 使用 `@testing-library/react-hooks` 测试自定义 Hooks\\n   - 编写单元测试确保 Hooks 行为符合预期\\n\\n## 总结\\n\\nReact Hooks 彻底改变了 React 组件的编写方式，使函数组件拥有了类组件的所有能力，同时代码更简洁、更易于测试和复用。通过合理使用内置 Hooks 和创建自定义 Hooks，我们可以更好地组织和复用组件逻辑，提高开发效率和代码质量。\\n\\n希望本文能帮助你全面了解 React Hooks，并在实际项目中灵活运用。随着 React 的不断发展，Hooks 将继续成为 React 开发的核心部分，掌握它们对于每一位 React 开发者来说都至关重要。\\n\",\"wordCount\":3626},{\"id\":\"cdf2fdd3\",\"title\":\"SSO 及其具体流程\",\"date\":\"2024-03-26\",\"tags\":[\"SSO\",\"业务场景\"],\"fileName\":\"SSO 及其具体流程.md\",\"content\":\"\\n## 前言\\n\\n在现代企业应用中，用户经常需要访问多个相关但独立的系统。如何避免用户重复登录，同时保证系统安全性？单点登录（Single Sign-On，SSO）提供了完美的解决方案。本文将深入探讨 SSO 的原理、实现方式和最佳实践。\\n\\n## 什么是单点登录\\n\\n单点登录是一种身份验证机制，允许用户使用单一的凭据（如用户名和密码）访问多个相关的系统。一次登录，即可访问所有已授权的应用，无需重复认证。\\n\\n## SSO 的实现方式\\n\\n### 1. 基于 Cookie 的同域名 SSO\\n\\n适用于同一主域名下的多个子域名系统，例如：\\n\\n- app1.example.com\\n- app2.example.com\\n- app3.example.com\\n\\n```typescript\\n// Cookie 配置示例\\nconst cookieConfig = {\\n  domain: '.example.com', // 注意这里的点号\\n  path: '/',\\n  httpOnly: true,\\n  secure: true,\\n};\\n```\\n\\n### 2. 基于 Token 的跨域名 SSO\\n\\n适用于不同域名的系统之间的单点登录：\\n\\n```typescript\\ninterface TokenPayload {\\n  userId: string;\\n  username: string;\\n  exp: number; // 过期时间\\n  iat: number; // 签发时间\\n  applications: string[]; // 允许访问的应用列表\\n}\\n```\\n\\n## SSO 登录流程详解\\n\\n### 1. 基本流程\\n\\n1. 用户访问应用系统\\n2. 应用系统检查是否已登录\\n3. 未登录则重定向到 SSO 认证中心\\n4. 用户在 SSO 认证中心登录\\n5. SSO 认证中心验证身份并生成 Token\\n6. 重定向回应用系统，并携带 Token\\n7. 应用系统验证 Token 并创建本地会话\\n\\n### 2. 代码实现\\n\\n#### 前端实现\\n\\n```typescript\\nclass SSOClient {\\n  private ssoServerUrl: string;\\n  private clientId: string;\\n\\n  constructor(config: SSOConfig) {\\n    this.ssoServerUrl = config.ssoServerUrl;\\n    this.clientId = config.clientId;\\n  }\\n\\n  async checkAuthentication() {\\n    const token = localStorage.getItem('sso_token');\\n\\n    if (!token) {\\n      this.redirectToLogin();\\n      return;\\n    }\\n\\n    try {\\n      await this.validateToken(token);\\n    } catch {\\n      this.redirectToLogin();\\n    }\\n  }\\n\\n  private redirectToLogin() {\\n    const currentUrl = encodeURIComponent(window.location.href);\\n    window.location.href = `${this.ssoServerUrl}/login?redirect_uri=${currentUrl}&client_id=${this.clientId}`;\\n  }\\n}\\n```\\n\\n#### 后端实现\\n\\n```typescript\\nclass SSOServer {\\n  async login(req: Request, res: Response) {\\n    const { username, password } = req.body;\\n\\n    // 验证用户\\n    const user = await this.validateUser(username, password);\\n\\n    if (user) {\\n      // 生成 token\\n      const token = jwt.sign({ userId: user.id, username: user.username }, SECRET_KEY, { expiresIn: '1h' });\\n\\n      // 重定向回原系统\\n      const { redirect_uri } = req.query;\\n      res.redirect(`${redirect_uri}?token=${token}`);\\n    }\\n  }\\n\\n  async validateToken(req: Request, res: Response) {\\n    const { token } = req.query;\\n\\n    try {\\n      const decoded = jwt.verify(token, SECRET_KEY);\\n      res.json({ valid: true, user: decoded });\\n    } catch {\\n      res.json({ valid: false });\\n    }\\n  }\\n}\\n```\\n\\n## 安全性考虑\\n\\n### 1. Token 安全\\n\\n- 使用 JWT 等标准格式\\n- 设置合理的过期时间\\n- 使用 HTTPS 传输\\n- 实现 Token 撤销机制\\n\\n### 2. CSRF 防护\\n\\n```typescript\\n// 添加 CSRF Token\\nconst csrfToken = generateCSRFToken();\\nres.cookie('XSRF-TOKEN', csrfToken, {\\n  httpOnly: true,\\n  secure: true,\\n  sameSite: 'strict',\\n});\\n```\\n\\n### 3. 单点登出\\n\\n```typescript\\nclass SingleLogout {\\n  async logout() {\\n    // 清除本地 token\\n    localStorage.removeItem('sso_token');\\n\\n    // 通知 SSO 服务器\\n    await fetch(`${ssoServerUrl}/logout`, {\\n      credentials: 'include',\\n    });\\n\\n    // 通知所有子系统\\n    this.notifyApplications();\\n\\n    // 重定向到登出页面\\n    window.location.href = logoutPage;\\n  }\\n\\n  private async notifyApplications() {\\n    const apps = this.getRegisteredApps();\\n    await Promise.all(\\n      apps.map((app) =>\\n        fetch(`${app.url}/logout`, {\\n          method: 'POST',\\n          credentials: 'include',\\n        })\\n      )\\n    );\\n  }\\n}\\n```\\n\\n## 性能优化\\n\\n### 1. 缓存策略\\n\\n```typescript\\nclass TokenCache {\\n  private cache: Map<string, TokenInfo>;\\n  private readonly maxAge: number;\\n\\n  constructor(maxAge: number = 3600000) {\\n    // 1小时\\n    this.cache = new Map();\\n    this.maxAge = maxAge;\\n    this.startCleanup();\\n  }\\n\\n  set(token: string, info: TokenInfo) {\\n    this.cache.set(token, {\\n      ...info,\\n      timestamp: Date.now(),\\n    });\\n  }\\n\\n  get(token: string): TokenInfo | null {\\n    const info = this.cache.get(token);\\n    if (!info) return null;\\n\\n    if (Date.now() - info.timestamp > this.maxAge) {\\n      this.cache.delete(token);\\n      return null;\\n    }\\n\\n    return info;\\n  }\\n\\n  private startCleanup() {\\n    setInterval(() => {\\n      const now = Date.now();\\n      for (const [token, info] of this.cache.entries()) {\\n        if (now - info.timestamp > this.maxAge) {\\n          this.cache.delete(token);\\n        }\\n      }\\n    }, this.maxAge);\\n  }\\n}\\n```\\n\\n### 2. 监控和日志\\n\\n```typescript\\nclass SSOMonitoring {\\n  logLoginAttempt(userId: string, success: boolean) {\\n    logger.info('Login attempt', {\\n      userId,\\n      success,\\n      timestamp: new Date(),\\n      ip: request.ip,\\n    });\\n  }\\n\\n  trackTokenUsage(token: string) {\\n    metrics.increment('token.usage', {\\n      token: hashToken(token),\\n    });\\n  }\\n\\n  reportError(error: Error) {\\n    errorTracking.capture(error);\\n  }\\n}\\n```\\n\\n## 最佳实践\\n\\n1. **使用标准协议**\\n\\n   - OAuth 2.0\\n   - SAML 2.0\\n   - OpenID Connect\\n\\n2. **错误处理**\\n\\n   - SSO 服务器宕机的降级策略\\n   - Token 过期的优雅处理\\n   - 网络异常的重试机制\\n\\n3. **用户体验**\\n   - 无感知的 Token 续期\\n   - 友好的错误提示\\n   - 平滑的登录/登出过程\\n\\n## 总结\\n\\n单点登录（SSO）是现代企业应用不可或缺的认证机制。通过合理的实现和配置，可以：\\n\\n1. 提升用户体验\\n2. 增强系统安全性\\n3. 简化认证管理\\n4. 降低维护成本\\n\\n在实施 SSO 时，需要注意：\\n\\n- 选择合适的实现方式\\n- 重视安全性考虑\\n- 优化性能\\n- 做好监控和日志\\n- 遵循最佳实践\\n\\n通过本文的详细讲解，相信你已经对 SSO 有了深入的理解，可以在实际项目中进行合理的实现和应用。\\n\",\"wordCount\":598},{\"id\":\"04989b2a\",\"title\":\"Vue 核心原理深度解析\",\"date\":\"2024-03-16\",\"tags\":[\"vue\"],\"fileName\":\"Vue 核心原理深度解析.md\",\"content\":\"\\n## 一、响应式系统（Reactivity）\\n\\n### 1. Vue 2.x 的响应式实现\\n\\nVue 2 使用 `Object.defineProperty` 实现数据响应式：\\n\\n```javascript\\nfunction observe(obj) {\\n  if (!obj || typeof obj !== 'object') return;\\n\\n  Object.keys(obj).forEach((key) => {\\n    let value = obj[key];\\n    let dep = new Dep();\\n\\n    Object.defineProperty(obj, key, {\\n      enumerable: true,\\n      configurable: true,\\n      get() {\\n        // 依赖收集\\n        if (Dep.target) {\\n          dep.depend();\\n        }\\n        return value;\\n      },\\n      set(newValue) {\\n        if (value === newValue) return;\\n        value = newValue;\\n        // 触发更新\\n        dep.notify();\\n      },\\n    });\\n\\n    // 递归观察子属性\\n    observe(value);\\n  });\\n}\\n\\n// 依赖收集器\\nclass Dep {\\n  constructor() {\\n    this.subscribers = new Set();\\n  }\\n\\n  depend() {\\n    if (Dep.target) {\\n      this.subscribers.add(Dep.target);\\n    }\\n  }\\n\\n  notify() {\\n    this.subscribers.forEach((sub) => sub.update());\\n  }\\n}\\n```\\n\\n### 2. Vue 3.x 的响应式实现\\n\\nVue 3 使用 Proxy 实现数据响应式：\\n\\n```javascript\\nfunction reactive(target) {\\n  if (!isObject(target)) return target;\\n\\n  const handler = {\\n    get(target, key, receiver) {\\n      const result = Reflect.get(target, key, receiver);\\n      // 依赖收集\\n      track(target, key);\\n      return isObject(result) ? reactive(result) : result;\\n    },\\n\\n    set(target, key, value, receiver) {\\n      const oldValue = target[key];\\n      const result = Reflect.set(target, key, value, receiver);\\n      if (oldValue !== value) {\\n        // 触发更新\\n        trigger(target, key);\\n      }\\n      return result;\\n    },\\n  };\\n\\n  return new Proxy(target, handler);\\n}\\n```\\n\\nVue 3 的优势：\\n\\n- 可以监听数组变化\\n- 可以监听对象属性的添加和删除\\n- 支持 Map、Set、WeakMap、WeakSet\\n- 性能更好，不需要递归遍历\\n\\n## 二、虚拟 DOM（Virtual DOM）\\n\\n### 1. 虚拟 DOM 的结构\\n\\n```javascript\\nconst vnode = {\\n  type: 'div',\\n  props: {\\n    id: 'app',\\n    class: 'container',\\n  },\\n  children: [\\n    {\\n      type: 'h1',\\n      props: null,\\n      children: ['Hello Vue'],\\n    },\\n  ],\\n};\\n```\\n\\n### 2. Diff 算法实现\\n\\n```javascript\\nfunction patch(n1, n2) {\\n  if (n1.type !== n2.type) {\\n    // 节点类型不同，直接替换\\n    replaceNode(n1, n2);\\n    return;\\n  }\\n\\n  // 更新属性\\n  const el = (n2.el = n1.el);\\n  const oldProps = n1.props || {};\\n  const newProps = n2.props || {};\\n\\n  // 更新新属性\\n  for (const key in newProps) {\\n    if (oldProps[key] !== newProps[key]) {\\n      patchProp(el, key, oldProps[key], newProps[key]);\\n    }\\n  }\\n\\n  // 删除旧属性\\n  for (const key in oldProps) {\\n    if (!(key in newProps)) {\\n      patchProp(el, key, oldProps[key], null);\\n    }\\n  }\\n\\n  // 更新子节点\\n  patchChildren(n1, n2, el);\\n}\\n```\\n\\n## 三、编译器（Compiler）\\n\\n### 1. 模板编译过程\\n\\n```javascript\\n// 模板\\n<div id=\\\"app\\\">\\n  <p>{{ message }}</p>\\n</div>;\\n\\n// 编译后的渲染函数\\nfunction render() {\\n  return h('div', { id: 'app' }, [h('p', null, ctx.message)]);\\n}\\n```\\n\\n### 2. 编译优化\\n\\nVue 3 的编译优化：\\n\\n```javascript\\n// 模板\\n<div>\\n  <p>静态内容</p>\\n  <p>{{ dynamic }}</p>\\n</div>;\\n\\n// 编译后（带有 PatchFlag）\\nconst hoisted = h('p', null, '静态内容');\\n\\nfunction render() {\\n  return h('div', null, [hoisted, h('p', null, ctx.dynamic, 1 /* TEXT */)]);\\n}\\n```\\n\\n## 四、组件化机制\\n\\n### 1. 组件的生命周期\\n\\n```javascript\\nconst MyComponent = {\\n  data() {\\n    return { count: 0 };\\n  },\\n\\n  beforeCreate() {\\n    // 实例初始化之后，数据观测之前\\n  },\\n\\n  created() {\\n    // 数据观测、事件配置完成\\n  },\\n\\n  beforeMount() {\\n    // 挂载开始之前\\n  },\\n\\n  mounted() {\\n    // 挂载完成\\n  },\\n\\n  beforeUpdate() {\\n    // 数据更新时\\n  },\\n\\n  updated() {\\n    // 更新完成\\n  },\\n\\n  beforeUnmount() {\\n    // 卸载之前\\n  },\\n\\n  unmounted() {\\n    // 卸载完成\\n  },\\n};\\n```\\n\\n### 2. 组件通信\\n\\n```javascript\\n// 父组件\\nconst Parent = {\\n  template: `\\n    <Child \\n      :msg=\\\"message\\\"\\n      @update=\\\"handleUpdate\\\"\\n    />\\n  `,\\n  data() {\\n    return {\\n      message: 'Hello',\\n    };\\n  },\\n  methods: {\\n    handleUpdate(value) {\\n      this.message = value;\\n    },\\n  },\\n};\\n\\n// 子组件\\nconst Child = {\\n  props: ['msg'],\\n  emits: ['update'],\\n  template: `\\n    <div @click=\\\"$emit('update', 'New Message')\\\">\\n      {{ msg }}\\n    </div>\\n  `,\\n};\\n```\\n\\n## 五、Vue 3 的新特性\\n\\n### 1. Composition API\\n\\n```javascript\\nimport { computed, onMounted, ref } from 'vue';\\n\\nexport default {\\n  setup() {\\n    const count = ref(0);\\n    const double = computed(() => count.value * 2);\\n\\n    function increment() {\\n      count.value++;\\n    }\\n\\n    onMounted(() => {\\n      console.log('组件已挂载');\\n    });\\n\\n    return {\\n      count,\\n      double,\\n      increment,\\n    };\\n  },\\n};\\n```\\n\\n### 2. 新的 API 设计\\n\\n```javascript\\n// 创建应用实例\\nconst app = createApp({\\n  // 根组件选项\\n});\\n\\n// 注册全局组件\\napp.component('my-component', {\\n  // 组件选项\\n});\\n\\n// 注册全局指令\\napp.directive('focus', {\\n  mounted(el) {\\n    el.focus();\\n  },\\n});\\n\\n// 挂载应用\\napp.mount('#app');\\n```\\n\\n## 六、性能优化\\n\\n### 1. 编译时优化\\n\\nVue 3 在编译时引入了多项优化策略，显著提升了应用性能：\\n\\n#### 1.1 静态树提升（Static Tree Hoisting）\\n\\n静态树提升是指将永远不会改变的静态子树提升到渲染函数之外，使其只被创建一次，后续的重新渲染直接复用。\\n\\n```javascript\\n// 模板\\n<div>\\n  <div class=\\\"header\\\">\\n    <h1>标题</h1>\\n    <p>静态内容</p>\\n  </div>\\n  <div class=\\\"content\\\">{{ message }}</div>\\n</div>;\\n\\n// 编译后\\nconst hoisted = createVNode('div', { class: 'header' }, [\\n  createVNode('h1', null, '标题'),\\n  createVNode('p', null, '静态内容'),\\n]);\\n\\nfunction render() {\\n  return createVNode('div', null, [\\n    hoisted, // 直接复用静态子树\\n    createVNode('div', { class: 'content' }, ctx.message),\\n  ]);\\n}\\n```\\n\\n这种优化：\\n\\n- 减少了每次渲染时的 VNode 创建开销\\n- 降低了内存占用\\n- 提高了渲染性能\\n\\n#### 1.2 静态属性提升\\n\\n与静态树提升类似，静态属性也会被提升到渲染函数之外。\\n\\n```javascript\\n// 模板\\n<div>\\n  <div class=\\\"card\\\" data-type=\\\"info\\\" :title=\\\"title\\\">\\n    {{ content }}\\n  </div>\\n</div>\\n\\n// 编译后\\nconst hoistedProps = {\\n  class: \\\"card\\\",\\n  \\\"data-type\\\": \\\"info\\\"\\n}\\n\\nfunction render() {\\n  return createVNode(\\\"div\\\", null, [\\n    createVNode(\\\"div\\\", {\\n      ...hoistedProps,  // 复用静态属性\\n      title: ctx.title\\n    }, ctx.content)\\n  ])\\n}\\n```\\n\\n优势：\\n\\n- 避免重复创建静态属性对象\\n- 减少内存分配\\n- 提高属性比对效率\\n\\n#### 1.3 Patch Flag 标记动态节点\\n\\nPatch Flag 是 Vue 3 引入的一个重要优化，它会在编译时标记动态内容的类型，运行时只需要关注带有标记的内容。\\n\\n```javascript\\n// 模板\\n<div>\\n  <div>{{ text }}</div>\\n  <div :class=\\\"cls\\\"></div>\\n  <div :id=\\\"id\\\">{{ text }}</div>\\n</div>\\n\\n// 编译后\\nfunction render() {\\n  return createVNode(\\\"div\\\", null, [\\n    createVNode(\\\"div\\\", null, ctx.text, 1 /* TEXT */),\\n    createVNode(\\\"div\\\", { class: ctx.cls }, null, 2 /* CLASS */),\\n    createVNode(\\\"div\\\", { id: ctx.id }, ctx.text, 3 /* PROPS + TEXT */)\\n  ])\\n}\\n```\\n\\nPatch Flag 类型：\\n\\n- TEXT = 1: 文本内容是动态的\\n- CLASS = 2: class 是动态的\\n- PROPS = 4: 属性是动态的\\n- STYLE = 8: style 是动态的\\n- 等等...\\n\\n优势：\\n\\n- 精确定位需要更新的内容\\n- 跳过静态内容的比对\\n- 提高 diff 效率\\n\\n#### 1.4 Block Tree 优化更新性能\\n\\nBlock Tree 是 Vue 3 中的一个更高层次的优化，它将模板基于动态节点进行分块。\\n\\n```javascript\\n// 模板\\n<div>\\n  <div>静态内容</div>\\n  <div v-if=\\\"show\\\">\\n    <div>{{ dynamic }}</div>\\n  </div>\\n</div>;\\n\\n// 编译后（简化版）\\nfunction render() {\\n  return createBlock('div', null, [\\n    createVNode('div', null, '静态内容'),\\n    (openBlock(),\\n    createBlock(Fragment, null, [\\n      ctx.show\\n        ? createBlock('div', null, [createVNode('div', null, ctx.dynamic, 1 /* TEXT */)])\\n        : createCommentVNode('v-if'),\\n    ])),\\n  ]);\\n}\\n```\\n\\nBlock Tree 的工作原理：\\n\\n1. 将模板分割成不同的 block\\n2. 每个 block 跟踪其内部的动态节点\\n3. 更新时只需要遍历 block 中的动态节点\\n\\n优势：\\n\\n- 减少虚拟 DOM 树的遍历范围\\n- 提高大型应用的更新性能\\n- 更精确的更新追踪\\n\\n这些编译时优化共同作用，使得 Vue 3 相比 Vue 2：\\n\\n- 初始渲染速度提升约 40%\\n- 更新性能提升约 260%\\n- 内存使用减少约 40%\\n\\n在实际开发中，我们可以：\\n\\n1. 尽可能使用静态内容\\n2. 合理划分动态和静态内容\\n3. 利用 v-once 和 v-memo 等指令进一步优化\\n4. 关注编译器警告，避免反优化\\n\\n通过理解这些优化策略，我们可以编写出更高性能的 Vue 应用。\\n\\n### 2. 运行时优化\\n\\n```javascript\\n// 1. 使用 v-show 代替频繁切换的 v-if\\n<template>\\n  <div v-show=\\\"visible\\\">内容</div>\\n</template>\\n\\n// 2. 使用 computed 缓存计算结果\\nconst double = computed(() => count.value * 2);\\n\\n// 3. 使用 v-once 处理静态内容\\n<div v-once>这个内容永远不会改变</div>\\n\\n// 4. 合理使用 v-memo\\n<div v-memo=\\\"[item.id]\\\">\\n  \x3c!-- 只有 item.id 改变时才会更新 --\x3e\\n</div>\\n```\\n\\n## 总结\\n\\nVue 的核心原理包括：\\n\\n1. 响应式系统：追踪数据变化\\n2. 虚拟 DOM：高效更新视图\\n3. 模板编译：优化渲染性能\\n4. 组件化：提高代码复用性和可维护性\\n\\n理解这些原理有助于：\\n\\n- 更好地使用 Vue 框架\\n- 解决开发中遇到的问题\\n- 优化应用性能\\n- 编写更高质量的代码\\n\",\"wordCount\":783},{\"id\":\"eb83e938\",\"title\":\"实现一个简易的 React 调度器\",\"date\":\"2024-03-05\",\"tags\":[\"react\"],\"fileName\":\"实现一个简易的 React 调度器.md\",\"content\":\"\\n## 前言\\n\\nReact 16 引入了全新的调度系统（Scheduler），通过时间分片的方式来处理任务，避免长时间占用主线程。本文将从零实现一个简易版的调度器，帮助理解 React 调度系统的核心原理。\\n\\n## RequestIdleCallback\\n\\n功能：在浏览器的空闲时段内调用传入的回调函数，通常是在一帧（16.6ms）渲染完成后的剩余时间执行，以避免阻塞主线程上的重要工作（如动画和用户交互）。\\n\\n### 使用示例\\n\\n```javascript\\nrequestIdleCallback((deadline) => {\\n  // deadline.timeRemaining() 获取当前帧的剩余时间\\n  // deadline.didTimeout 是否超时\\n  while (deadline.timeRemaining() > 0) {\\n    // 执行任务\\n  }\\n});\\n```\\n\\n## MessageChannel\\n\\n功能：设计之初是用于提供了一个双向通信的管道，通过其两个端口（port1 和 port2）实现异步消息传递，可用于在不同的上下文间进行通信。在 react 实现中用于替代 requestIdleCallback。\\n\\n### 为什么选择 MessageChannel\\n\\n1. 更好的兼容性\\n\\n相比于 requestIdleCallback 有更好的兼容性\\n\\n2. 更精确的时间控制\\n\\n- setTimeout 和 setInterval 有最小延迟时间（约 4ms）\\n- 在后台标签页时，setTimeout 的最小延迟会被限制到 1000ms\\n- MessageChannel 没有这些限制，可以更精确地控制任务执行时机\\n\\n```js\\n// requestIdleCallback 依赖浏览器的空闲时间，不够灵活\\nrequestIdleCallback((deadline) => {\\n  // 只能在浏览器认为空闲的时候执行\\n  while (deadline.timeRemaining() > 0) {\\n    // 执行任务\\n  }\\n});\\n\\n// MessageChannel 可以自己控制时间切片\\nconst channel = new MessageChannel();\\nchannel.port1.onmessage = () => {\\n  const startTime = performance.now();\\n  while (performance.now() - startTime < 5) {\\n    // 可以精确控制执行时间\\n    performUnitOfWork();\\n  }\\n};\\n```\\n\\n3. 更好的性能\\n\\nMessageChannel 的消息通道机制比 setTimeout 更轻量，开销更小\\n\\n4. 优先级更高\\n\\n宏任务执行时机比 setTimout 优先级更高，可以更快触发\\n\\n5. 更稳定的行为\\n\\n- setTimeout 在不同浏览器中的行为可能不一致\\n- setTimeout 在系统繁忙时可能会被延迟更长时间\\n- MessageChannel 的行为更加可预测和稳定\\n\\n### 使用示例\\n\\n```javascript\\nconst channel = new MessageChannel();\\nconst port = channel.port2;\\n\\nchannel.port1.onmessage = () => {\\n  // 处理任务\\n};\\n\\n// 发送消息触发任务\\nport.postMessage(null);\\n```\\n\\n## Scheduler 核心实现\\n\\n```js\\nconst ImmediatePriority = 1; // 立即执行，点击事件\\nconst UserBlockingPriority = 2; // 用户阻塞，数据请求\\nconst NormalPriority = 3; // 正常，数据渲染\\nconst LowPriority = 4; // 低，数据更新\\nconst IdlePriority = 5; // 空闲，数据预加载\\n\\nfunction getCurrentTime() {\\n  return performance.now(); // 精确到微秒，更加精确\\n}\\n\\nclass SimpleScheduler {\\n  constructor() {\\n    this.taskQueue = [];\\n    // 是否正在执行任务，防止任务多次执行\\n    this.isPerformingTasks = false;\\n    const channel = new MessageChannel();\\n    this.port = channel.port2;\\n    channel.port1.onmessage = this.performWorkUnitDeaLine.bind(this);\\n  }\\n\\n  performWorkUnitDeaLine() {\\n    this.isPerformingTasks = true;\\n    this.workLoop();\\n    this.isPerformingTasks = false;\\n  }\\n\\n  scheduleCallback(priorityLevel, callback) {\\n    const currentTime = getCurrentTime();\\n    let timeout;\\n    switch (priorityLevel) {\\n      case ImmediatePriority:\\n        timeout = -1;\\n        break;\\n      case NormalPriority:\\n        timeout = 5000;\\n        break;\\n      case UserBlockingPriority:\\n        timeout = 250;\\n        break;\\n      case LowPriority:\\n        timeout = 10000;\\n        break;\\n      case IdlePriority:\\n        timeout = 1073741823;\\n        break;\\n      default:\\n        timeout = 5000;\\n        break;\\n    }\\n    const task = {\\n      callback,\\n      priorityLevel,\\n      expirationTime: currentTime + timeout,\\n    };\\n    this.push(this.taskQueue, task);\\n    if (!this.isPerformingTasks) {\\n      this.isPerformingTasks = true;\\n      this.port.postMessage(null);\\n    }\\n  }\\n\\n  workLoop() {\\n    let currentTask = this.peak(this.taskQueue);\\n\\n    while (currentTask) {\\n      let cb = currentTask.callback;\\n      cb?.();\\n      this.pop(this.taskQueue);\\n      currentTask = this.peak(this.taskQueue);\\n    }\\n  }\\n\\n  push(queue, task) {\\n    queue.push(task);\\n    // 优先级排序\\n    queue.sort((a, b) => a.expirationTime - b.expirationTime);\\n  }\\n  peak(queue) {\\n    return queue[0] || null;\\n  }\\n  pop(queue) {\\n    return queue.shift();\\n  }\\n}\\n\\nconst s = new SimpleScheduler();\\n\\n// 代码可以乱写，但是执行顺序是固定的\\n\\ns.scheduleCallback(NormalPriority, () => {\\n  console.log('2');\\n});\\n\\ns.scheduleCallback(UserBlockingPriority, () => {\\n  console.log('1');\\n});\\n\\ns.scheduleCallback(IdlePriority, () => {\\n  console.log('5');\\n});\\n\\ns.scheduleCallback(NormalPriority, () => {\\n  console.log('3');\\n});\\n\\n// 输出：1 2 3 5\\n```\\n\\n## 总结\\n\\n通过实现这个简易的调度器，我们了解了：\\n\\n1. React 调度系统的核心原理\\n2. 时间分片的实现方式\\n3. 任务优先级的管理方法\\n4. 异步调度的具体实现\\n\\n虽然这是一个简化版本，但包含了 React Scheduler 的核心概念，有助于深入理解 React 的调度机制。\\n\\n## 补充\\n\\nReact 19 可能计划改变调度器的实现方式，主要是使用浏览器新的 API：Scheduler Postask API。\\n\\n这个改变的原因是：\\n\\n1. 新的 Scheduler Postask API 更适合调度任务\\n\\n```js\\n// 新的 Scheduler API\\nwindow.scheduler.postTask(\\n  () => {\\n    // 执行任务\\n  },\\n  { priority: 'user-visible' }\\n);\\n```\\n\\n2. 相比 MessageChannel 的优势\\n\\n- 是专门为任务调度设计的 API\\n- 提供了原生的优先级控制\\n- 更好的性能和可靠性\\n- 与浏览器更好的集成\\n\\n3. React 团队的考虑\\n\\n- 更好地利用浏览器的能力\\n- 简化调度器的实现\\n- 提供更好的性能\\n\\n不过需要注意：\\n\\n- 这个改变还在计划中\\n- 需要等待浏览器的广泛支持\\n- 可能会提供降级方案\\n\",\"wordCount\":647},{\"id\":\"c1962d08\",\"title\":\"从零实现 React 核心原理：深入理解 Fiber 架构\",\"date\":\"2024-03-02\",\"tags\":[\"react\"],\"fileName\":\"从零实现 React 核心原理：深入理解 Fiber 架构.md\",\"content\":\"\\n## 前言\\n\\n在这篇文章中，我们将通过实现一个简化版的 React 来深入理解 React 的核心工作原理，特别是 Fiber 架构和协调过程。\\n\\n## 1. React.createElement 和虚拟 DOM\\n\\n首先，我们实现了最基础的 `createElement` 函数，这是 JSX 转换的核心：\\n\\n```javascript\\nconst React = {\\n  createElement(type, props, ...children) {\\n    return {\\n      type,\\n      props: {\\n        ...props,\\n        children: children.map((child) => (typeof child === 'object' ? child : React.createTextElement(child))),\\n      },\\n    };\\n  },\\n};\\n```\\n\\n这个函数将 JSX：\\n\\n```jsx\\n<div id=\\\"1\\\">\\n  <span>2</span>\\n</div>\\n```\\n\\n转换为虚拟 DOM 对象：\\n\\n```javascript\\n{\\n  type: \\\"div\\\",\\n  props: {\\n    id: \\\"1\\\",\\n    children: [{\\n      type: \\\"span\\\",\\n      props: {\\n        children: [{\\n          type: \\\"TEXT_ELEMENT\\\",\\n          props: { nodeValue: \\\"2\\\", children: [] }\\n        }]\\n      }\\n    }]\\n  }\\n}\\n```\\n\\n## 2. Fiber 架构的实现\\n\\n### 2.1 什么是 Fiber？\\n\\nFiber 是 React 16 引入的新架构，它的核心目标是实现增量渲染：能够将渲染工作分片，并将其分散到多个帧中。\\n\\n每个 Fiber 节点包含以下关键信息：\\n\\n```\\n{\\n  type, // 节点类型\\n  props, // 属性\\n  dom, // 真实 DOM 节点\\n  parent, // 父 Fiber 节点\\n  child, // 子 Fiber 节点\\n  sibling, // 兄弟 Fiber 节点\\n  alternate, // 上一次渲染的 Fiber 节点\\n  effectTag; // 标记节点要执行的操作\\n}\\n```\\n\\n### 2.2 工作循环（Work Loop）\\n\\n实现时间切片的核心是工作循环：\\n\\n```javascript\\nfunction workLoop(deadline) {\\n  let shouldYield = false;\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\\n    shouldYield = deadline.timeRemaining() < 1;\\n  }\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot();\\n  }\\n  requestIdleCallback(workLoop);\\n}\\n```\\n\\n这个循环的特点是：\\n\\n1. 可以被中断（当浏览器需要处理其他任务时）\\n2. 通过 `requestIdleCallback` 在浏览器空闲时执行\\n3. 每个工作单元执行完后都会检查剩余时间\\n\\n## 3. 协调过程（Reconciliation）\\n\\n协调过程是 React 的核心，它决定如何高效地更新 UI：\\n\\n```javascript\\nfunction reconcileChildren(fiber, elements) {\\n  let index = 0;\\n  let oldFiber = fiber.alternate && fiber.alternate.child;\\n  let prevSibling = null;\\n\\n  while (index < elements.length || oldFiber !== null) {\\n    const element = elements[index];\\n    let newFiber = null;\\n\\n    // 比较新旧节点\\n    const sameType = oldFiber && element && oldFiber.type === element.type;\\n\\n    if (sameType) {\\n      // 更新节点\\n      newFiber = {\\n        type: oldFiber.type,\\n        props: element.props,\\n        dom: oldFiber.dom,\\n        parent: fiber,\\n        alternate: oldFiber,\\n        effectTag: 'UPDATE',\\n      };\\n    }\\n    if (!sameType && element) {\\n      // 新增节点\\n      newFiber = createFiber(element, fiber);\\n      newFiber.effectTag = 'PLACEMENT';\\n    }\\n    if (oldFiber && !sameType) {\\n      // 删除节点\\n      oldFiber.effectTag = 'DELETION';\\n      deletions.push(oldFiber);\\n    }\\n  }\\n}\\n```\\n\\n协调过程的三种主要操作：\\n\\n1. 更新：当新旧节点类型相同时\\n2. 创建：当有新节点时\\n3. 删除：当旧节点不再需要时\\n\\n## 4. 提交阶段（Commit Phase）\\n\\n最后是将变更应用到真实 DOM 的阶段：\\n\\n```javascript\\nfunction commitWork(fiber) {\\n  if (!fiber) return;\\n\\n  const domParent = fiber.parent.dom;\\n  if (fiber.effectTag === 'PLACEMENT') {\\n    domParent.appendChild(fiber.dom);\\n  } else if (fiber.effectTag === 'UPDATE') {\\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props);\\n  } else if (fiber.effectTag === 'DELETION') {\\n    domParent.removeChild(fiber.dom);\\n  }\\n\\n  commitWork(fiber.child);\\n  commitWork(fiber.sibling);\\n}\\n```\\n\\n提交阶段的特点：\\n\\n1. 是同步执行的，不能被中断\\n2. 只有在所有工作单元处理完后才会执行\\n3. 按照深度优先的顺序应用变更\\n\\n## 5. 完整代码\\n\\n```js\\nconst React = {\\n  createElement(type, props, ...children) {\\n    return {\\n      type,\\n      props: {\\n        ...props,\\n        children: children.map((child) => (typeof child === 'object' ? child : React.createTextElement(child))),\\n      },\\n    };\\n  },\\n  createTextElement(text) {\\n    return {\\n      type: 'TEXT_ELEMENT',\\n      props: { nodeValue: text, children: [] },\\n    };\\n  },\\n};\\n\\nconst vdom = React.createElement('div', { id: '1' }, React.createElement('span', null, '2'));\\n\\n// <div id=\\\"1\\\"><span>2</span></div>\\nconsole.log(vdom);\\n\\n// 完成虚拟DOM转fiber结构和时间切片\\n\\nlet nextUnitOfWork = null; // 下一个工作单元\\nlet wipRoot = null; // 当前正在工作的根节点\\nlet currentRoot = null; // 上一次的根节点\\nlet deletions = null; // 需要删除的节点\\n\\nfunction render(element, container) {\\n  // 初始化fiber结构\\n  wipRoot = {\\n    dom: container,\\n    props: {\\n      children: [element],\\n    },\\n    // 旧的fiber树\\n    alternate: currentRoot,\\n  };\\n  deletions = [];\\n  nextUnitOfWork = wipRoot;\\n}\\n\\nfunction createDom(fiber) {\\n  const dom = fiber.type === 'TEXT_ELEMENT' ? document.createTextNode('') : document.createElement(fiber.type);\\n\\n  updateDom(dom, {}, fiber.props); // 挂在新的属性\\n\\n  return dom;\\n}\\n\\nfunction updateDom(dom, prevProps, nextProps) {\\n  // 旧的属性删除\\n  Object.keys(prevProps)\\n    .filter((name) => name !== 'children')\\n    .forEach((name) => {\\n      dom[name] = '';\\n    });\\n  // 新的属性要添加\\n  Object.keys(nextProps)\\n    .filter((name) => name !== 'children')\\n    .forEach((name) => {\\n      dom[name] = nextProps[name];\\n    });\\n}\\n\\nfunction workLoop(deadline) {\\n  // 是否需要让出时间\\n  let shouldYield = false;\\n  while (nextUnitOfWork && !shouldYield) {\\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\\n    shouldYield = deadline.timeRemaining() < 1;\\n  }\\n  // 没有工作单元 -> 所有改动都已经完成\\n  if (!nextUnitOfWork && wipRoot) {\\n    commitRoot();\\n  }\\n  requestIdleCallback(workLoop);\\n}\\n\\nrequestIdleCallback(workLoop);\\n\\n// 返回值返回下一个工作单元（fiber）\\nfunction performUnitOfWork(fiber) {\\n  if (!fiber.dom) {\\n    fiber.dom = createDom(fiber);\\n  }\\n  const elements = Array.isArray(fiber.props.children) ? fiber.props.children : [fiber.props.children];\\n  // 遍历子节点\\n  reconcileChildren(fiber, elements);\\n\\n  if (fiber.child) {\\n    return fiber.child;\\n  }\\n  let nextFiber = fiber;\\n  while (nextFiber) {\\n    if (nextFiber.sibling) {\\n      // 返回兄弟节点\\n      return nextFiber.sibling;\\n    }\\n    // 返回父节点\\n    nextFiber = nextFiber.parent;\\n  }\\n  return null;\\n}\\n\\nfunction createFiber(element, parent) {\\n  return {\\n    type: element.type,\\n    props: element.props,\\n    parent: parent,\\n    dom: null,\\n    alternate: null,\\n    effectTag: null,\\n    sibling: null,\\n    child: null,\\n  };\\n}\\n\\n// diff 算法、形成 fiber 树\\nfunction reconcileChildren(fiber, elements) {\\n  let index = 0;\\n  let oldFiber = fiber.alternate && fiber.alternate.child;\\n  let prevSibling = null;\\n\\n  while (index < elements.length || oldFiber !== null) {\\n    const element = elements[index];\\n    let newFiber = null;\\n    // 1、复用\\n    const sameType = oldFiber && element && oldFiber.type === element.type;\\n    if (sameType) {\\n      console.log('复用', element);\\n      newFiber = {\\n        // 类型复用\\n        type: oldFiber.type,\\n        // 属性可能会变\\n        props: element.props,\\n        // 复用dom\\n        dom: oldFiber.dom,\\n        parent: fiber,\\n        alternate: oldFiber,\\n        // 更新\\n        effectTag: 'UPDATE',\\n      };\\n    }\\n    // 2、新增\\n    if (!sameType && element) {\\n      console.log('新增', element);\\n      newFiber = createFiber(element, fiber);\\n      newFiber.effectTag = 'PLACEMENT'; // 新增\\n    }\\n    // 3、删除\\n    if (oldFiber && !sameType) {\\n      console.log('删除', oldFiber);\\n      oldFiber.effectTag = 'DELETION';\\n      deletions.push(oldFiber);\\n    }\\n    if (oldFiber) {\\n      oldFiber = oldFiber.sibling;\\n    }\\n\\n    if (index === 0) {\\n      fiber.child = newFiber;\\n    } else {\\n      prevSibling.sibling = newFiber;\\n    }\\n    prevSibling = newFiber;\\n    index++;\\n  }\\n}\\n\\nfunction commitRoot() {\\n  deletions.forEach(commitWork);\\n  commitWork(wipRoot.child);\\n  currentRoot = wipRoot; // 更新旧的fiber树\\n  wipRoot = null; // 所有的变化都完成了 回归原始状态\\n}\\n\\n// 提交工作\\nfunction commitWork(fiber) {\\n  if (!fiber) {\\n    return;\\n  }\\n  const domParent = fiber.parent.dom;\\n  if (fiber.effectTag === 'PLACEMENT' && fiber.dom !== null) {\\n    domParent.appendChild(fiber.dom);\\n  } else if (fiber.effectTag === 'UPDATE' && fiber.dom !== null) {\\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props);\\n  } else if (fiber.effectTag === 'DELETION') {\\n    domParent.removeChild(fiber.dom);\\n  }\\n  commitWork(fiber.child);\\n  commitWork(fiber.sibling);\\n}\\n\\n// 获取容器元素\\nconst container = document.getElementById('root');\\n\\nrender(React.createElement('div', { id: 1 }, React.createElement('span', null, 'a')), container);\\n\\nsetTimeout(() => {\\n  render(React.createElement('div', { id: 1 }, React.createElement('p', null, 'b')), container);\\n}, 2000);\\n```\\n\\n## 6. 总结\\n\\n这个简化版的实现展示了 React 的核心工作原理：\\n\\n1. 使用虚拟 DOM 描述 UI\\n2. 通过 Fiber 架构实现可中断的渲染\\n3. 通过协调过程高效地计算更新\\n4. 在提交阶段同步应用这些更新\\n\\n虽然这个实现省略了很多 React 的特性（如事件系统、Hooks、Context 等），但它展示了 React 最核心的工作原理。理解这些原理对于深入使用 React 和调试复杂问题都很有帮助。\\n\\n这个实现也展示了现代前端框架是如何解决性能问题的：通过将大量工作分解成小单元，并在浏览器空闲时执行，从而不阻塞主线程，保证了良好的用户体验。\\n\",\"wordCount\":561},{\"id\":\"32f99c1f\",\"title\":\"web worker 全解\",\"date\":\"2024-02-16\",\"tags\":[\"javascript\",\"web worker\",\"性能优化\"],\"fileName\":\"web worker 全解.md\",\"content\":\"\\n## 前言\\n\\n在 Web 开发中，JavaScript 是单线程的，这意味着所有任务都在主线程上执行。当遇到计算密集型任务时，可能会导致页面卡顿。Web Worker 提供了在后台线程中运行脚本的能力，让我们可以进行真正的并行处理。\\n\\n## Web Worker 基础\\n\\n### 1. 创建 Worker\\n\\n```javascript\\n// main.js\\nconst worker = new Worker('worker.js');\\n\\n// worker.js\\nself.onmessage = (e) => {\\n  const result = complexCalculation(e.data);\\n  self.postMessage(result);\\n};\\n```\\n\\n### 2. 通信机制\\n\\n```javascript\\n// 主线程发送消息\\nworker.postMessage({ type: 'START', payload: data });\\n\\n// 主线程接收消息\\nworker.onmessage = (e) => {\\n  console.log('Received:', e.data);\\n};\\n\\n// Worker 中发送消息\\nself.postMessage({ type: 'RESULT', payload: result });\\n\\n// Worker 中接收消息\\nself.onmessage = (e) => {\\n  console.log('Received in worker:', e.data);\\n};\\n```\\n\\n### 3. 错误处理\\n\\n```javascript\\n// 主线程监听错误\\nworker.onerror = (error) => {\\n  console.error('Worker error:', error);\\n};\\n\\n// Worker 中的错误处理\\nself.onerror = (error) => {\\n  console.error('Error in worker:', error);\\n};\\n```\\n\\n## Worker 类型\\n\\n### 1. Dedicated Worker\\n\\n最基本的 Worker 类型，一个页面专用。\\n\\n```javascript\\nconst dedicatedWorker = new Worker('worker.js');\\n```\\n\\n### 2. Shared Worker\\n\\n可以在多个页面间共享的 Worker。\\n\\n```javascript\\nconst sharedWorker = new SharedWorker('shared-worker.js');\\nsharedWorker.port.start();\\nsharedWorker.port.postMessage(data);\\n```\\n\\n### 3. Service Worker\\n\\n主要用于 PWA，可以拦截网络请求和实现缓存。\\n\\n```javascript\\n// 注册 Service Worker\\nnavigator.serviceWorker.register('/sw.js').then((registration) => {\\n  console.log('SW registered');\\n});\\n```\\n\\n## 数据传输\\n\\n### 1. 基本数据传输\\n\\n```javascript\\n// 传输普通数据\\nworker.postMessage({\\n  number: 42,\\n  string: 'Hello',\\n  array: [1, 2, 3],\\n});\\n```\\n\\n### 2. Transferable Objects\\n\\n```javascript\\n// 传输 ArrayBuffer\\nconst buffer = new ArrayBuffer(1024);\\nworker.postMessage(buffer, [buffer]);\\n\\n// 传输 ImageBitmap\\ncreateImageBitmap(imageBlob).then((bitmap) => {\\n  worker.postMessage({ image: bitmap }, [bitmap]);\\n});\\n```\\n\\n### 3. SharedArrayBuffer\\n\\n```javascript\\n// 共享内存\\nconst sharedBuffer = new SharedArrayBuffer(1024);\\nworker.postMessage({ buffer: sharedBuffer });\\n```\\n\\n## 实际应用场景\\n\\n### 1. 大数据处理\\n\\n```javascript\\n// main.js\\nconst dataWorker = new Worker('data-worker.js');\\n\\nfunction processLargeDataset(data) {\\n  dataWorker.postMessage(data);\\n}\\n\\ndataWorker.onmessage = (e) => {\\n  updateUI(e.data);\\n};\\n\\n// data-worker.js\\nself.onmessage = (e) => {\\n  const result = e.data.map((item) => complexCalculation(item));\\n  self.postMessage(result);\\n};\\n```\\n\\n### 2. 图像处理\\n\\n```javascript\\n// image-worker.js\\nself.onmessage = async (e) => {\\n  const { imageData } = e.data;\\n  const processed = await applyImageFilters(imageData);\\n  self.postMessage(processed);\\n};\\n\\n// 使用示例\\nconst imageWorker = new Worker('image-worker.js');\\nconst canvas = document.createElement('canvas');\\nconst ctx = canvas.getContext('2d');\\nconst imageData = ctx.getImageData(0, 0, width, height);\\n\\nimageWorker.postMessage({ imageData });\\n```\\n\\n### 3. 实时数据处理\\n\\n```javascript\\n// websocket-worker.js\\nlet ws;\\n\\nself.onmessage = (e) => {\\n  if (e.data.type === 'connect') {\\n    ws = new WebSocket(e.data.url);\\n    ws.onmessage = (event) => {\\n      const processed = processData(event.data);\\n      self.postMessage(processed);\\n    };\\n  }\\n};\\n```\\n\\n## 性能优化实践\\n\\n### 1. Worker 池\\n\\n```javascript\\nclass WorkerPool {\\n  constructor(size, workerScript) {\\n    this.workers = [];\\n    this.queue = [];\\n    this.activeWorkers = new Map();\\n\\n    for (let i = 0; i < size; i++) {\\n      const worker = new Worker(workerScript);\\n      this.workers.push(worker);\\n    }\\n  }\\n\\n  runTask(data) {\\n    return new Promise((resolve, reject) => {\\n      const availableWorker = this.workers.find((w) => !this.activeWorkers.has(w));\\n\\n      if (availableWorker) {\\n        this.executeTask(availableWorker, data, resolve);\\n      } else {\\n        this.queue.push({ data, resolve });\\n      }\\n    });\\n  }\\n\\n  executeTask(worker, data, resolve) {\\n    const handler = (e) => {\\n      worker.removeEventListener('message', handler);\\n      this.activeWorkers.delete(worker);\\n      resolve(e.data);\\n\\n      if (this.queue.length > 0) {\\n        const next = this.queue.shift();\\n        this.executeTask(worker, next.data, next.resolve);\\n      }\\n    };\\n\\n    worker.addEventListener('message', handler);\\n    this.activeWorkers.set(worker, handler);\\n    worker.postMessage(data);\\n  }\\n}\\n```\\n\\n### 2. 任务分片\\n\\n```javascript\\n// 大任务分片处理\\nfunction splitTask(data, chunkSize) {\\n  const chunks = [];\\n  for (let i = 0; i < data.length; i += chunkSize) {\\n    chunks.push(data.slice(i, i + chunkSize));\\n  }\\n  return chunks;\\n}\\n\\nconst workerPool = new WorkerPool(4, 'worker.js');\\nconst chunks = splitTask(largeData, 1000);\\n\\nPromise.all(chunks.map((chunk) => workerPool.runTask(chunk))).then((results) => {\\n  const finalResult = results.flat();\\n  updateUI(finalResult);\\n});\\n```\\n\\n## 注意事项与限制\\n\\n1. **Worker 限制**\\n\\n- 不能访问 DOM\\n- 不能使用 window 对象\\n- 限制使用某些 Web API\\n\\n2. **内存考虑**\\n\\n- 合理控制 Worker 数量\\n- 注意数据传输开销\\n- 及时终止不需要的 Worker\\n\\n3. **调试技巧**\\n\\n```javascript\\n// Worker 中添加调试信息\\nself.postMessage({\\n  type: 'DEBUG',\\n  payload: {\\n    memory: performance.memory,\\n    time: performance.now(),\\n  },\\n});\\n```\\n\\n## 总结\\n\\nWeb Worker 为 Web 应用提供了强大的多线程能力，适合处理：\\n\\n1. 计算密集型任务\\n2. 大数据处理\\n3. 实时数据处理\\n4. 图像处理\\n\\n通过合理使用 Worker，我们可以：\\n\\n- 提升应用性能\\n- 优化用户体验\\n- 实现更复杂的功能\\n\\n记住要根据实际需求选择合适的 Worker 类型和数据传输方式，同时注意内存管理和性能优化。\\n\",\"wordCount\":369},{\"id\":\"4580856b\",\"title\":\"写一个简易版的 zustand\",\"date\":\"2023-08-11\",\"tags\":[\"react\",\"zustand\",\"状态管理\"],\"fileName\":\"写一个简易版的 zustand.md\",\"content\":\"\\n## 前言\\n\\n工作中的状态管理从一开始的`rematch`切换到了`zustand`，相比于`rematch`，`zustand`更加的简单易用体积小，且使业务中少写了很多模板代码。因此抱着学习的态度来研究一下它的底层实现。\\n\\n## 基本使用\\n\\n根据官方文档给出的基本示例：\\n\\n1.首先通过`create`来创建我们的全局状态\\n\\n```js\\nimport { create } from 'zustand';\\n\\nconst useBearStore = create((set) => ({\\n  bears: 0,\\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\\n  removeAllBears: () => set({ bears: 0 }),\\n}));\\n```\\n\\n2.将状态绑定到需要的组件中\\n\\n```js\\n// 展示 bears 数值\\nfunction BearCounter() {\\n  const bears = useBearStore((state) => state.bears);\\n  return <h1>{bears} around here ...</h1>;\\n}\\n\\n// 点击按钮，增加 bears 数值\\nfunction Controls() {\\n  const increasePopulation = useBearStore((state) => state.increasePopulation);\\n  return <button onClick={increasePopulation}>one up</button>;\\n}\\n```\\n\\n以上便是 zustand 的基本使用了，这个场景其实已经涵盖了百分之八十的业务场景了，业务中无非也就是创建状态，然后去消费、设置状态。\\n\\n## zustand 的本质\\n\\n通过[阅读源码](https://github.com/pmndrs/zustand/tree/main/src)可以发现，其实`zustand`的本质是通过闭包去实现全局状态的管理。\\n\\n这种实现方式的优点是：\\n\\n- 状态被完全封装，外部无法直接访问和修改\\n- 通过闭包提供的访问控制，我们可以精确控制状态的更新方式\\n- 不需要像 Redux 那样维护一个全局的 store 对象\\n- 实现简单且高效，因为状态更新直接发生在闭包内部\\n\\n## 写一个简化版本的 zustand\\n\\n根据对源码核心原理的理解，我们可以写一个简化版本的`zustand`，代码如下：\\n\\n```js\\n// 创建 store 的函数\\nfunction create(createState) {\\n  let state;\\n  const listeners = new Set();\\n\\n  // 设置状态并通知所有监听器\\n  const setState = (partial) => {\\n    const nextState = typeof partial === 'function' ? partial(state) : partial;\\n    if (nextState !== state) {\\n      state = Object.assign({}, state, nextState);\\n      listeners.forEach((listener) => listener(state));\\n    }\\n  };\\n\\n  // 获取当前状态\\n  const getState = () => state;\\n\\n  // 订阅状态变化\\n  const subscribe = (listener) => {\\n    listeners.add(listener);\\n    return () => listeners.delete(listener);\\n  };\\n\\n  // 初始化状态\\n  const api = { setState, getState, subscribe };\\n  state = createState(setState, getState, api);\\n\\n  const useStore = (selector = (state) => state) => {\\n    const [, forceUpdate] = React.useReducer((c) => c + 1, 0);\\n    const currentState = React.useRef(state);\\n\\n    React.useEffect(() => {\\n      const listener = () => {\\n        const nextState = selector(state);\\n        if (nextState !== currentState.current) {\\n          currentState.current = nextState;\\n          forceUpdate();\\n        }\\n      };\\n      // 订阅视图更新监听器\\n      const destory = subscribe(listener);\\n      // 销毁视图更新监听器\\n      return destory;\\n    }, [selector]);\\n\\n    return selector(state);\\n  };\\n\\n  // 将 store 的方法挂载到 useStore 上\\n  Object.assign(useStore, {\\n    getState,\\n    setState,\\n    subscribe,\\n  });\\n\\n  return useStore;\\n}\\n```\\n\\n## useSyncExternalStore\\n\\n`useSyncExternalStore` 是 React 18 引入的一个专门用于订阅外部数据源的 Hook\\n\\n在`zustand`的最新版本中可以看到它是使用`useSyncExternalStore`去做视图更新的，它这么做主要是基于以下原因：\\n\\n并发模式支持：\\n\\n- 在 React 18 的并发模式下，useEffect 可能会被延迟执行，这可能导致状态更新不及时\\n- useSyncExternalStore 能确保在并发模式下状态更新是同步的，避免出现状态不一致的问题\\n\\n性能优化：\\n\\n- useSyncExternalStore 内部实现了更高效的订阅机制\\n- 它能够避免不必要的重渲染，只在状态真正变化时才触发更新\\n\\nSSR 支持：\\n\\n- useSyncExternalStore 对服务端渲染（SSR）有更好的支持\\n- 它能够正确处理服务端和客户端的状态同步\\n\\n因此我们可以优化一下我们的代码：\\n\\n```js\\n// 创建 store 的函数\\nfunction create(createState) {\\n  let state;\\n  const listeners = new Set();\\n\\n  // 设置状态并通知所有监听器\\n  const setState = (partial) => {\\n    const nextState = typeof partial === 'function' ? partial(state) : partial;\\n    if (nextState !== state) {\\n      state = Object.assign({}, state, nextState);\\n      listeners.forEach((listener) => listener(state));\\n    }\\n  };\\n\\n  // 获取当前状态\\n  const getState = () => state;\\n\\n  // 订阅状态变化\\n  const subscribe = (listener) => {\\n    listeners.add(listener);\\n    return () => listeners.delete(listener);\\n  };\\n\\n  // 初始化状态\\n  const api = { setState, getState, subscribe };\\n  state = createState(setState, getState, api);\\n\\n  // 使用 useSyncExternalStore 替代 useReducer 和 useEffect\\n  const useStore = (selector = (state) => state) => {\\n    return React.useSyncExternalStore(\\n      subscribe,\\n      () => selector(state),\\n      () => selector(state)\\n    );\\n  };\\n\\n  // 将 store 的方法挂载到 useStore 上\\n  Object.assign(useStore, {\\n    getState,\\n    setState,\\n    subscribe,\\n  });\\n\\n  return useStore;\\n}\\n```\\n\\n解释一下 useSyncExternalStore 的三个参数：\\n\\n- subscribe: 订阅函数，当外部数据源发生变化时会被调用\\n- getSnapshot: 获取当前状态的函数\\n- getServerSnapshot: 在服务端渲染时获取状态的函数（这里我们使用相同的函数）\\n\",\"wordCount\":605},{\"id\":\"ff092e46\",\"title\":\"HTTP 成长史\",\"date\":\"2023-06-26\",\"tags\":[\"http\",\"网络\"],\"fileName\":\"HTTP 成长史.md\",\"content\":\"\\n## 前言\\n\\nHTTP（HyperText Transfer Protocol）作为互联网的基础协议，见证了 Web 的蓬勃发展。从最初的 HTTP/1.0 到最新的 HTTP/3，每一次升级都带来了革命性的改进。让我们深入了解各个版本的特点、优势和局限。\\n\\n## HTTP/1.0：奠定基础\\n\\n### 核心特性\\n\\n1. 版本号概念的引入\\n2. 请求/响应头部（Header）的引入\\n3. 状态码系统\\n4. 多种内容类型（Content-Type）支持\\n\\n### 工作方式\\n\\n- 简单的请求-响应模式\\n- 每个请求都需要建立新的 TCP 连接\\n- 连接完成后立即断开（非持久连接）\\n\\n### 局限性\\n\\n1. 性能问题\\n\\n- 每个请求都需要重新建立 TCP 连接\\n- TCP 的三次握手带来额外开销\\n- 无法复用连接\\n\\n2. 功能限制\\n\\n- 不支持断点续传\\n- 不支持虚拟主机\\n- 缺乏缓存控制机制\\n\\n## HTTP/1.1：重大改进\\n\\n### 核心改进\\n\\n1. 持久连接（Keep-Alive）\\n\\n- 默认开启\\n- 可以复用 TCP 连接\\n- 显著减少握手开销\\n\\n2. 管道化（Pipelining）\\n\\n- 允许在单个连接中发送多个请求\\n- 无需等待上一个响应完成\\n- 但受制于队头阻塞问题\\n\\n3. 新增功能\\n\\n- 断点续传支持\\n- 虚拟主机支持\\n- 新增请求方法（PUT、DELETE、OPTIONS等）\\n- 缓存控制机制\\n- 响应分块传输编码\\n\\n### 存在的问题\\n\\n1. 队头阻塞（Head-of-line blocking）\\n\\n- 前面的请求阻塞后续请求\\n- 影响整体性能\\n\\n2. 效率问题\\n\\n- 请求/响应头部未压缩\\n- 每个域名的 TCP 连接数限制\\n- 管道化实现复杂，浏览器默认关闭\\n\\n## HTTP/2：革命性突破\\n\\n### 核心创新\\n\\n1. 多路复用（Multiplexing）\\n\\n- 单个 TCP 连接支持并发的数据流\\n- 解决了 HTTP/1.1 的队头阻塞问题\\n- 提高了网络利用效率\\n\\n2. 二进制分帧层\\n\\n- 将信息分割为更小的帧\\n- 支持乱序传输和重组\\n- 提供了更高效的传输方式\\n\\n3. Header 压缩\\n\\n- 使用 HPACK 算法\\n- 显著减少头部开销\\n- 提高带宽利用率\\n\\n4. 服务器推送（Server Push）\\n\\n- 服务器可主动推送资源\\n- 减少客户端请求次数\\n- 提升页面加载速度\\n\\n### 优化特性\\n\\n1. 请求优先级\\n\\n- 可以设置请求的优先级\\n- 优化关键资源的加载\\n\\n2. 流量控制\\n\\n- 基于流的控制机制\\n- 更精细的资源分配\\n\\n### 面临的挑战\\n\\n1. TCP 层面的局限\\n\\n- TCP 层仍存在队头阻塞\\n- 建立连接时间较长\\n\\n2. 部署要求\\n\\n- 需要 HTTPS 支持\\n- 配置相对复杂\\n\\n## HTTP/3：面向未来\\n\\n### 革命性变化\\n\\n1. QUIC 协议\\n\\n- 基于 UDP 构建\\n- 彻底解决队头阻塞\\n- 集成了 TLS 1.3\\n\\n2. 性能优化\\n\\n- 快速连接建立（0-RTT 或 1-RTT）\\n- 改进的拥塞控制\\n- 更好的丢包恢复机制\\n\\n### 创新特性\\n\\n1. 连接迁移\\n\\n- 支持网络切换（如 4G 转 Wi-Fi）\\n- 保持连接状态\\n\\n2. 安全性\\n\\n- 内建加密\\n- 更好的隐私保护\\n\\n### 实施挑战\\n\\n1. 部署门槛\\n\\n- 需要服务器和客户端同时支持\\n- UDP 可能被防火墙拦截\\n\\n2. 资源消耗\\n\\n- CPU 使用率较高\\n- 需要更多的服务器资源\\n\\n## 版本选择建议\\n\\n1. 现代 Web 应用\\n\\n- 推荐：HTTP/2 或 HTTP/3\\n- 原因：更好的性能和功能支持\\n\\n2. 简单静态网站\\n\\n- 可选：HTTP/1.1\\n- 原因：部署简单，功能足够\\n\\n3. 高性能要求场景\\n\\n- 推荐：HTTP/3\\n- 原因：最佳性能和移动支持\\n\\n4. 遗留系统\\n\\n- 建议：保持 HTTP/1.1\\n- 计划：逐步迁移到新版本\\n\\n## 总结\\n\\nHTTP 协议的演进史是 Web 技术不断进步的缩影。从 HTTP/1.0 的基础功能，到 HTTP/1.1 的重要改进，再到 HTTP/2 的革命性创新，最后到 HTTP/3 的全新设计，每个版本都在解决其前身的问题，同时带来新的优化和可能性。在实际应用中，需要根据具体场景和需求选择合适的协议版本，同时为未来的升级预留空间。\\n\",\"wordCount\":981},{\"id\":\"4da8668c\",\"title\":\"请求竞态\",\"date\":\"2023-06-08\",\"tags\":[\"业务场景\"],\"fileName\":\"请求竞态.md\",\"content\":\"\\n## 引言\\n\\n在前端开发中，请求竞态（Race Condition）是一个常见但容易被忽视的问题。当我们同时发起多个异步请求，或者快速重复发起相同请求时，可能会出现后发起的请求比先发起的请求更早得到响应的情况。这种情况如果处理不当，可能会导致数据显示错误、用户体验下降，甚至引发业务逻辑错误。\\n\\n## 什么是请求竞态？\\n\\n请求竞态是指多个请求并发执行时，由于网络延迟、服务器处理时间等因素的不确定性，导致请求的响应顺序与发起顺序不一致的现象。这种情况在以下场景中特别常见：\\n\\n1. **快速切换场景**：\\n\\n   - 用户快速切换页面标签\\n   - 快速切换下拉列表选项\\n   - 快速输入搜索关键词\\n\\n2. **自动刷新场景**：\\n\\n   - 定时轮询数据\\n   - 下拉刷新\\n   - 自动加载更多\\n\\n3. **并发请求场景**：\\n   - 同时加载多个数据源\\n   - 批量操作多个资源\\n\\n## 请求竞态带来的问题\\n\\n### 1. 数据展示错误\\n\\n```javascript\\n// 示例：搜索框实时搜索\\nasync function search(keyword) {\\n  const result = await fetch(`/api/search?q=${keyword}`);\\n  const data = await result.json();\\n  displayResults(data); // 可能显示旧的搜索结果\\n}\\n\\n// 用户快速输入 \\\"a\\\" -> \\\"ab\\\" -> \\\"abc\\\"\\nsearch('a');\\nsearch('ab');\\nsearch('abc');\\n```\\n\\n如果 \\\"ab\\\" 的搜索请求比 \\\"abc\\\" 的请求晚返回，界面上会显示错误的搜索结果。\\n\\n### 2. 资源浪费\\n\\n多个重复的请求同时发起会造成不必要的服务器负载和带宽消耗。\\n\\n### 3. 状态不一致\\n\\n并发的请求响应可能导致应用状态与服务器状态不同步。\\n\\n## 解决方案\\n\\n### 1. 取消之前的请求\\n\\n在前端开发中，我们有多种方式发起 HTTP 请求，每种方式都有其对应的请求取消方法。让我们详细了解各种请求方式的取消机制。\\n\\n#### 1.1 使用 Fetch API 取消请求\\n\\nFetch API 使用 `AbortController` 来取消请求，这是现代浏览器提供的标准方案：\\n\\n```javascript\\nlet controller = null;\\n\\nasync function searchWithFetch(keyword) {\\n  // 取消之前的请求\\n  if (controller) {\\n    controller.abort();\\n  }\\n\\n  // 创建新的 AbortController\\n  controller = new AbortController();\\n\\n  try {\\n    const response = await fetch(`/api/search?q=${keyword}`, {\\n      signal: controller.signal,\\n    });\\n    const data = await response.json();\\n    displayResults(data);\\n  } catch (error) {\\n    if (error.name === 'AbortError') {\\n      // 请求被取消，不需要处理\\n      return;\\n    }\\n    // 处理其他错误\\n    console.error(error);\\n  }\\n}\\n```\\n\\n`AbortController` 是浏览器原生提供的 API，它创建一个控制器对象，该对象允许你在需要时中止一个或多个 DOM 请求。它的工作原理是：\\n\\n1. 创建一个 `AbortController` 实例\\n2. 从控制器获取 `signal` 属性并将其传递给 fetch 请求\\n3. 当需要取消请求时，调用控制器的 `abort()` 方法\\n4. 这会使正在进行的 fetch 请求抛出一个 `AbortError`，可以在 catch 块中捕获并处理\\n\\n需要注意的是，`AbortController` 不仅可以取消网络请求，还可以用于取消其他任何支持 abort signal 的异步操作。\\n\\n#### 1.2 使用 XMLHttpRequest 取消请求\\n\\nXMLHttpRequest (XHR) 是最早支持请求取消的方式，通过调用 `abort()` 方法来取消请求：\\n\\n```javascript\\nlet activeXHR = null;\\n\\nfunction searchWithXHR(keyword) {\\n  // 取消之前的请求\\n  if (activeXHR) {\\n    activeXHR.abort();\\n  }\\n\\n  // 创建新的 XHR 请求\\n  activeXHR = new XMLHttpRequest();\\n  activeXHR.open('GET', `/api/search?q=${keyword}`);\\n\\n  activeXHR.onload = function () {\\n    if (activeXHR.status === 200) {\\n      const data = JSON.parse(activeXHR.responseText);\\n      displayResults(data);\\n    }\\n  };\\n\\n  activeXHR.onerror = function () {\\n    console.error('请求失败');\\n  };\\n\\n  activeXHR.onabort = function () {\\n    console.log('请求被取消');\\n  };\\n\\n  activeXHR.send();\\n}\\n```\\n\\nXHR 的取消机制相对简单：\\n\\n1. 保存对 XHR 实例的引用\\n2. 当需要取消请求时，直接调用该实例的 `abort()` 方法\\n3. 这会立即终止请求，并触发 `onabort` 事件处理函数\\n4. 被取消的请求不会触发 `onload` 或 `onerror` 事件\\n\\nXHR 的取消机制虽然简单，但它是同步的，调用 `abort()` 后请求立即被取消，不需要像 Fetch API 那样处理 Promise 和异常。\\n\\n#### 1.3 使用 Axios 取消请求\\n\\nAxios 是一个流行的 HTTP 客户端库，它提供了两种取消请求的方式：\\n\\n##### 1.3.1 使用 CancelToken（旧版本）：\\n\\n```javascript\\nconst CancelToken = axios.CancelToken;\\nlet cancel = null;\\n\\nasync function searchWithAxiosCancelToken(keyword) {\\n  // 取消之前的请求\\n  if (cancel) {\\n    cancel('取消之前的请求');\\n  }\\n\\n  try {\\n    const response = await axios.get(`/api/search?q=${keyword}`, {\\n      cancelToken: new CancelToken(function executor(c) {\\n        // executor 函数接收一个 cancel 函数作为参数\\n        cancel = c;\\n      }),\\n    });\\n    displayResults(response.data);\\n  } catch (error) {\\n    if (axios.isCancel(error)) {\\n      // 请求被取消\\n      console.log('请求被取消:', error.message);\\n      return;\\n    }\\n    // 处理其他错误\\n    console.error(error);\\n  }\\n}\\n```\\n\\nCancelToken 的工作原理：\\n\\n1. 创建一个 CancelToken 实例，并传入一个 executor 函数\\n2. executor 函数接收一个 cancel 函数作为参数，保存这个函数以便后续使用\\n3. 当需要取消请求时，调用保存的 cancel 函数，可以传入一个消息说明取消原因\\n4. 被取消的请求会抛出一个可以通过 `axios.isCancel()` 识别的错误\\n\\n##### 1.3.2 使用 AbortController（新版本推荐）：\\n\\n从 Axios v0.22.0 开始，Axios 支持标准的 AbortController 接口：\\n\\n```javascript\\nlet controller = null;\\n\\nasync function searchWithAxiosAbort(keyword) {\\n  // 取消之前的请求\\n  if (controller) {\\n    controller.abort();\\n  }\\n\\n  // 创建新的 AbortController\\n  controller = new AbortController();\\n\\n  try {\\n    const response = await axios.get(`/api/search?q=${keyword}`, {\\n      signal: controller.signal,\\n    });\\n    displayResults(response.data);\\n  } catch (error) {\\n    if (axios.isCancel(error)) {\\n      // 请求被取消\\n      console.log('请求被取消:', error.message);\\n      return;\\n    }\\n    // 处理其他错误\\n    console.error(error);\\n  }\\n}\\n```\\n\\n这种方式与 Fetch API 的取消方式非常相似，使用了浏览器原生的 AbortController API。Axios 内部会将 AbortController 的信号转换为适当的取消机制。\\n\\n### 2. 使用标记位\\n\\n通过标记位判断是否使用返回的结果：\\n\\n```javascript\\nlet currentRequestId = 0;\\n\\nasync function searchWithFlag(keyword) {\\n  const requestId = ++currentRequestId;\\n\\n  const response = await fetch(`/api/search?q=${keyword}`);\\n  const data = await response.json();\\n\\n  // 只处理最新请求的响应\\n  if (requestId === currentRequestId) {\\n    displayResults(data);\\n  }\\n}\\n```\\n\\n### 3. 使用 SWR 或 React Query 等库\\n\\n现代前端框架提供了专门的数据请求和缓存管理库，它们内置了处理请求竞态的机制：\\n\\n```javascript\\n// 使用 SWR 示例\\nimport useSWR from 'swr';\\n\\nfunction UserProfile({ userId }) {\\n  const { data, error } = useSWR(`/api/user/${userId}`, fetcher);\\n\\n  if (error) return <div>加载失败</div>;\\n  if (!data) return <div>加载中...</div>;\\n  return <div>Hello {data.name}!</div>;\\n}\\n```\\n\\n## 最佳实践建议\\n\\n1. **选择合适的方案**：\\n\\n   - 实时搜索 -> 使用请求取消\\n   - 数据缓存 -> 使用专业的状态管理库\\n\\n2. **设置合理的超时时间**：\\n\\n   ```javascript\\n   const timeout = 5000;\\n   const controller = new AbortController();\\n   const timeoutId = setTimeout(() => controller.abort(), timeout);\\n\\n   try {\\n     const response = await fetch(url, { signal: controller.signal });\\n     clearTimeout(timeoutId);\\n     // 处理响应\\n   } catch (error) {\\n     if (error.name === 'AbortError') {\\n       console.log('请求超时或被取消');\\n     }\\n   }\\n   ```\\n\\n3. **错误处理**：\\n\\n   - 始终处理请求错误\\n   - 区分请求取消和其他错误\\n   - 提供适当的用户反馈\\n\\n4. **状态管理**：\\n   - 使用加载状态指示器\\n   - 保持 UI 响应性\\n   - 合理使用乐观更新\\n\\n## 总结\\n\\n请求竞态是前端开发中不可避免的问题，但通过合适的解决方案可以有效管理。本文重点介绍了两种主要的解决方案：取消之前的请求和使用标记位。这些方法可以帮助我们避免数据展示错误、减少资源浪费，并确保应用状态的一致性。\\n\\n通过合理处理请求竞态，我们可以构建更稳定、可靠的前端应用。\\n\",\"wordCount\":1259},{\"id\":\"a3cb0b4c\",\"title\":\"自动检测更新\",\"date\":\"2023-05-26\",\"tags\":[\"业务场景\",\"前端工程化\"],\"fileName\":\"自动检测更新.md\",\"content\":\"\\n# 前端应用自动检测更新的实现方案\\n\\n## 背景\\n\\n在现代 Web 应用开发中，前端代码的迭代速度越来越快。当我们发布新版本的应用后，如何确保用户能够及时获取到最新版本，而不是继续使用缓存中的旧版本，这成为了一个重要的问题。\\n\\n传统的解决方案是要求用户手动刷新页面，但这种方式用户体验较差，且很多用户可能并不会主动刷新。特别是在以下场景中，自动检测更新显得尤为重要：\\n\\n1. **修复关键 Bug**：当应用存在严重 Bug 并紧急修复后，需要确保用户能够立即获取到修复版本。\\n\\n2. **功能迭代**：新功能上线后，希望用户能够立即体验，而不是停留在旧版本。\\n\\n3. **API 变更**：后端 API 发生变更，前端需要相应更新以保持兼容性。\\n\\n4. **安全漏洞修复**：当发现安全漏洞并修复后，需要用户尽快更新到安全版本。\\n\\n5. **长时间打开的应用**：某些用户可能长时间不关闭应用（如在线办公工具、监控面板等），这时自动检测更新尤为必要。\\n\\n因此，实现一个可靠的前端应用自动检测更新机制，对于提升用户体验和确保应用稳定性具有重要意义。\\n\\n## 实现方案及原理\\n\\n前端自动检测更新有多种实现方案，每种方案都有其适用场景和优缺点。以下是几种常见的实现方案：\\n\\n### 1. 定时轮询检测\\n\\n**原理**：\\n\\n定时轮询是最直接的实现方式，通过定期向服务器发送请求，检查是否有新版本可用。\\n\\n```javascript\\n// 基本实现\\nfunction checkForUpdates() {\\n  fetch('/version.json?t=' + Date.now())\\n    .then((response) => response.json())\\n    .then((data) => {\\n      const currentVersion = localStorage.getItem('appVersion');\\n      if (currentVersion && currentVersion !== data.version) {\\n        // 发现新版本\\n        notifyUserAboutUpdate();\\n      } else {\\n        // 保存当前版本号\\n        localStorage.setItem('appVersion', data.version);\\n      }\\n    })\\n    .catch((error) => console.error('检查更新失败:', error));\\n}\\n\\n// 每5分钟检查一次更新\\nsetInterval(checkForUpdates, 5 * 60 * 1000);\\n\\n// 页面加载时也检查一次\\ndocument.addEventListener('DOMContentLoaded', checkForUpdates);\\n```\\n\\n**优点**：\\n\\n- 实现简单，容易理解\\n- 适用于各种浏览器环境\\n- 可以灵活控制检查频率\\n\\n**缺点**：\\n\\n- 增加服务器负载，特别是在用户量大的情况下\\n- 不够实时，更新检测存在延迟\\n- 频繁的网络请求可能影响应用性能\\n- 如果用户处于离线状态，无法检测更新\\n\\n### 2. Service Worker 缓存控制\\n\\n**原理**：\\n\\nService Worker 是一种在浏览器后台运行的脚本，可以拦截和处理网络请求，包括对资源的缓存。通过 Service Worker，我们可以实现更精细的缓存控制和更新检测。\\n\\n```javascript\\n// service-worker.js\\nconst CACHE_NAME = 'app-cache-v1';\\nconst VERSION_URL = '/version.json';\\n\\n// 安装 Service Worker\\nself.addEventListener('install', (event) => {\\n  event.waitUntil(\\n    caches.open(CACHE_NAME).then((cache) => {\\n      // 预缓存关键资源\\n      return cache.addAll(['/', '/index.html', '/styles.css', '/app.js']);\\n    })\\n  );\\n});\\n\\n// 拦截网络请求\\nself.addEventListener('fetch', (event) => {\\n  // 对于版本检查请求，始终从网络获取\\n  if (event.request.url.includes(VERSION_URL)) {\\n    event.respondWith(fetch(event.request));\\n    return;\\n  }\\n\\n  // 对其他请求使用缓存优先策略\\n  event.respondWith(\\n    caches.match(event.request).then((response) => {\\n      return (\\n        response ||\\n        fetch(event.request).then((fetchResponse) => {\\n          return caches.open(CACHE_NAME).then((cache) => {\\n            cache.put(event.request, fetchResponse.clone());\\n            return fetchResponse;\\n          });\\n        })\\n      );\\n    })\\n  );\\n});\\n\\n// 检查更新\\nself.addEventListener('activate', (event) => {\\n  event.waitUntil(\\n    fetch(VERSION_URL + '?t=' + Date.now())\\n      .then((response) => response.json())\\n      .then((data) => {\\n        // 如果版本变更，清除旧缓存\\n        if (CACHE_NAME !== 'app-cache-' + data.version) {\\n          return caches\\n            .keys()\\n            .then((cacheNames) => {\\n              return Promise.all(\\n                cacheNames.map((cacheName) => {\\n                  if (cacheName !== 'app-cache-' + data.version) {\\n                    return caches.delete(cacheName);\\n                  }\\n                })\\n              );\\n            })\\n            .then(() => {\\n              // 通知客户端有更新\\n              self.clients.matchAll().then((clients) => {\\n                clients.forEach((client) =>\\n                  client.postMessage({\\n                    type: 'UPDATE_AVAILABLE',\\n                  })\\n                );\\n              });\\n            });\\n        }\\n      })\\n  );\\n});\\n```\\n\\n**优点**：\\n\\n- 可以精确控制缓存策略\\n- 能够在后台自动更新资源\\n- 支持离线访问\\n- 减少服务器负载，大部分请求可以从缓存获取\\n\\n**缺点**：\\n\\n- 浏览器兼容性问题，旧版浏览器不支持\\n- 实现相对复杂\\n- 调试困难\\n- 更新机制可能导致用户体验不一致\\n\\n### 3. WebSocket 实时通知\\n\\n**原理**：\\n\\nWebSocket 提供了一种在客户端和服务器之间建立持久连接的方法，可以用于服务器主动向客户端推送更新通知。\\n\\n```javascript\\n// 客户端实现\\nclass UpdateNotifier {\\n  constructor() {\\n    this.socket = null;\\n    this.connect();\\n  }\\n\\n  connect() {\\n    this.socket = new WebSocket('wss://your-server.com/updates');\\n\\n    this.socket.onopen = () => {\\n      console.log('WebSocket 连接已建立');\\n    };\\n\\n    this.socket.onmessage = (event) => {\\n      const data = JSON.parse(event.data);\\n\\n      if (data.type === 'NEW_VERSION_AVAILABLE') {\\n        // 处理更新通知\\n        this.notifyUser(data.version, data.message);\\n      }\\n    };\\n\\n    this.socket.onclose = () => {\\n      console.log('WebSocket 连接已关闭，尝试重新连接...');\\n      // 断线重连\\n      setTimeout(() => this.connect(), 5000);\\n    };\\n\\n    this.socket.onerror = (error) => {\\n      console.error('WebSocket 错误:', error);\\n    };\\n  }\\n\\n  notifyUser(version, message) {\\n    // 显示更新提示\\n    const notification = document.createElement('div');\\n    notification.className = 'update-notification';\\n    notification.innerHTML = `\\n      <p>发现新版本 (${version}): ${message}</p>\\n      <button id=\\\"update-now\\\">立即更新</button>\\n      <button id=\\\"update-later\\\">稍后更新</button>\\n    `;\\n\\n    document.body.appendChild(notification);\\n\\n    document.getElementById('update-now').addEventListener('click', () => {\\n      window.location.reload();\\n    });\\n\\n    document.getElementById('update-later').addEventListener('click', () => {\\n      notification.remove();\\n    });\\n  }\\n}\\n\\n// 初始化更新通知器\\nconst updater = new UpdateNotifier();\\n```\\n\\n**服务端实现（Node.js 示例）**：\\n\\n```javascript\\nconst WebSocket = require('ws');\\nconst wss = new WebSocket.Server({ port: 8080 });\\n\\n// 存储所有连接的客户端\\nconst clients = new Set();\\n\\nwss.on('connection', (ws) => {\\n  // 添加新客户端\\n  clients.add(ws);\\n\\n  ws.on('close', () => {\\n    // 移除断开连接的客户端\\n    clients.delete(ws);\\n  });\\n});\\n\\n// 当有新版本发布时，通知所有客户端\\nfunction notifyClientsAboutUpdate(version, message) {\\n  const updateNotification = JSON.stringify({\\n    type: 'NEW_VERSION_AVAILABLE',\\n    version: version,\\n    message: message,\\n  });\\n\\n  clients.forEach((client) => {\\n    if (client.readyState === WebSocket.OPEN) {\\n      client.send(updateNotification);\\n    }\\n  });\\n}\\n\\n// 示例：发布新版本时调用\\n// notifyClientsAboutUpdate('1.2.0', '修复了若干bug，提升了性能');\\n```\\n\\n**优点**：\\n\\n- 实时性强，服务器可以立即推送更新通知\\n- 减少不必要的轮询请求\\n- 可以传递更详细的更新信息\\n- 适用于需要实时通知的应用\\n\\n**缺点**：\\n\\n- 需要服务器支持 WebSocket\\n- 维护长连接会消耗服务器资源\\n- 可能受到网络限制（如防火墙）\\n- 实现和维护成本较高\\n\\n### 4. HTTP 缓存控制\\n\\n**原理**：\\n\\n通过合理设置 HTTP 缓存头，可以控制浏览器对静态资源的缓存行为。对于需要频繁更新的资源，可以设置较短的缓存时间或使用版本号/哈希值作为文件名的一部分。\\n\\n```javascript\\n// 在服务器端设置适当的缓存头（Node.js Express 示例）\\nconst express = require('express');\\nconst app = express();\\n\\n// HTML 文件不缓存或短期缓存\\napp.get('*.html', (req, res) => {\\n  res.setHeader('Cache-Control', 'no-cache, max-age=0');\\n  // 处理请求...\\n});\\n\\n// 静态资源（带有哈希值的文件名）可以长期缓存\\napp.get('*.js', (req, res) => {\\n  if (req.path.includes('.chunk.') || req.path.includes('.hash.')) {\\n    // 包含哈希值的文件可以长期缓存\\n    res.setHeader('Cache-Control', 'public, max-age=31536000'); // 1年\\n  } else {\\n    // 其他JS文件使用较短的缓存时间\\n    res.setHeader('Cache-Control', 'public, max-age=3600'); // 1小时\\n  }\\n  // 处理请求...\\n});\\n\\n// 版本文件不缓存\\napp.get('/version.json', (req, res) => {\\n  res.setHeader('Cache-Control', 'no-store');\\n  res.json({ version: '1.0.0' });\\n});\\n```\\n\\n**前端构建配置（webpack示例）**：\\n\\n```javascript\\n// webpack.config.js\\nmodule.exports = {\\n  output: {\\n    filename: '[name].[contenthash].js', // 使用内容哈希作为文件名的一部分\\n    path: path.resolve(__dirname, 'dist'),\\n  },\\n  // 其他配置...\\n};\\n```\\n\\n**优点**：\\n\\n- 无需额外的客户端代码\\n- 利用浏览器原生缓存机制\\n- 减少服务器负载\\n- 适用于所有现代浏览器\\n\\n**缺点**：\\n\\n- 无法主动通知用户有更新\\n- 对于已经打开的应用，需要刷新才能获取更新\\n- 配置复杂，需要理解HTTP缓存机制\\n- 可能受到中间缓存（如CDN）的影响\\n\\n### 5. 版本号比对\\n\\n**原理**：\\n\\n在应用启动时，将本地存储的版本号与服务器上的最新版本号进行比对，如果发现新版本，则提示用户刷新。\\n\\n```javascript\\n// 在应用入口文件中\\nclass VersionChecker {\\n  constructor(options = {}) {\\n    this.options = Object.assign(\\n      {\\n        versionUrl: '/version.json',\\n        checkOnLoad: true,\\n        checkInterval: 60 * 60 * 1000, // 1小时检查一次\\n        storageKey: 'appCurrentVersion',\\n      },\\n      options\\n    );\\n\\n    this.currentVersion = localStorage.getItem(this.options.storageKey) || null;\\n\\n    if (this.options.checkOnLoad) {\\n      this.checkVersion();\\n    }\\n\\n    if (this.options.checkInterval > 0) {\\n      setInterval(() => this.checkVersion(), this.options.checkInterval);\\n    }\\n  }\\n\\n  async checkVersion() {\\n    try {\\n      const response = await fetch(this.options.versionUrl + '?t=' + Date.now());\\n      const data = await response.json();\\n\\n      // 首次访问，保存版本号\\n      if (!this.currentVersion) {\\n        this.currentVersion = data.version;\\n        localStorage.setItem(this.options.storageKey, this.currentVersion);\\n        return;\\n      }\\n\\n      // 版本号比对\\n      if (this.currentVersion !== data.version) {\\n        this.notifyUpdate(data.version, data.updateMessage);\\n      }\\n    } catch (error) {\\n      console.error('检查版本更新失败:', error);\\n    }\\n  }\\n\\n  notifyUpdate(newVersion, message = '有新版本可用') {\\n    const updateBar = document.createElement('div');\\n    updateBar.className = 'version-update-bar';\\n    updateBar.innerHTML = `\\n      <span>${message} (v${newVersion})</span>\\n      <button id=\\\"refresh-app\\\">刷新应用</button>\\n      <button id=\\\"dismiss-update\\\">稍后</button>\\n    `;\\n\\n    document.body.appendChild(updateBar);\\n\\n    document.getElementById('refresh-app').addEventListener('click', () => {\\n      // 更新本地版本号并刷新\\n      localStorage.setItem(this.options.storageKey, newVersion);\\n      window.location.reload();\\n    });\\n\\n    document.getElementById('dismiss-update').addEventListener('click', () => {\\n      updateBar.remove();\\n    });\\n  }\\n}\\n\\n// 初始化版本检查器\\nconst versionChecker = new VersionChecker();\\n```\\n\\n**优点**：\\n\\n- 实现相对简单\\n- 可以提供用户友好的更新提示\\n- 灵活性高，可以自定义检查频率和提示方式\\n- 可以与其他更新策略结合使用\\n\\n**缺点**：\\n\\n- 需要额外的服务器端点来提供版本信息\\n- 依赖客户端存储，可能受到用户清除缓存的影响\\n- 更新检测有延迟\\n- 需要用户主动刷新才能应用更新\\n\\n### 6. HTML Script 标签比对\\n\\n**原理**：\\n\\n这是一种纯前端的解决方案，通过定期获取HTML文档并解析其中的script标签，与上一次获取的结果进行比对，如果发现差异（如新增、删除或修改了script标签），则提示用户刷新页面获取最新版本。\\n\\n```javascript\\nclass ScriptChangeDetector {\\n  constructor(options = {}) {\\n    this.options = Object.assign(\\n      {\\n        checkInterval: 5 * 60 * 1000, // 5分钟检查一次\\n        indexUrl: window.location.pathname, // 默认检查当前页面\\n        storageKey: 'lastScriptsSignature',\\n      },\\n      options\\n    );\\n\\n    // 存储上次检测到的脚本信息\\n    this.lastScriptsInfo = JSON.parse(localStorage.getItem(this.options.storageKey) || '[]');\\n\\n    // 初始化时保存当前脚本信息\\n    if (this.lastScriptsInfo.length === 0) {\\n      this.saveCurrentScriptsInfo();\\n    }\\n\\n    // 设置定时检查\\n    setInterval(() => this.checkForChanges(), this.options.checkInterval);\\n  }\\n\\n  // 获取当前页面的脚本信息\\n  getCurrentScriptsInfo() {\\n    const scripts = document.querySelectorAll('script[src]');\\n    return Array.from(scripts).map((script) => {\\n      return {\\n        src: script.getAttribute('src'),\\n        // 可以添加其他属性如 type, async, defer 等\\n        type: script.getAttribute('type') || '',\\n        id: script.id || '',\\n      };\\n    });\\n  }\\n\\n  // 保存当前脚本信息到本地存储\\n  saveCurrentScriptsInfo() {\\n    const currentScriptsInfo = this.getCurrentScriptsInfo();\\n    localStorage.setItem(this.options.storageKey, JSON.stringify(currentScriptsInfo));\\n    this.lastScriptsInfo = currentScriptsInfo;\\n  }\\n\\n  // 检查HTML文档中的脚本是否有变化\\n  async checkForChanges() {\\n    try {\\n      // 获取HTML文档\\n      const response = await fetch(this.options.indexUrl + '?t=' + Date.now(), {\\n        headers: { 'Cache-Control': 'no-cache' },\\n      });\\n      const html = await response.text();\\n\\n      // 创建一个临时的DOM解析器\\n      const parser = new DOMParser();\\n      const doc = parser.parseFromString(html, 'text/html');\\n\\n      // 获取文档中的所有脚本\\n      const scripts = doc.querySelectorAll('script[src]');\\n      const newScriptsInfo = Array.from(scripts).map((script) => {\\n        return {\\n          src: script.getAttribute('src'),\\n          type: script.getAttribute('type') || '',\\n          id: script.id || '',\\n        };\\n      });\\n\\n      // 比较脚本数组\\n      if (this.scriptsChanged(this.lastScriptsInfo, newScriptsInfo)) {\\n        this.notifyUpdate();\\n      }\\n    } catch (error) {\\n      console.error('检查脚本更新失败:', error);\\n    }\\n  }\\n\\n  // 比较两个脚本数组是否有差异\\n  scriptsChanged(oldScripts, newScripts) {\\n    // 如果数量不同，肯定有变化\\n    if (oldScripts.length !== newScripts.length) {\\n      return true;\\n    }\\n\\n    // 比较每个脚本的属性\\n    for (let i = 0; i < oldScripts.length; i++) {\\n      const oldScript = oldScripts[i];\\n      const newScript = newScripts.find((s) => s.src === oldScript.src);\\n\\n      // 如果找不到相同src的脚本，或者属性不同\\n      if (!newScript || oldScript.type !== newScript.type || oldScript.id !== newScript.id) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  // 通知用户有更新\\n  notifyUpdate() {\\n    const updateNotification = document.createElement('div');\\n    updateNotification.className = 'script-update-notification';\\n    updateNotification.innerHTML = `\\n      <p>检测到应用有新版本可用，请刷新页面获取最新功能。</p>\\n      <button id=\\\"refresh-now\\\">立即刷新</button>\\n      <button id=\\\"refresh-later\\\">稍后刷新</button>\\n    `;\\n\\n    document.body.appendChild(updateNotification);\\n\\n    document.getElementById('refresh-now').addEventListener('click', () => {\\n      // 更新脚本信息并刷新页面\\n      this.saveCurrentScriptsInfo();\\n      window.location.reload();\\n    });\\n\\n    document.getElementById('refresh-later').addEventListener('click', () => {\\n      updateNotification.remove();\\n    });\\n  }\\n}\\n\\n// 初始化脚本变化检测器\\nconst scriptDetector = new ScriptChangeDetector();\\n```\\n\\n**优点**：\\n\\n- 纯前端实现，不需要服务器端支持\\n- 不依赖于特定的构建工具或框架\\n- 可以检测到任何类型的脚本变化，包括动态加载的脚本\\n- 实现相对简单，易于集成到现有项目\\n\\n**缺点**：\\n\\n- 需要额外的网络请求来获取HTML文档\\n- 可能受到跨域限制，只能检测同源的页面\\n- 无法检测到CSS、图片等其他资源的变化\\n- 如果HTML文档中的脚本顺序变化但内容相同，也会被误判为有更新\\n\\n### 7. HTTP响应头（ETag/Last-Modified）检测\\n\\n**原理**：\\n\\n这种方法利用HTTP协议中的ETag和Last-Modified响应头来检测资源是否发生变化。当服务器返回资源时，会附带这些头信息：ETag是资源内容的唯一标识符，Last-Modified表示资源最后修改时间。通过定期发送HEAD请求并比较这些头信息，可以高效地检测资源是否更新。\\n\\n```javascript\\nclass HttpHeaderChangeDetector {\\n  constructor(options = {}) {\\n    this.options = Object.assign(\\n      {\\n        checkInterval: 5 * 60 * 1000, // 5分钟检查一次\\n        indexUrl: window.location.pathname, // 默认检查当前页面\\n        storageKey: 'lastHeaderInfo',\\n      },\\n      options\\n    );\\n\\n    // 获取上次保存的头信息\\n    this.lastHeaderInfo = JSON.parse(localStorage.getItem(this.options.storageKey) || '{}');\\n\\n    // 初始化时保存当前头信息\\n    if (!this.lastHeaderInfo.etag && !this.lastHeaderInfo.lastModified) {\\n      this.saveCurrentHeaderInfo();\\n    }\\n\\n    // 设置定时检查\\n    setInterval(() => this.checkForChanges(), this.options.checkInterval);\\n  }\\n\\n  // 保存当前头信息\\n  async saveCurrentHeaderInfo() {\\n    try {\\n      const headerInfo = await this.fetchHeaderInfo();\\n      localStorage.setItem(this.options.storageKey, JSON.stringify(headerInfo));\\n      this.lastHeaderInfo = headerInfo;\\n    } catch (error) {\\n      console.error('保存头信息失败:', error);\\n    }\\n  }\\n\\n  // 获取资源的头信息\\n  async fetchHeaderInfo() {\\n    const response = await fetch(this.options.indexUrl, {\\n      method: 'HEAD', // 只获取头信息，不下载内容\\n      cache: 'no-store', // 不使用缓存\\n    });\\n\\n    return {\\n      etag: response.headers.get('ETag'),\\n      lastModified: response.headers.get('Last-Modified'),\\n    };\\n  }\\n\\n  // 检查头信息是否变化\\n  async checkForChanges() {\\n    try {\\n      const currentHeaderInfo = await this.fetchHeaderInfo();\\n\\n      // 如果ETag或Last-Modified有变化，说明资源已更新\\n      if (\\n        (currentHeaderInfo.etag && currentHeaderInfo.etag !== this.lastHeaderInfo.etag) ||\\n        (currentHeaderInfo.lastModified && currentHeaderInfo.lastModified !== this.lastHeaderInfo.lastModified)\\n      ) {\\n        this.notifyUpdate();\\n      }\\n    } catch (error) {\\n      console.error('检查更新失败:', error);\\n    }\\n  }\\n\\n  // 通知用户有更新\\n  notifyUpdate() {\\n    const updateNotification = document.createElement('div');\\n    updateNotification.className = 'header-update-notification';\\n    updateNotification.innerHTML = `\\n      <p>检测到应用有新版本可用，请刷新页面获取最新功能。</p>\\n      <button id=\\\"refresh-now\\\">立即刷新</button>\\n      <button id=\\\"refresh-later\\\">稍后刷新</button>\\n    `;\\n\\n    document.body.appendChild(updateNotification);\\n\\n    document.getElementById('refresh-now').addEventListener('click', () => {\\n      // 更新头信息并刷新页面\\n      this.saveCurrentHeaderInfo();\\n      window.location.reload();\\n    });\\n\\n    document.getElementById('refresh-later').addEventListener('click', () => {\\n      updateNotification.remove();\\n    });\\n  }\\n}\\n\\n// 初始化检测器\\nconst headerDetector = new HttpHeaderChangeDetector();\\n```\\n\\n**优点**：\\n\\n- 高效：只需发送HEAD请求，不需要下载完整的HTML内容\\n- 标准：使用HTTP标准机制，不依赖于特定的HTML结构\\n- 准确：ETag是服务器生成的精确标识，比解析HTML更可靠\\n- 轻量：减少网络传输和解析开销\\n- 通用：适用于任何类型的资源，不仅限于HTML页面\\n\\n**缺点**：\\n\\n- 需要服务器正确配置ETag和Last-Modified头\\n- 可能受到中间代理缓存的影响\\n- 无法检测客户端动态生成的内容变化\\n- 某些服务器可能不支持HEAD请求或不返回这些头信息\\n\\n## 最佳实践与方案选择\\n\\n选择合适的自动检测更新方案，需要考虑以下因素：\\n\\n1. **应用类型**：不同类型的应用有不同的更新需求\\n\\n   - 内容密集型应用（如新闻网站）：HTTP缓存控制可能更合适\\n   - 功能密集型应用（如在线工具）：Service Worker或版本号比对更适合\\n   - 实时性要求高的应用：WebSocket通知是更好的选择\\n\\n2. **用户体验要求**：\\n\\n   - 是否需要无缝更新？\\n   - 是否允许强制更新？\\n   - 是否需要提供更新说明？\\n\\n3. **技术环境**：\\n   - 浏览器兼容性要求\\n   - 服务器能力和资源限制\\n   - 是否有CDN或其他中间缓存\\n\\n### 推荐的组合方案\\n\\n在实际应用中，通常会结合多种方案以获得最佳效果：\\n\\n1. **基础层**：使用HTTP缓存控制和内容哈希\\n\\n   - HTML文件设置为不缓存或短期缓存\\n   - JS/CSS等静态资源使用内容哈希命名并长期缓存\\n   - 版本信息文件设置为不缓存\\n\\n2. **检测层**：根据应用特点选择合适的检测方式\\n\\n   - 对于需要服务器支持的应用：使用版本号比对或定时轮询\\n   - 对于纯静态应用：使用HTML Script标签比对\\n   - 对于标准HTTP服务器：优先考虑HTTP响应头（ETag/Last-Modified）检测\\n   - 对于实时性要求高的应用：使用WebSocket通知\\n   - 在应用启动和定期运行时检查更新\\n   - 发现更新时提供用户友好的通知\\n\\n3. **高级层**（可选）：使用Service Worker\\n\\n   - 提供离线访问能力\\n   - 在后台预加载更新\\n   - 提供更精细的缓存控制\\n\\n4. **降级方案**：为不支持高级特性的浏览器提供备选方案\\n   - 如果浏览器不支持Service Worker，回退到基于轮询的方案\\n   - 如果WebSocket连接失败，回退到HTTP轮询\\n\\n### 示例：综合解决方案\\n\\n```javascript\\n// 1. 注册Service Worker（如果浏览器支持）\\nif ('serviceWorker' in navigator) {\\n  window.addEventListener('load', () => {\\n    navigator.serviceWorker\\n      .register('/sw.js')\\n      .then((registration) => {\\n        console.log('Service Worker 注册成功:', registration.scope);\\n      })\\n      .catch((error) => {\\n        console.error('Service Worker 注册失败:', error);\\n      });\\n  });\\n}\\n\\n// 2. 实现版本检查\\nclass AppUpdater {\\n  constructor() {\\n    this.checkForUpdates();\\n    // 每小时检查一次更新\\n    setInterval(() => this.checkForUpdates(), 60 * 60 * 1000);\\n\\n    // 监听来自Service Worker的消息\\n    if ('serviceWorker' in navigator) {\\n      navigator.serviceWorker.addEventListener('message', (event) => {\\n        if (event.data && event.data.type === 'UPDATE_AVAILABLE') {\\n          this.showUpdateNotification(event.data.version);\\n        }\\n      });\\n    }\\n  }\\n\\n  async checkForUpdates() {\\n    try {\\n      const response = await fetch('/version.json?t=' + Date.now());\\n      const data = await response.json();\\n      const currentVersion = localStorage.getItem('appVersion');\\n\\n      if (currentVersion && currentVersion !== data.version) {\\n        this.showUpdateNotification(data.version);\\n      } else {\\n        localStorage.setItem('appVersion', data.version);\\n      }\\n    } catch (error) {\\n      console.error('检查更新失败:', error);\\n    }\\n  }\\n\\n  showUpdateNotification(version) {\\n    // 创建更新通知UI\\n    const notification = document.createElement('div');\\n    notification.className = 'update-notification';\\n    notification.innerHTML = `\\n      <p>发现新版本 (v${version})，请刷新页面获取最新功能和修复。</p>\\n      <button id=\\\"update-now\\\">立即更新</button>\\n      <button id=\\\"update-later\\\">稍后更新</button>\\n    `;\\n\\n    document.body.appendChild(notification);\\n\\n    document.getElementById('update-now').addEventListener('click', () => {\\n      window.location.reload();\\n    });\\n\\n    document.getElementById('update-later').addEventListener('click', () => {\\n      notification.remove();\\n    });\\n  }\\n}\\n\\n// 初始化更新检测\\nconst updater = new AppUpdater();\\n```\\n\\n## 总结\\n\\n前端应用自动检测更新是提升用户体验和确保应用稳定性的重要机制。本文介绍了七种主要的实现方案：定时轮询检测、Service Worker缓存控制、WebSocket实时通知、HTTP缓存控制、版本号比对、HTML Script标签比对以及HTTP响应头（ETag/Last-Modified）检测。每种方案都有其适用场景和优缺点，开发者可以根据自己的应用特点和需求，选择合适的更新检测策略。\\n\\n特别值得一提的是HTML Script标签比对和HTTP响应头检测这两种方案：\\n\\n- **HTML Script标签比对**：作为一种纯前端实现，不依赖服务器端支持，适用于静态网站或无法修改服务器配置的场景，为开发者提供了一种灵活的选择。\\n\\n- **HTTP响应头检测**：利用HTTP协议的标准机制（ETag和Last-Modified），只需发送轻量级的HEAD请求，就能高效准确地检测资源变化，是一种既标准又高效的解决方案。\\n\\n无论选择哪种方案，都应该注意以下几点：\\n\\n1. **尊重用户选择**：除非是关键安全更新，否则应该让用户决定何时更新。\\n\\n2. **提供清晰的更新信息**：告诉用户更新内容，帮助他们理解更新的必要性。\\n\\n3. **优化更新体验**：尽量减少更新对用户的干扰，考虑在后台预加载更新内容。\\n\\n4. **监控更新效果**：收集用户更新行为数据，持续优化更新策略。\\n\\n通过合理实现前端应用的自动检测更新机制，可以确保用户始终使用最新、最安全的应用版本，同时提供良好的用户体验。\\n\",\"wordCount\":2651},{\"id\":\"9b0ee691\",\"title\":\"SourceMap 的原理\",\"date\":\"2023-05-15\",\"tags\":[\"webpack\",\"工程化\"],\"fileName\":\"SourceMap 的原理.md\",\"content\":\"\\n## 前言\\n\\nSourceMap 是一种将压缩、合并或转译后的代码映射回原始源代码的技术，主要用于调试和错误追踪。它的核心原理是通过记录压缩代码与原始代码之间的位置对应关系，使开发者工具（如浏览器 DevTools）能够将压缩后的代码位置“翻译”回原始代码的位置。\\n\\n## SourceMap 的核心组成\\n\\n一个 SourceMap 文件（通常是 `.map` 后缀）包含以下关键信息（类似于一个 JSON 的格式，具有以下 6 个字段）：\\n\\n1. **版本（version）**：当前 SourceMap 的版本（如 3）。\\n2. **文件（file）**：生成的压缩文件名（如 bundle.min.js）。\\n3. **原始文件列表（sources）**：所有原始源文件的路径（如 [\\\"src/index.js\\\", \\\"src/utils.js\\\"]）。\\n4. **原始内容（sourcesContent）**：可选，直接包含原始代码内容，避免额外请求。\\n5. **名称（names）**：压缩过程中被缩短的变量名或函数名的原始名称（如将 myVariable 压缩为 a）。\\n6. **映射数据（mappings）**：最核心的部分，通过特定编码（如 VLQ）记录压缩代码与原始代码的位置对应关系。\\n\\n## 映射数据（mappings）的编码原理\\n\\n`mappings` 字段是一个字符串，通过分段编码记录了每个生成代码位置对应的原始位置。其编码过程如下：\\n\\n1. 位置分段\\n\\n- 每一行生成代码（压缩后的代码）用分号 ; 分隔。\\n- 同一行内的每个位置映射用逗号 , 分隔。\\n- 每个位置映射包含 1-5 个字段，用 VLQ 编码表示：\\n\\n```\\n生成的列 > 原始文件索引 > 原始行 > 原始列 > （可选）名称索引\\n```\\n\\n2. VLQ（Variable Length Quantity）编码\\n\\n- VLQ 是一种变长编码，能将大整数转换为 Base64 字符，减少文件体积。\\n- 每个位置字段的值是相对于前一个位置的 偏移量（而非绝对值），进一步压缩数据。\\n- 例如：数值 7 的 VLQ 编码是 7 → Base64 字符 7；数值 1000 的 VLQ 编码是 qB。\\n\\n3. 编码示例\\n\\n假设有以下映射字符串：\\n\\n```\\nmappings: \\\"AAAA,SAASA,CAASC\\\"\\n```\\n\\n解码后可能表示：\\n\\n- AAAA → 生成代码第 0 列 → 对应原始文件 0 的第 0 行第 0 列。\\n- SAASA → 生成代码第 1 列 → 对应原始文件 1 的第 1 行第 0 列。\\n\\n## 生成与使用流程\\n\\n1. 生成阶段：\\n\\n- 构建工具（如 Webpack、Babel、Terser）在压缩/转译代码时生成 SourceMap。\\n- 工具会记录每个生成代码位置对应的原始文件、行号、列号及原始名称。\\n\\n2. 浏览器使用阶段：\\n\\n- 浏览器检测到压缩文件末尾的 //# sourceMappingURL=bundle.min.js.map 注释时，会加载 SourceMap。\\n- 开发者工具（如 Chrome DevTools）根据 SourceMap 将压缩代码的位置映射回原始代码，显示原始文件名、行号等信息。\\n\\n## 注意事项\\n\\n1. 安全性：生产环境应避免暴露 SourceMap 文件，否则可能泄露源代码。\\n2. 性能：SourceMap 仅在打开开发者工具时加载，不影响普通用户性能。\\n3. 兼容性：现代浏览器均支持 SourceMap。\\n\\n## 总结\\n\\n通过这种映射机制，SourceMap 让开发者能在压缩代码中直接调试原始代码，极大提升了开发体验。\\n\",\"wordCount\":758},{\"id\":\"3fd32e8f\",\"title\":\"yalc 指南\",\"date\":\"2023-03-12\",\"tags\":[\"npm\",\"monorepo\",\"工程化\"],\"fileName\":\"yalc 指南.md\",\"content\":\"\\n## 前言\\n\\n业务中经常涉及到本地包的开发和调试，有一个绕不开的工具是 yalc，yalc 是一个更强大的本地包管理工具，相比 npm link 有很多优势。\\n\\n## 基本概念\\n\\n- yalc 是一个用于本地包开发和测试的工具\\n- 它模拟了真实的包安装过程，比 npm link 更接近生产环境\\n- 支持多个项目同时使用同一个本地包\\n\\n## 主要优势\\n\\n- 更接近真实环境：模拟了真实的包安装过程\\n- 更好的依赖处理：正确处理 peerDependencies\\n- 多项目支持：可以在多个项目中同时使用同一个本地包\\n- 版本管理：支持包的版本控制\\n- 更可靠：不会出现符号链接相关的问题\\n\\n## 安装\\n\\n```bash\\n# 全局安装\\nnpm install -g yalc\\n# 或\\nyarn global add yalc\\n```\\n\\n## 基本使用流程\\n\\n### 在包项目中\\n\\n```bash\\n# 1. 构建包\\nnpm run build\\n\\n# 2. 发布到本地存储\\nyalc publish\\n\\n# 3. 当代码有更新时\\nyalc push\\n```\\n\\n### 在使用包的项目中\\n\\n```bash\\n# 1. 添加本地包\\nyalc add npm-package\\n\\n# 2. 更新包\\nyalc update npm-package\\n\\n# 3. 移除包\\nyalc remove npm-package\\n```\\n\\n### 常用命令\\n\\n```bash\\n# 查看帮助\\nyalc --help\\n\\n# 查看已发布的包\\nyalc installations show\\n\\n# 清理所有安装\\nyalc installations clean\\n\\n# 查看包信息\\nyalc info\\n```\\n\\n## 工作流程示例\\n\\n假设你在开发 css-scope-loader：\\n\\n```bash\\n# 在 css-scope-loader 项目中\\n# 1. 初始化\\nnpm install -g yalc\\n\\n# 2. 构建\\nnpm run build\\n\\n# 3. 发布到本地存储\\nyalc publish\\n\\n# 4. 当代码有更新时\\n# 修改代码后\\nnpm run build\\nyalc push  # 这会自动更新所有使用这个包的项目\\n```\\n\\n在 my-app 项目中：\\n\\n```bash\\n# 1. 添加本地包\\nyalc add css-scope-loader\\n\\n# 2. 更新包（当包有更新时）\\nyalc update css-scope-loader\\n\\n# 3. 当开发完成后，移除本地包\\nyalc remove css-scope-loader\\n# 然后安装正式版本\\nnpm install css-scope-loader\\n```\\n\\n## 与 npm link 的区别\\n\\n| 特性       | yalc             | npm link       |\\n| ---------- | ---------------- | -------------- |\\n| 安装方式   | 模拟真实安装     | 使用符号链接   |\\n| 依赖处理   | 正确处理所有依赖 | 可能有依赖问题 |\\n| 多项目支持 | 支持             | 有限支持       |\\n| 更新机制   | 需要显式更新     | 自动更新       |\\n| 可靠性     | 更高             | 较低           |\\n| 使用场景   | 开发测试         | 快速原型       |\\n\\n## 最佳实践\\n\\n- 在开发包时使用 yalc publish 和 yalc push\\n- 在测试项目中使用 yalc add 和 yalc update\\n- 定期使用 yalc installations clean 清理旧的安装\\n- 在发布到 npm 前，确保使用 yalc remove 移除本地包\\n\\n## 高级用法\\n\\n```bash\\n# 发布特定版本\\nyalc publish --version 1.0.0\\n\\n# 强制更新\\nyalc push --force\\n\\n# 查看包的状态\\nyalc status\\n\\n# 添加私有包\\nyalc add file:../path/to/package\\n```\\n\\n## 与 monorepo 配合使用\\n\\n如果你使用 monorepo（如 lerna 或 yarn workspaces），yalc 可以很好地配合：\\n\\n```bash\\n# 在 monorepo 的包目录中\\nyalc publish\\n\\n# 在其他包中使用\\nyalc add css-scope-loader\\n```\\n\\n## 注意事项\\n\\n- yalc 会在项目根目录创建 .yalc 目录和 yalc.lock 文件\\n- 这些文件应该被添加到 .gitignore 中\\n- 在团队开发中，确保所有成员都使用相同版本的 yalc\\n- 在 CI/CD 环境中不要使用 yalc\\n\\n总的来说，yalc 是一个比 npm link 更强大、更可靠的本地包开发工具，特别适合：\\n\\n- 开发需要复杂依赖的包\\n- 在多个项目中测试同一个包\\n- 需要更接近生产环境的测试\\n- 团队协作开发包\\n\",\"wordCount\":558},{\"id\":\"8515dfa5\",\"title\":\"npm link 的工作原理\",\"date\":\"2023-03-11\",\"tags\":[\"npm\"],\"fileName\":\"npm link 的工作原理.md\",\"content\":\"\\n## 作用\\n\\n`npm link`是一个非常有用的开发工具，它允许你在本地开发和测试 npm 包，而不需要每次都发布到 npm 仓库。\\n\\n## 原理\\n\\n### 符号链接（Symbolic Link）机制\\n\\n- npm link 本质上是在你的系统中创建了一个符号链接（symlink）\\n- 符号链接类似于 Windows 的快捷方式或 macOS/Linux 的软链接\\n- 它创建了一个指向源文件的引用，而不是复制文件\\n\\n### 工作流程\\n\\n当你在包目录中运行`npm link`时：\\n\\n```text\\n/path/to/your-package $ npm link\\n```\\n\\n- npm 会在全局的 node_modules 目录中创建一个符号链接\\n- 这个链接指向你的包目录\\n- 包的名称来自 package.json 中的 name 字段\\n\\n当你在项目目录中运行`npm link package-name`时：\\n\\n```text\\n/path/to/your-project $ npm link package-name\\n```\\n\\n- npm 会在项目的 node_modules 目录中创建一个符号链接\\n- 这个链接指向全局 node_modules 中的包链接\\n- 最终形成了一个链式链接：项目 → 全局 → 包源码\\n\\n### 实际路径示例\\n\\n假设你的包名是 css-scope-loader：\\n\\n```text\\n项目 node_modules/css-scope-loader\\n→ 全局 node_modules/css-scope-loader\\n→ 你的包源码目录\\n```\\n\\n### 优势\\n\\n- 实时更新：修改包源码后，项目会立即看到变化\\n- 无需发布：可以在本地测试包的功能\\n- 节省时间：避免了频繁的 npm publish 和 npm install\\n- 方便调试：可以直接在源码中设置断点\\n\\n### 注意事项\\n\\n- 如果包有依赖，需要确保这些依赖在项目中可用\\n- 某些构建工具可能需要额外的配置来处理符号链接\\n- 在 Windows 系统上可能需要管理员权限\\n- 如果包使用了 peerDependencies，需要确保版本兼容\\n\\n### 替代方案\\n\\n- yarn link：与 npm link 类似，但由 yarn 提供\\n- npm install ../path/to/package：直接安装本地包\\n- yalc：更强大的本地包管理工具\\n\\n### 最佳实践\\n\\n- 在开发包时使用 npm link\\n- 在测试完成后，使用 npm unlink 解除链接\\n- 确保包的 package.json 中正确设置了 main、module 等字段\\n- 在包的 devDependencies 中声明开发依赖\\n- 在 peerDependencies 中声明必要的运行时依赖\\n\\n这就是为什么 npm link 是开发 npm 包时非常有用的工具 - 它创建了一个无缝的开发环境，让你可以实时测试和调试你的包，而不需要经过发布和安装的繁琐过程。\\n\",\"wordCount\":561},{\"id\":\"152b5457\",\"title\":\"CommonJS 和 ESModule 详解\",\"date\":\"2022-08-23\",\"tags\":[\"模块化、工程化\"],\"fileName\":\"CommonJS 和 ESModule 详解.md\",\"content\":\"\\n## CommonJS 和 ESModule 的起源与背景\\n\\n### CommonJS\\n\\n- 起源：2009 年由 Mozilla 工程师 Kevin Dangoor 提出，旨在为 JavaScript 在浏览器外（如服务器端）提供模块化支持。\\n- 应用场景：Node.js 的默认模块系统，主要用于服务器端开发。\\n- 核心目标：解决 JavaScript 无模块化的问题，实现代码复用和依赖管理。\\n\\n### ESModule\\n\\n- 起源：2015 年随 ES6 (ECMAScript 2015) 正式发布，成为 JavaScript 语言标准的一部分。\\n- 应用场景：现代浏览器和前端构建工具（如 Webpack、Rollup）广泛支持，逐步成为主流。\\n- 核心目标：统一 JavaScript 的模块化标准，支持静态分析和异步加载。\\n\\n## 语法对比\\n\\n### CommonJS 语法\\n\\n导出模块：\\n\\n```js\\n// 导出单个值\\nmodule.exports = function add(a, b) {\\n  return a + b;\\n};\\n\\n// 导出多个值\\nexports.subtract = (a, b) => a - b;\\nexports.multiply = (a, b) => a * b;\\n```\\n\\n导入模块：\\n\\n```js// 导入整个模块\\nconst math = require('./math.js');\\nmath.add(2, 3); // 5\\n\\n// 解构导入\\nconst { subtract } = require('./math.js');\\nsubtract(5, 2); // 3\\n```\\n\\n### ESModule 语法\\n\\n导出模块：\\n\\n```js\\n// 命名导出\\nexport const PI = 3.14;\\nexport function circleArea(r) {\\n  return PI * r * r;\\n}\\n\\n// 默认导出\\nexport default class Calculator {\\n  /* ... */\\n}\\n```\\n\\n导入模块：\\n\\n```js\\n// 导入命名导出\\n// 12.56\\n// 导入默认导出\\nimport Calculator from './Calculator.js';\\nimport { PI, circleArea } from './math.js';\\n\\nconsole.log(circleArea(2)); // 12.56\\n\\nconst calc = new Calculator();\\n\\n// 动态导入（异步）\\nimport('./math.js').then((module) => {\\n  console.log(module.PI);\\n});\\n```\\n\\n## 核心差异\\n\\n### 标准\\n\\n一个是社区标准，一个是官方标准。\\n\\n### 加载方式\\n\\n| 特性     | CommonJS                   | ESModule                 |\\n| -------- | -------------------------- | ------------------------ |\\n| 加载时机 | 运行时同步加载（阻塞执行） | 编译时静态解析，异步加载 |\\n| 适用环境 | 服务器（Node.js）          | 浏览器和现代 Node.js     |\\n| 动态导入 | 支持 `require` 动态加载    | 支持 `import()` 动态加载 |\\n\\n示例：动态加载\\n\\n```js\\n// CommonJS\\nif (condition) {\\n  const module = require('./dynamic-module');\\n}\\n\\n// ESModule\\nif (condition) {\\n  import('./dynamic-module.js').then((module) => {\\n    /* ... */\\n  });\\n}\\n```\\n\\n### 模块作用域与值传递\\n\\n| 特性     | CommonJS                               | ESModule                            |\\n| -------- | -------------------------------------- | ----------------------------------- |\\n| 输出类型 | 输出值的拷贝（原始类型复制，对象引用） | 输出值的只读引用（类似 const 绑定） |\\n| 响应性   | 导出值变化后，导入方不受影响           | 导出值变化后，导入方同步更新        |\\n\\n示例：值传递差异\\n\\n```js\\n// counter.js (CommonJS)\\nlet count = 0;\\nmodule.exports = { count, increment: () => count++ };\\n\\n// main.js\\nconst { count, increment } = require('./counter');\\nincrement();\\nconsole.log(count); // 0（count 是原始值的拷贝）\\n\\n// counter.mjs (ESModule)\\nexport let count = 0;\\nexport const increment = () => count++;\\n\\n// main.mjs\\nimport { count, increment } from './counter.mjs';\\nincrement();\\nconsole.log(count); // 1（count 是引用）\\n```\\n\\n### 循环依赖处理\\n\\n| 特性     | CommonJS                         | ESModule                   |\\n| -------- | -------------------------------- | -------------------------- |\\n| 处理方式 | 可能获取不完整模块（已执行部分） | 通过静态分析确保引用完整性 |\\n\\n示例：循环依赖\\n\\n```js\\n// a.js (CommonJS)\\nconst b = require('./b');\\nconsole.log('a: b.value =', b.value);\\nmodule.exports = { value: 'a' };\\n\\n// b.js (CommonJS)\\nconst a = require('./a');\\nconsole.log('b: a.value =', a.value); // 输出 {}（a 未完成初始化）\\nmodule.exports = { value: 'b' };\\n\\n// 执行 node a.js 输出：\\n// b: a.value = {}\\n// a: b.value = b\\n\\n// a.mjs (ESModule)\\nimport { value } from './b.mjs';\\nconsole.log('a:', value);\\nexport const value = 'a';\\n\\n// b.mjs (ESModule)\\nimport { value } from './a.mjs';\\nconsole.log('b:', value); // 报错：无法在初始化前访问 'value'\\nexport const value = 'b';\\n\\n// 浏览器中执行会直接报错（ReferenceError）\\n```\\n\\n### 静态分析与 Tree Shaking\\n\\n- ESModule：支持静态分析，构建工具（如 Webpack）可进行 Tree Shaking，删除未使用的代码。\\n- CommonJS：动态特性导致无法可靠分析依赖，Tree Shaking 效果有限。\\n\\n示例：Tree Shaking\\n\\n```js\\n// main.js\\nimport { add } from './math.js';\\n\\n// math.js (ESModule)\\nexport function add(a, b) {\\n  return a + b;\\n}\\nexport function multiply(a, b) {\\n  return a * b;\\n}\\n\\nconsole.log(add(2, 3));\\n\\n// 构建后产物中不会包含 multiply 函数。\\n```\\n\\n### Top-Level Await\\n\\n- ESModule：支持在模块顶层使用 await。\\n- CommonJS：不支持，必须在函数内部使用。\\n\\n示例：Top-Level Await\\n\\n```js\\n// data.mjs (ESModule)\\nconst data = await fetch('https://api.example.com/data');\\nexport { data };\\n\\n// main.mjs\\nimport { data } from './data.mjs';\\nconsole.log(data);\\n```\\n\\n## 现代开发中的使用与兼容\\n\\n### Node.js 中的 ESModule 支持\\n\\n- 文件扩展名：使用 .mjs 或设置 package.json 中 \\\"type\\\": \\\"module\\\"。\\n- 互操作性：可通过 import 加载 CommonJS 模块，但部分特性（如动态 require）受限。\\n\\n示例：Node.js 配置\\n\\n```json\\n// package.json\\n{\\n  \\\"type\\\": \\\"module\\\", // 启用 ESModule\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"node index.mjs\\\"\\n  }\\n}\\n```\\n\\n### 构建工具中的转换\\n\\n- Babel：将 ESModule 转换为 CommonJS 以兼容旧环境。\\n- Webpack/Rollup：支持混合使用两种模块系统。\\n\\n示例：Babel 配置\\n\\n```json\\n// .babelrc\\n{\\n  \\\"presets\\\": [\\n    [\\\"@babel/preset-env\\\", { \\\"modules\\\": \\\"commonjs\\\" }] // 转译 ESM 为 CJS\\n  ]\\n}\\n```\\n\\n## 总结与选择建议\\n\\n| 场景                | 推荐模块系统            | 理由                        |\\n| ------------------- | ----------------------- | --------------------------- |\\n| Node.js 服务端      | CommonJS                | 内置支持，生态成熟          |\\n| 现代浏览器/前端项目 | ESModule                | 原生支持，Tree Shaking 优化 |\\n| 混合项目            | ESModule + 构建工具转换 | 兼容新旧环境，统一代码风格  |\\n\\n未来趋势：ESModule 逐渐成为主流，Node.js 也在增强对 ESM 的支持。建议新项目优先使用 ESModule，旧项目逐步迁移。\\n\",\"wordCount\":719},{\"id\":\"aded5fcc\",\"title\":\"Webpack 常见问题\",\"date\":\"2022-07-16\",\"tags\":[\"webpack\"],\"fileName\":\"Webpack 常见问题.md\",\"content\":\"\\n## Webpack5 和 Webpack4 之间重要的区别\\n\\n1. 性能改进：Webpack5 在构建速度和打包体积方面进行了一些优化。它引入了持久缓存，可以减少构建时间。此外，Webpack5 还引入了更好的树摇（tree shaking）算法，可以更好地优化打包体积。\\n2. 模块联邦（Module Federation）：这是 Webpack5 中最重要的新功能之一。模块联邦允许不同的应用程序共享模块，从而实现更好的代码复用和拆分。\\n   这对于构建大型的微服务架构非常有用。\\n3. 支持 WebAssembly：Webpack5 对 WebAssembly 提供了更好的支持。它可以直接导入和导出 WebAssembly 模块，并且可以通过配置进行优化。\\n4. 改进的缓存策略：Webpack5 引入了更好的缓存策略，可以更好地利用浏览器缓存。这可以减少用户在更新应用程序时需要下载的文件数量。\\n5. 改进的 Tree Shaking：Webpack5 引入了更好的 Tree Shaking 算法，可以更好地识别和删除未使用的代码。这可以进一步减少打包体积。\\n6. 改进的持久缓存：Webpack5 引入了更好的持久缓存策略，可以更好地利用缓存。这可以减少构建时间。\\n\\n## 安装\\n\\n```js\\nnpm init -y     // 初始化package.json\\nnpm install webpack webpack-cli --save-dev\\n\\nnpx webpack --watch     // 监听文件修改\\nnpx webpack-dev-server  // 以server的方式启动项目，不会打包物理文件，而是输出到内存\\n```\\n\\n## 生命周期钩子\\n\\n- beforeRun：在 Webpack 开始运行之前调用，可以在此处执行一些准备工作。\\n\\n- run：在 Webpack 开始运行时调用，可以在此处执行一些初始化操作。\\n\\n- beforeCompile：在 Webpack 开始编译之前调用，可以在此处执行一些准备工作。\\n\\n- compile：在 Webpack 开始编译时调用，可以在此处执行一些初始化操作。\\n\\n- make：在 Webpack 开始构建编译器时调用，可以在此处执行一些准备工作。\\n\\n- afterCompile：在 Webpack 完成编译之后调用，可以在此处执行一些后处理操作。\\n\\n- emit：在 Webpack 生成最终的资源之前调用，可以在此处执行一些额外的操作，如生成额外的文件。\\n\\n- afterEmit：在 Webpack 生成最终的资源之后调用，可以在此处执行一些后处理操作。\\n\\n- done：在 Webpack 完成构建之后调用，可以在此处执行一些清理工作。\\n\\n### 使用钩子\\n\\n```js\\nmodule.exports = {\\n  // ...\\n  plugins: [\\n    {\\n      apply: (compiler) => {\\n        compiler.hooks.beforeRun.tap('MyPlugin', () => {\\n          console.log('Before run');\\n        });\\n\\n        compiler.hooks.done.tap('MyPlugin', () => {\\n          console.log('Build done');\\n        });\\n      },\\n    },\\n  ],\\n};\\n\\n//在上述示例中，我们定义了一个自定义插件，并在其中使用了beforeRun和done两个生命周期钩子函数。\\n//在这些钩子函数中，我们可以执行一些自定义的操作，如输出日志信息。\\n```\\n\\n## Loader（转换器）\\n\\nWebpack Loader 在 Webpack 构建过程中的生命周期中的工作主要分为以下几个阶段：\\n\\n- 解析阶段：Webpack 会根据配置文件中的入口文件，递归解析所有的依赖模块。在这个阶段，Webpack 会根据文件的后缀名来确定使用哪个 Loader 来处理该文件。\\n\\n- 编译阶段：在这个阶段，Webpack 会将解析后的模块转换成 AST（抽象语法树），并且根据配置文件中的规则，将模块中的代码进行转换和处理。这个阶段是 Loader 的主要工作阶段，Loader 可以对模块进行各种处理，例如转换代码、添加额外的功能等。\\n\\n- 生成阶段：在这个阶段，Webpack 会根据处理后的模块生成最终的输出文件。输出文件的格式和路径可以通过配置文件进行配置。\\n\\n在这些阶段中，Loader 主要在编译阶段发挥作用。Loader 可以通过导出一个函数来定义自己的处理逻辑，这个函数接收一个参数，即待处理的模块的源代码，然后返回处理后的代码。\\n\\n### 常用 Loader\\n\\n以下是一些常用的 Webpack Loader：\\n\\n- babel-loader：用于将 ES6+ 的 JavaScript 代码转换为 ES5 代码，以便在旧版本浏览器中运行。\\n\\n- css-loader：用于解析 CSS 文件，并处理其中的 import 和 url() 等语法。\\n\\n- style-loader：将解析后的 CSS 代码以 `<style>` 标签的形式插入到 HTML 文件中。\\n\\n- file-loader：用于处理文件资源（如图片、字体等），并将其复制到输出目录中。\\n\\n- url-loader：类似于 file-loader，但可以根据文件大小将文件转换为 DataURL，以减少 HTTP 请求。\\n\\n- sass-loader：用于将 SASS/SCSS 代码转换为 CSS 代码。\\n\\n- less-loader：用于将 Less 代码转换为CSS代码。\\n\\n- postcss-loader：用于对 CSS 代码进行后处理，如自动添加浏览器前缀等。\\n\\n- vue-loader：用于解析和转换 Vue 单文件组件。\\n\\n- ts-loader：用于将 TypeScript 代码转换为 JavaScript 代码。\\n\\n### 自定义 Loader\\n\\n```js\\n// 核心代码：\\n\\nfunction clearConsoleLoader(source) {\\n  // 使用正则表达式匹配并替换console语句\\n  const modifiedSource = source.replace(/console\\\\.[a-z]+\\\\(.+\\\\);?/g, '');\\n\\n  return modifiedSource;\\n}\\n\\nmodule.exports = clearConsoleLoader;\\n\\n//使用\\nmodule.exports = {\\n  // ...\\n  module: {\\n    rules: [\\n      {\\n        test: /\\\\.js$/,\\n        exclude: /node_modules/,\\n        use: ['babel-loader', './path/to/clearConsoleLoader.js'],\\n      },\\n    ],\\n  },\\n};\\n```\\n\\n## Plugin（插件）\\n\\n### 工作原理\\n\\nWebpack Plugin 是用来扩展 Webpack 功能的工具，它可以在 Webpack 构建过程中的不同阶段执行一些额外的操作。\\n\\n插件的工作原理是通过在 Webpack 的构建过程中的不同生命周期中注册一些钩子函数，然后在对应的阶段执行这些钩子函数中的逻辑。\\n\\nWebpack 的构建过程中有以下几个生命周期：\\n\\n- 初始化阶段：在这个阶段，Webpack 会初始化配置参数，加载插件，并准备开始编译。\\n\\n- 编译阶段：在这个阶段，Webpack 会从入口文件开始递归解析所有的依赖模块，并将模块转换成 AST（抽象语法树），然后根据配置文件中的规则进行转换和处理。\\n\\n- 完成编译阶段：在这个阶段，Webpack 已经完成了所有的模块的转换和处理，并且生成了最终的输出文件。\\n\\n- 输出阶段：在这个阶段，Webpack 会将生成的输出文件写入到磁盘上。\\n\\n插件可以在这些生命周期中的任意阶段注册对应的钩子函数，并在钩子函数中执行一些额外的操作。\\n\\n### 常用 Plugin\\n\\n以下是一些常用的 Webpack 插件：\\n\\n- html-webpack-plugin：用于生成 HTML 文件，并自动将打包后的资源插入到 HTML 文件中。\\n\\n- mini-css-extract-plugin：用于将 CSS 代码提取成单独的文件，并生成一个 CSS 文件。\\n\\n- webpack-bundle-analyzer：用于分析打包后的文件结构，并生成一个可视化的报告。\\n\\n- webpack-dev-server：用于提供一个本地开发服务器，并自动刷新浏览器。\\n\\n- webpack-merge：用于合并多个 Webpack 配置文件。\\n\\n- webpack-plugin-replace：用于在打包过程中替换文件中的变量。\\n\\n- webpack-bundle-analyzer：用于分析打包后的文件结构，并生成一个可视化的报告。\\n\\n- webpack-dev-server：用于提供一个本地开发服务器，并自动刷新浏览器。\\n\\n- webpack-merge：用于合并多个 Webpack 配置文件。\\n\\n- webpack-plugin-replace：用于在打包过程中替换文件中的变量。\\n\\n### 自定义 Plugin\\n\\n```js\\nclass MyPlugin {\\n  apply(compiler) {\\n    // 注册初始化阶段的钩子函数\\n    compiler.hooks.initialize.tap('MyPlugin', () => {\\n      console.log('MyPlugin initialized');\\n    });\\n\\n    // 注册编译阶段的钩子函数\\n    compiler.hooks.compile.tap('MyPlugin', () => {\\n      console.log('MyPlugin compiling');\\n    });\\n  }\\n}\\n\\nmodule.exports = MyPlugin;\\n\\n// 使用\\n\\nconst MyPlugin = require('./my-plugin');\\n\\nmodule.exports = {\\n  // ...\\n  plugins: [\\n    new MyPlugin(),\\n  ],\\n};\\n```\\n\\n## 打包过程\\n\\n- 读取配置文件：Webpack 会首先读取配置文件，根据配置文件中的入口、出口等信息进行打包。\\n\\n- 解析模块依赖：Webpack 会从指定的入口文件开始递归解析所有的模块依赖，直到找到所有的模块。\\n\\n- 加载器处理：对于不同类型的模块，Webpack 会使用相应的加载器对其进行处理。例如，对于 JavaScript 模块，Webpack 会使用 Babel 加载器将 ES6 语法转换为 ES5 语法；对于 CSS 模块，Webpack 会使用 CSS 加载器将 CSS 代码打包进 JS 文件中。\\n\\n- 插件处理：在模块加载完成之后，Webpack 会执行一系列插件，用于完成一些额外的任务，例如生成 HTML 文件、提取 CSS 文件等。\\n\\n- 编译打包：Webpack 将经过处理的模块和插件生成最终的打包文件。通常情况下，Webpack 会生成一个或多个 JavaScript 文件，同时也可以生成其他类型的文件，例如 CSS、图片等。\\n\\n- 输出打包文件：Webpack 将生成的打包文件输出到指定的目录中。通常情况下，Webpack 会将打包文件输出到 dist 目录下。\\n\\n## 加速 Webpack 打包速度和减小打包体积的优化\\n\\n### 优化打包速度\\n\\n1. 优化 Webpack 配置：使用 Tree shaking 来减小打包体积，设置 Webpack 的 mode 为 production 以启用 UglifyJsPlugin 等插件进行代码压缩和优化。\\n\\n2. 使用 Webpack 的 code splitting 功能：将代码分割成较小的块，以便在需要时动态加载。\\n\\n3. 压缩图片和字体文件：使用 ImageMinWebpackPlugin 和 FontminWebpackPlugin 等插件来压缩图片和字体文件，减小打包体积。\\n\\n4. 缓存：启用 Webpack 的缓存功能，以便在修改代码时只重新打包修改的文件，而不是重新打包所有文件。\\n\\n5. 使用 DLLPlugin和DllReferencePlugin：将一些第三方库打包成单独的文件，以便在每次打包应用程序时不必重新打包这些库。\\n\\n6. 使用 HappyPack 插件：使用多线程来加速Webpack打包，以便同时处理多个任务。\\n\\n7. 使用 externals 选项：将一些不需要打包的库从打包中排除，以便减小打包体积。\\n\\n8. 使用 webpack-bundle-analyzer 插件：分析打包后的文件，以便找出冗余的代码和依赖关系，进行优化。\\n\\n这些技巧可以帮助优化Webpack的打包速度和打包体积。\\n\\n## Webpack 配置文件\\n\\n```js\\nconst path = require('path');\\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // 自动引入资源插件  npm install --save-dev html-webpack-plugin\\nconst MiniCssExtracPlugin = require('mini-css-extrac-plugin'); // css抽离\\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\\n//加载toml、yarm、json5数据资源 npm install toml yarm json5 -D\\nconst toml = require('toml');\\nconst yarm = require('yarm');\\nconst json5 = require('json5');\\n\\nmodule.exports = (env) => {\\n  return {\\n    // 手动分离公共文件，通过配置成对象的方式实现多入口代码分割\\n    // entry: {\\n    //  index:{\\n    //    import:\\\"./src/index.js\\\",\\n    //    dependOn: \\\"shared\\\"  // 抽离公共文件\\n    //  },\\n    //  shared: \\\"lodash\\\"      // 公共的js文件\\n    // },\\n    // 多入口\\n    // entry: {\\n    // \\t pageOne: './src/pageOne/index.js',\\n    //  \\tpageTwo: './src/pageTwo/index.js',\\n    //  \\tpageThree: './src/pageThree/index.js',\\n    // },\\n    // 单入口\\n    entry: {\\n      index: './src/index.js',\\n    },\\n    output: {\\n      filename: 'scripts/[name].[contenthash].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\\n      path: path.resolve(__dirname, './dist'),\\n      clean: true, // 清除上一次的垃圾文件\\n      assetModuleFilename: 'images/[contenthash][ext]', // 在images目录下，根据文件内容自动生成hash文件名\\n      publicPath: 'https://*****.com/', // 公共路径（cdn域名或者本地localhost）\\n    },\\n    mode: env.prodection ? 'prodection' : 'development', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\\n    devtool: 'cheap-module-source-map', // 真实报错文件指向,生产环境一般不开启sourcemap\\n    // 插件（非必要的，缺少也不影响项目打包）\\n    plugins: [\\n      new HtmlWebpackPlugin({\\n        template: './index.html', // 模板\\n        filename: 'app.html',\\n        inject: 'body', // script 存在的位置\\n        hash: true, // 解决缓存\\n        minify: {\\n          removeAttributeQuotes: true, // 压缩，去掉引号\\n        },\\n      }),\\n      new MiniCssExtracPlugin({\\n        filename: 'style/[contenthash].css',\\n      }),\\n    ],\\n    devServer: {\\n      static: './dist', // 监听根目录文件变化，自动刷新页面插件 npm install --save-dev webpack-dev-server\\n      //反向代理\\n      proxy: {\\n        '/ajax': {\\n          target: 'https:**********',\\n          ws: true,\\n          changeOrigin: true,\\n        },\\n      },\\n    },\\n    // 模块（必要的，缺少影响项目打包）\\n    module: {\\n      rules: [\\n        //资源模块类型我们称之为Asset Modules Type，总共有四种，来代替loader，分别是：\\n        // asset/resource：发送一个单独的文件并导出URL，替代file-loader\\n        // asset/inline：导出一个资源的data URI(base64)，替代url-loader\\n        // asset/source：导出资源的源代码，之前通过使用raw-loader实现\\n        // asset：介于asset/resource和asset/inline之间， 之前通过url-loader+limit属性实现。\\n        {\\n          test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则图片文件\\n          type: 'asset',\\n          generator: {\\n            filename: 'images/[contenthash][ext]', // 优先级高于 assetModuleFilename\\n          },\\n        },\\n        {\\n          // 支持less\\n          // npm install style-loader css-loader less-loader less --save-dev\\n          // 抽离 npm install mini-css-extrac-plugin  --save-dev   webpack5环境下构建的插件\\n          test: /\\\\.(le|c)ss$/, // .less and .css\\n          use: [MiniCssExtracPlugin.loader, /* \\\"style-loader\\\", */ 'css-loader', 'less-loader'],\\n        },\\n        {\\n          test: /\\\\.(woff|woff2|eot|ttf|oft)$/, // 正则字体文件\\n          type: 'asset/resource',\\n        },\\n        //加载csv、xml数据资源 npm install csv-loader xml-loader -D\\n        {\\n          test: /\\\\.(csv|tsv)$/,\\n          use: 'csv-loader',\\n        },\\n        {\\n          test: /\\\\.xml$/,\\n          use: 'xml-loader',\\n        },\\n        //加载toml、yarm、json5数据资源\\n        {\\n          test: /\\\\.toml$/,\\n          type: 'json',\\n          parser: {\\n            parse: toml.parse,\\n          },\\n        },\\n        {\\n          test: /\\\\.yarm$/,\\n          type: 'json',\\n          parser: {\\n            parse: yarm.parse,\\n          },\\n        },\\n        {\\n          test: /\\\\.json5$/,\\n          type: 'json',\\n          parser: {\\n            parse: json5.parse,\\n          },\\n        },\\n        // loader工具 支持数组方式链式调用，数组靠后的元素先执行\\n        {\\n          // 压缩图片\\n          //图片小于一定大小使用base64 否则使用file-loader产生真实图片 npm install url-loader --save-dev\\n          test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则\\n          use: [\\n            {\\n              loader: 'url-loader',\\n              options: {\\n                limit: 5000, //小于限定使用base64\\n                name: 'home/images/[name].[hash:8].[ext]',\\n                publicPath: `../../`,\\n                esModule: false,\\n              },\\n            },\\n          ],\\n        },\\n        // 使用babel-loader npm install -D babel-loader @babel/core @babel/preset-env\\n        // regeneratorRuntime是webpack打包生成的全局辅助函数，由babel生成，用于兼容 async/await 的语法\\n        // npm install --save @babel/runtime\\n        // npm install --save-dev @babel/plugin-transform-runtime\\n        {\\n          test: /\\\\.js$/,\\n          exclude: /node_modules/, // *业务代码里面可能会引入node_modules外部js，这些js不需要babel-loader编译，因此需要排除掉\\n          use: {\\n            loader: 'babel-loader', // *引入babel-loader\\n            options: {\\n              presets: ['@babel/preset-env'], // *引入预设\\n              plugins: [\\n                [\\n                  '@babel/plugin-transform-runtime', // *配置插件信息\\n                ],\\n              ],\\n            },\\n          },\\n        },\\n      ],\\n    },\\n    optimization: {\\n      minimizer: [new CssMinimizerPlugin(), new TerserPlugin()], //代码压缩 mode改为 production\\n      splitChunks: {\\n        // 缓存\\n        cacheGroups: {\\n          vendor: {\\n            test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n            name: 'vendors',\\n            chunks: 'all', // 自动重复代码抽离\\n          },\\n        },\\n      },\\n    },\\n  };\\n};\\n```\\n\\n## Webpack 配置文件拆分\\n\\n### webpack.config.common.js\\n\\nwebpack.config.common.js 文件用于公共环境配置\\n\\n```js\\nconst path = require('path');\\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // 自动引入资源插件  npm install --save-dev html-webpack-plugin\\nconst MiniCssExtracPlugin = require('mini-css-extrac-plugin'); // css抽离\\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\\n//加载toml、yarm、json5数据资源 npm install toml yarm json5 -D\\nconst toml = require('toml');\\nconst yarm = require('yarm');\\nconst json5 = require('json5');\\n\\nmodule.exports = {\\n  entry: {\\n    index: './src/index.js',\\n  },\\n  output: {\\n    path: path.resolve(__dirname, './dist'),\\n    clean: true, // 清除上一次的垃圾文件\\n    assetModuleFilename: 'images/[contenthash][ext]', // 在images目录下，根据文件内容自动生成hash文件名\\n  },\\n  // 插件（非必要的，缺少也不影响项目打包）\\n  plugins: [\\n    new HtmlWebpackPlugin({\\n      template: './index.html', // 模板\\n      filename: 'app.html',\\n      inject: 'body', // script 存在的位置\\n      hash: true, // 解决缓存\\n      minify: {\\n        removeAttributeQuotes: true, // 压缩，去掉引号\\n      },\\n    }),\\n    new MiniCssExtracPlugin({\\n      filename: 'style/[contenthash].css',\\n    }),\\n  ],\\n  // 模块（必要的，缺少影响项目打包）\\n  module: {\\n    rules: [\\n      //资源模块类型我们称之为Asset Modules Type，总共有四种，来代替loader，分别是：\\n      // asset/resource：发送一个单独的文件并导出URL，替代file-loader\\n      // asset/inline：导出一个资源的data URI(base64)，替代url-loader\\n      // asset/source：导出资源的源代码，之前通过使用raw-loader实现\\n      // asset：介于asset/resource和asset/inline之间， 之前通过url-loader+limit属性实现。\\n      {\\n        test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则图片文件\\n        type: 'asset',\\n        generator: {\\n          filename: 'images/[contenthash][ext]', // 优先级高于 assetModuleFilename\\n        },\\n      },\\n      {\\n        // 支持less\\n        // npm install style-loader css-loader less-loader less --save-dev\\n        // 抽离 npm install mini-css-extrac-plugin  --save-dev   webpack5环境下构建的插件\\n        test: /\\\\.(le|c)ss$/, // .less and .css\\n        use: [MiniCssExtracPlugin.loader, /* \\\"style-loader\\\", */ 'css-loader', 'less-loader'],\\n      },\\n      {\\n        test: /\\\\.(woff|woff2|eot|ttf|oft)$/, // 正则字体文件\\n        type: 'asset/resource',\\n      },\\n      //加载csv、xml数据资源 npm install csv-loader xml-loader -D\\n      {\\n        test: /\\\\.(csv|tsv)$/,\\n        use: 'csv-loader',\\n      },\\n      {\\n        test: /\\\\.xml$/,\\n        use: 'xml-loader',\\n      },\\n      //加载toml、yarm、json5数据资源\\n      {\\n        test: /\\\\.toml$/,\\n        type: 'json',\\n        parser: {\\n          parse: toml.parse,\\n        },\\n      },\\n      {\\n        test: /\\\\.yarm$/,\\n        type: 'json',\\n        parser: {\\n          parse: yarm.parse,\\n        },\\n      },\\n      {\\n        test: /\\\\.json5$/,\\n        type: 'json',\\n        parser: {\\n          parse: json5.parse,\\n        },\\n      },\\n      // loader工具 支持数组方式链式调用，数组靠后的元素先执行\\n      {\\n        // 压缩图片\\n        //图片小于一定大小使用base64 否则使用file-loader产生真实图片 npm install url-loader --save-dev\\n        test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则\\n        use: [\\n          {\\n            loader: 'url-loader',\\n            options: {\\n              limit: 5000, //小于限定使用base64\\n              name: 'home/images/[name].[hash:8].[ext]',\\n              publicPath: `../../`,\\n              esModule: false,\\n            },\\n          },\\n        ],\\n      },\\n      // 使用babel-loader npm install -D babel-loader @babel/core @babel/preset-env\\n      // regeneratorRuntime是webpack打包生成的全局辅助函数，由babel生成，用于兼容 async/await 的语法\\n      // npm install --save @babel/runtime\\n      // npm install --save-dev @babel/plugin-transform-runtime\\n      {\\n        test: /\\\\.js$/,\\n        exclude: /node_modules/, // *业务代码里面可能会引入node_modules外部js，这些js不需要babel-loader编译，因此需要排除掉\\n        use: {\\n          loader: 'babel-loader', // *引入babel-loader\\n          options: {\\n            presets: ['@babel/preset-env'], // *引入预设\\n            plugins: [\\n              [\\n                '@babel/plugin-transform-runtime', // *配置插件信息\\n              ],\\n            ],\\n          },\\n        },\\n      },\\n    ],\\n  },\\n  optimization: {\\n    splitChunks: {\\n      // 缓存\\n      cacheGroups: {\\n        vendor: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          name: 'vendors',\\n          chunks: 'all', // 自动重复代码抽离\\n        },\\n      },\\n    },\\n  },\\n};\\n```\\n\\n### webpack.config.dev.js\\n\\nwebpack.config.dev.js 文件用于开发环境配置，`npx webpack -c ./webpack.config.dev.js`\\n\\n```js\\nmodule.exports = {\\n  output: {\\n    filename: 'scripts/[name].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\\n  },\\n  mode: 'development', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\\n  devtool: 'cheap-module-source-map', // 真实报错文件指向,生产\\n  devServer: {\\n    static: './dist', // 监听根目录文件变化，自动刷新页面插件 npm install --save-dev webpack-dev-server\\n    //反向代理\\n    proxy: {\\n      '/ajax': {\\n        target: 'https:**********',\\n        ws: true,\\n        changeOrigin: true,\\n      },\\n    },\\n  },\\n};\\n```\\n\\n### webpack.config.prod.js\\n\\nwebpack.config.prod.js 文件用于生产环境配置，`npx webpack -c ./webpack.config.prod.js`\\n\\n```js\\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\\n\\nmodule.exports = {\\n  output: {\\n    filename: 'scripts/[name].[contenthash].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\\n    publicPath: 'https://*****.com/', // 公共路径（cdn域名或者本地localhost）\\n  },\\n  mode: 'prodection', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\\n  optimization: {\\n    minimizer: [new CssMinimizerPlugin(), new TerserPlugin()], //代码压缩 mode改为 production\\n  },\\n  performance: {\\n    hints: false, // 关闭性能提示\\n  },\\n};\\n```\\n\\n### webpack.config.js\\n\\n总的配置文件，根据环境变量来决定使用哪个配置文件，`npx webpack -c ./webpack.config.js --env development`\\n\\n```js\\nconst { merge } = require('webpack-merge'); // npm install webpack-merge -D\\nconst commonConfig = require('./webpack.config.common');\\nconst productionConfig = require('./webpack.config.prod');\\nconst developmentConfig = require('./webpack.config.dev');\\n\\nmodule.exports = (env) => {\\n  switch (true) {\\n    case env.development:\\n      return merge(commonConfig, developmentConfig);\\n    case env.production:\\n      return merge(commonConfig, productionConfig);\\n      defult: return new Error();\\n  }\\n};\\n```\\n\\n## 封装 Webpack 自定义插件\\n\\n```js\\n1. 创建一个 JavaScript 文件，并导出一个函数。这个函数将作为你的插件的构造函数。\\n\\n2. 在函数中定义一个 apply 方法，该方法接收一个 compiler 参数。这个 compiler 对象是 Webpack 的核心，它包含了 Webpack 的所有配置和工作流程。\\n\\n3. 在 apply 方法中，可以通过 compiler.hooks 对象访问 Webpack 的生命周期钩子。通过这些钩子，你可以在 Webpack 运行的不同阶段执行自定义代码。\\n\\n4. 实现你的插件逻辑，例如在特定的 Webpack 钩子上注册回调函数，向编译器添加自定义插件等。\\n\\n5. 将你的插件打包成一个 npm 模块，并在项目中引入和使用它。\\n\\n下面是一个简单的 Webpack 插件示例：\\n\\nconst MyPlugin = function() {};\\n\\nMyPlugin.prototype.apply = function(compiler) {\\n  compiler.hooks.done.tap('MyPlugin', stats => {\\n    console.log('Webpack is done!');\\n  });\\n};\\n\\nmodule.exports = MyPlugin;\\n\\n在这个示例中，我们定义了一个 MyPlugin 插件，它在 Webpack 编译完成后输出一条信息。\\n在 apply 方法中，我们使用 compiler.hooks.done 钩子注册了一个回调函数，在编译完成后输出一条消息。\\n\\n要使用这个插件，你需要将它打包成一个 npm 模块，并在 Webpack 配置文件中引入和使用它：\\n\\nconst MyPlugin = require('my-plugin');\\n\\nmodule.exports = {\\n  plugins: [\\n    new MyPlugin()\\n  ]\\n};\\n\\n这个示例中，我们在 Webpack 配置文件中引入了 MyPlugin 插件，并将它作为插件数组的一项传递给 plugins 选项。\\n这样，当 Webpack 编译时，MyPlugin 将会被启用并执行它的逻辑。\\n```\\n\",\"wordCount\":2361},{\"id\":\"0d76ebdd\",\"title\":\"前端实现大文件上传与下载的最佳实践\",\"date\":\"2022-05-23\",\"tags\":[\"react\",\"业务场景\"],\"fileName\":\"前端实现大文件上传与下载的最佳实践.md\",\"content\":\"\\n## 背景介绍\\n\\n在Web应用开发中，处理大文件的上传和下载是一个常见而棘手的问题。传统的文件传输方式在处理大文件时往往会遇到性能瓶颈、超时错误和糟糕的用户体验。本文将深入探讨前端实现大文件上传与下载的最佳实践，包括文件切片、断点续传、进度监控等关键技术。\\n\\n## 一、大文件上传的挑战\\n\\n传统文件上传面临的主要问题：\\n\\n1. 请求超时：大文件上传耗时长，容易触发服务器或浏览器的超时限制\\n2. 内存占用：一次性加载大文件会占用大量内存\\n3. 上传失败无法恢复：网络波动导致上传失败时需要重新上传整个文件\\n4. 用户体验差：缺乏进度反馈，用户无法了解上传状态\\n\\n## 二、文件切片上传技术\\n\\n### 2.1 基本原理\\n\\n文件切片上传的核心思想是将大文件分割成多个小块（切片），分别上传这些切片，最后在服务器端合并。这种方式有以下优势：\\n\\n- 单个请求体积小，不易超时\\n- 可以并发上传多个切片，提高上传速度\\n- 支持断点续传，提升用户体验\\n- 便于实现上传进度的精确计算\\n\\n### 2.2 前端实现\\n\\n#### 2.2.1 文件切片\\n\\n```js\\n/**\\n * 将文件切片\\n * @param {File} file - 要上传的文件\\n * @param {number} chunkSize - 切片大小(bytes)\\n * @returns {Array} 切片数组\\n */\\nfunction createFileChunks(file, chunkSize = 1024 * 1024 * 5) {\\n  const chunks = [];\\n  let cur = 0;\\n  while (cur < file.size) {\\n    chunks.push(file.slice(cur, cur + chunkSize));\\n    cur += chunkSize;\\n  }\\n  return chunks;\\n}\\n```\\n\\n#### 2.2.2 计算文件唯一标识\\n\\n为了实现断点续传，需要为每个文件生成唯一标识：\\n\\n```js\\n/**\\n * 计算文件的MD5值作为唯一标识\\n * @param {File} file - 文件对象\\n * @returns {Promise<string>} MD5哈希值\\n */\\nasync function calculateFileMD5(file) {\\n  return new Promise((resolve, reject) => {\\n    const reader = new FileReader();\\n    reader.readAsArrayBuffer(file);\\n    reader.onload = (e) => {\\n      const buffer = e.target.result;\\n      const spark = new SparkMD5.ArrayBuffer();\\n      spark.append(buffer);\\n      const md5 = spark.end();\\n      resolve(md5);\\n    };\\n    reader.onerror = reject;\\n  });\\n}\\n```\\n\\n#### 2.2.3 上传切片\\n\\n```js\\n/**\\n * 上传单个切片\\n * @param {Blob} chunk - 文件切片\\n * @param {number} index - 切片索引\\n * @param {string} fileId - 文件唯一标识\\n * @param {string} fileName - 文件名\\n * @returns {Promise}\\n */\\nasync function uploadChunk(chunk, index, fileId, fileName) {\\n  const formData = new FormData();\\n  formData.append('chunk', chunk);\\n  formData.append('index', index);\\n  formData.append('fileId', fileId);\\n  formData.append('fileName', fileName);\\n\\n  return axios.post('/upload/chunk', formData, {\\n    headers: {\\n      'Content-Type': 'multipart/form-data',\\n    },\\n    // 上传进度监控\\n    onUploadProgress: (e) => {\\n      // 可以在这里更新每个切片的上传进度\\n    },\\n  });\\n}\\n```\\n\\n#### 2.2.4 并发控制\\n\\n为了避免过多的并发请求导致浏览器或服务器崩溃，需要控制并发数：\\n\\n```js\\n/**\\n * 控制并发上传\\n * @param {Array} chunks - 切片数组\\n * @param {string} fileId - 文件唯一标识\\n * @param {string} fileName - 文件名\\n * @param {number} concurrency - 并发数\\n * @returns {Promise}\\n */\\nasync function uploadChunksWithConcurrency(chunks, fileId, fileName, concurrency = 3) {\\n  const pool = []; // 并发池\\n  const results = []; // 存储所有上传结果\\n\\n  for (let i = 0; i < chunks.length; i++) {\\n    const chunk = chunks[i];\\n\\n    // 创建上传任务\\n    const task = async () => {\\n      const result = await uploadChunk(chunk, i, fileId, fileName);\\n      results[i] = result;\\n      return result;\\n    };\\n\\n    // 将任务加入并发池\\n    const promise = task();\\n    pool.push(promise);\\n\\n    // 当并发数达到限制时，等待一个任务完成\\n    if (pool.length >= concurrency) {\\n      await Promise.race(pool);\\n      // 移除已完成的任务\\n      const index = await Promise.race(\\n        pool.map(async (p, index) => {\\n          try {\\n            await p;\\n            return index;\\n          } catch (e) {\\n            return -1;\\n          }\\n        })\\n      );\\n      if (index !== -1) {\\n        pool.splice(index, 1);\\n      }\\n    }\\n  }\\n\\n  // 等待所有任务完成\\n  await Promise.all(pool);\\n  return results;\\n}\\n```\\n\\n#### 2.2.5 合并请求\\n\\n所有切片上传完成后，通知服务器合并文件：\\n\\n```js\\n/**\\n * 请求合并切片\\n * @param {string} fileId - 文件唯一标识\\n * @param {string} fileName - 文件名\\n * @param {number} totalChunks - 切片总数\\n * @returns {Promise}\\n */\\nasync function mergeChunks(fileId, fileName, totalChunks) {\\n  return axios.post('/upload/merge', {\\n    fileId,\\n    fileName,\\n    totalChunks,\\n  });\\n}\\n```\\n\\n#### 2.2.6 断点续传实现\\n\\n断点续传需要记录已上传的切片，在上传前检查：\\n\\n```js\\n/**\\n * 获取已上传的切片\\n * @param {string} fileId - 文件唯一标识\\n * @returns {Promise<Array>} 已上传的切片索引数组\\n */\\nasync function getUploadedChunks(fileId) {\\n  const response = await axios.get(`/upload/chunks?fileId=${fileId}`);\\n  return response.data.uploadedChunks || [];\\n}\\n\\n/**\\n * 实现断点续传\\n * @param {File} file - 要上传的文件\\n */\\nasync function resumableUpload(file) {\\n  // 计算文件MD5作为唯一标识\\n  const fileId = await calculateFileMD5(file);\\n\\n  // 获取文件已上传的切片\\n  const uploadedChunks = await getUploadedChunks(fileId);\\n\\n  // 切割文件\\n  const chunks = createFileChunks(file);\\n\\n  // 过滤出未上传的切片\\n  const remainingChunks = chunks.filter((_, index) => !uploadedChunks.includes(index));\\n\\n  // 上传剩余切片\\n  await uploadChunksWithConcurrency(remainingChunks, fileId, file.name);\\n\\n  // 合并文件\\n  await mergeChunks(fileId, file.name, chunks.length);\\n\\n  return { success: true, fileId };\\n}\\n```\\n\\n### 2.3 完整的 React 组件示例\\n\\n下面是一个完整的React组件，实现了大文件切片上传、断点续传和进度显示：\\n\\n```jsx\\nimport React, { useCallback, useState } from 'react';\\n\\nimport axios from 'axios';\\nimport SparkMD5 from 'spark-md5';\\n\\nconst FileUploader = () => {\\n  const [selectedFile, setSelectedFile] = useState(null);\\n  const [uploadProgress, setUploadProgress] = useState(0);\\n  const [uploading, setUploading] = useState(false);\\n  const [uploadedChunks, setUploadedChunks] = useState([]);\\n\\n  // 文件选择处理\\n  const handleFileChange = (e) => {\\n    const file = e.target.files[0];\\n    if (file) {\\n      setSelectedFile(file);\\n      setUploadProgress(0);\\n    }\\n  };\\n\\n  // 计算文件MD5\\n  const calculateFileMD5 = useCallback(async (file) => {\\n    return new Promise((resolve, reject) => {\\n      const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;\\n      const chunkSize = 2097152; // 2MB\\n      const chunks = Math.ceil(file.size / chunkSize);\\n      let currentChunk = 0;\\n      const spark = new SparkMD5.ArrayBuffer();\\n      const fileReader = new FileReader();\\n\\n      fileReader.onload = (e) => {\\n        spark.append(e.target.result);\\n        currentChunk++;\\n\\n        if (currentChunk < chunks) {\\n          loadNext();\\n        } else {\\n          const md5 = spark.end();\\n          resolve(md5);\\n        }\\n      };\\n\\n      fileReader.onerror = reject;\\n\\n      function loadNext() {\\n        const start = currentChunk * chunkSize;\\n        const end = Math.min(start + chunkSize, file.size);\\n        fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));\\n      }\\n\\n      loadNext();\\n    });\\n  }, []);\\n\\n  // 创建文件切片\\n  const createFileChunks = useCallback((file, chunkSize = 1024 * 1024 * 5) => {\\n    const chunks = [];\\n    let cur = 0;\\n    while (cur < file.size) {\\n      chunks.push(file.slice(cur, cur + chunkSize));\\n      cur += chunkSize;\\n    }\\n    return chunks;\\n  }, []);\\n\\n  // 获取已上传的切片\\n  const getUploadedChunks = useCallback(async (fileId) => {\\n    try {\\n      const response = await axios.get(`/upload/chunks?fileId=${fileId}`);\\n      return response.data.uploadedChunks || [];\\n    } catch (error) {\\n      console.error('获取已上传切片失败:', error);\\n      return [];\\n    }\\n  }, []);\\n\\n  // 上传单个切片\\n  const uploadChunk = useCallback(\\n    async (chunk, index, fileId, fileName, totalChunks) => {\\n      const formData = new FormData();\\n      formData.append('chunk', chunk);\\n      formData.append('index', index);\\n      formData.append('fileId', fileId);\\n      formData.append('fileName', fileName);\\n      formData.append('totalChunks', totalChunks);\\n\\n      try {\\n        await axios.post('/upload/chunk', formData, {\\n          headers: {\\n            'Content-Type': 'multipart/form-data',\\n          },\\n        });\\n\\n        // 更新已上传的切片\\n        setUploadedChunks((prev) => [...prev, index]);\\n\\n        // 更新总进度\\n        setUploadProgress((prevProgress) => {\\n          const newProgress = Math.round(((uploadedChunks.length + 1) / totalChunks) * 100);\\n          return Math.max(prevProgress, newProgress);\\n        });\\n\\n        return { success: true, index };\\n      } catch (error) {\\n        console.error(`切片 ${index} 上传失败:`, error);\\n        return { success: false, index };\\n      }\\n    },\\n    [uploadedChunks]\\n  );\\n\\n  // 合并切片\\n  const mergeChunks = useCallback(async (fileId, fileName, totalChunks) => {\\n    try {\\n      await axios.post('/upload/merge', {\\n        fileId,\\n        fileName,\\n        totalChunks,\\n      });\\n      return true;\\n    } catch (error) {\\n      console.error('合并切片失败:', error);\\n      return false;\\n    }\\n  }, []);\\n\\n  // 开始上传\\n  const startUpload = useCallback(async () => {\\n    if (!selectedFile) {\\n      alert('请先选择文件');\\n      return;\\n    }\\n\\n    setUploading(true);\\n\\n    try {\\n      // 计算文件MD5\\n      const fileId = await calculateFileMD5(selectedFile);\\n\\n      // 获取已上传的切片\\n      const uploadedChunksData = await getUploadedChunks(fileId);\\n      setUploadedChunks(uploadedChunksData);\\n\\n      // 创建切片\\n      const chunks = createFileChunks(selectedFile);\\n      const totalChunks = chunks.length;\\n\\n      // 更新初始进度\\n      setUploadProgress(Math.round((uploadedChunksData.length / totalChunks) * 100));\\n\\n      // 上传未完成的切片\\n      const uploadPromises = [];\\n\\n      for (let i = 0; i < totalChunks; i++) {\\n        if (!uploadedChunksData.includes(i)) {\\n          uploadPromises.push(uploadChunk(chunks[i], i, fileId, selectedFile.name, totalChunks));\\n        }\\n      }\\n\\n      // 等待所有切片上传完成\\n      await Promise.all(uploadPromises);\\n\\n      // 合并切片\\n      const mergeResult = await mergeChunks(fileId, selectedFile.name, totalChunks);\\n\\n      if (mergeResult) {\\n        alert('文件上传成功!');\\n        setUploadProgress(100);\\n      } else {\\n        alert('文件合并失败，请重试');\\n      }\\n    } catch (error) {\\n      console.error('上传过程中出错:', error);\\n      alert('上传失败，请重试');\\n    } finally {\\n      setUploading(false);\\n    }\\n  }, [selectedFile, calculateFileMD5, getUploadedChunks, createFileChunks, uploadChunk, mergeChunks]);\\n\\n  // 暂停上传\\n  const pauseUpload = useCallback(() => {\\n    // 实际实现中可以取消正在进行的请求\\n    setUploading(false);\\n    alert('上传已暂停，您可以稍后继续');\\n  }, []);\\n\\n  return (\\n    <div className=\\\"file-uploader\\\">\\n      <h2>大文件分片上传示例</h2>\\n\\n      <div className=\\\"upload-container\\\">\\n        <input type=\\\"file\\\" onChange={handleFileChange} disabled={uploading} />\\n\\n        {selectedFile && (\\n          <div className=\\\"file-info\\\">\\n            <p>文件名: {selectedFile.name}</p>\\n            <p>文件大小: {(selectedFile.size / 1024 / 1024).toFixed(2)} MB</p>\\n          </div>\\n        )}\\n\\n        <div className=\\\"progress-container\\\">\\n          <div className=\\\"progress-bar\\\" style={{ width: `${uploadProgress}%` }}></div>\\n          <span className=\\\"progress-text\\\">{uploadProgress}%</span>\\n        </div>\\n\\n        <div className=\\\"button-group\\\">\\n          <button onClick={startUpload} disabled={!selectedFile || uploading}>\\n            {uploadedChunks.length > 0 ? '继续上传' : '开始上传'}\\n          </button>\\n\\n          {uploading && <button onClick={pauseUpload}>暂停上传</button>}\\n        </div>\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport default FileUploader;\\n```\\n\\n## 三、大文件下载技术\\n\\n### 3.1 传统下载的问题\\n\\n传统的文件下载方式存在以下问题：\\n\\n1. 无法显示下载进度：用户无法了解下载状态\\n2. 下载中断无法恢复：网络波动导致下载失败时需要重新下载\\n3. 大文件下载耗时长：用户体验差\\n\\n### 3.2 流式下载与切片下载\\n\\n#### 3.2.1 使用 Blob 和 URL.createObjectURL\\n\\n```js\\n/**\\n * 基本的文件下载函数\\n * @param {string} url - 文件下载地址\\n * @param {string} filename - 保存的文件名\\n */\\nasync function downloadFile(url, filename) {\\n  try {\\n    const response = await fetch(url);\\n    const blob = await response.blob();\\n    const objectUrl = URL.createObjectURL(blob);\\n\\n    const link = document.createElement('a');\\n    link.href = objectUrl;\\n    link.download = filename;\\n    document.body.appendChild(link);\\n    link.click();\\n\\n    // 清理\\n    document.body.removeChild(link);\\n    URL.revokeObjectURL(objectUrl);\\n  } catch (error) {\\n    console.error('下载失败:', error);\\n  }\\n}\\n```\\n\\n#### 3.3.2 带进度监控的下载\\n\\n```js\\n/**\\n * 带进度监控的文件下载\\n * @param {string} url - 文件下载地址\\n * @param {string} filename - 保存的文件名\\n * @param {Function} onProgress - 进度回调函数\\n */\\nasync function downloadFileWithProgress(url, filename, onProgress) {\\n  try {\\n    const response = await fetch(url);\\n\\n    if (!response.ok) {\\n      throw new Error(`HTTP error! status: ${response.status}`);\\n    }\\n\\n    // 获取文件大小\\n    const contentLength = response.headers.get('content-length');\\n    const total = parseInt(contentLength, 10);\\n\\n    // 创建可读流\\n    const reader = response.body.getReader();\\n\\n    // 接收数据块\\n    let receivedLength = 0;\\n    const chunks = [];\\n\\n    while (true) {\\n      const { done, value } = await reader.read();\\n\\n      if (done) {\\n        break;\\n      }\\n\\n      chunks.push(value);\\n      receivedLength += value.length;\\n\\n      // 报告进度\\n      if (onProgress) {\\n        onProgress(receivedLength, total);\\n      }\\n    }\\n\\n    // 合并数据块\\n    const chunksAll = new Uint8Array(receivedLength);\\n    let position = 0;\\n    for (const chunk of chunks) {\\n      chunksAll.set(chunk, position);\\n      position += chunk.length;\\n    }\\n\\n    // 创建Blob并下载\\n    const blob = new Blob([chunksAll]);\\n    const objectUrl = URL.createObjectURL(blob);\\n\\n    const link = document.createElement('a');\\n    link.href = objectUrl;\\n    link.download = filename;\\n    document.body.appendChild(link);\\n    link.click();\\n\\n    // 清理\\n    document.body.removeChild(link);\\n    URL.revokeObjectURL(objectUrl);\\n  } catch (error) {\\n    console.error('下载失败:', error);\\n  }\\n}\\n```\\n\\n#### 3.3.3 切片下载\\n\\n对于超大文件，可以实现切片下载：\\n\\n```js\\n/**\\n * 切片下载大文件\\n * @param {string} url - 文件基础URL\\n * @param {string} filename - 保存的文件名\\n * @param {number} chunkSize - 切片大小(bytes)\\n * @param {number} totalSize - 文件总大小\\n * @param {Function} onProgress - 进度回调函数\\n */\\nasync function downloadLargeFile(url, filename, chunkSize, totalSize, onProgress) {\\n  // 计算切片数量\\n  const chunks = Math.ceil(totalSize / chunkSize);\\n  const chunksData = [];\\n\\n  // 获取本地存储中的下载进度\\n  const storageKey = `download_${url}_${filename}`;\\n  const storedData = localStorage.getItem(storageKey);\\n  let downloadedChunks = [];\\n\\n  if (storedData) {\\n    try {\\n      const parsed = JSON.parse(storedData);\\n      downloadedChunks = parsed.downloadedChunks || [];\\n      chunksData.push(...(parsed.chunksData || []));\\n    } catch (e) {\\n      console.error('解析存储的下载进度失败:', e);\\n      downloadedChunks = [];\\n    }\\n  }\\n\\n  // 计算已下载的大小\\n  let downloadedSize = downloadedChunks.length * chunkSize;\\n  if (onProgress) {\\n    onProgress(downloadedSize, totalSize);\\n  }\\n\\n  // 下载未完成的切片\\n  for (let i = 0; i < chunks; i++) {\\n    // 跳过已下载的切片\\n    if (downloadedChunks.includes(i)) {\\n      continue;\\n    }\\n\\n    const start = i * chunkSize;\\n    const end = Math.min(start + chunkSize - 1, totalSize - 1);\\n\\n    try {\\n      const response = await fetch(url, {\\n        headers: {\\n          Range: `bytes=${start}-${end}`,\\n        },\\n      });\\n\\n      if (!response.ok && response.status !== 206) {\\n        throw new Error(`HTTP error! status: ${response.status}`);\\n      }\\n\\n      const buffer = await response.arrayBuffer();\\n      chunksData[i] = new Uint8Array(buffer);\\n\\n      // 更新下载进度\\n      downloadedChunks.push(i);\\n      downloadedSize += buffer.byteLength;\\n\\n      // 保存下载进度到本地存储\\n      localStorage.setItem(\\n        storageKey,\\n        JSON.stringify({\\n          downloadedChunks,\\n          totalChunks: chunks,\\n        })\\n      );\\n\\n      // 报告进度\\n      if (onProgress) {\\n        onProgress(downloadedSize, totalSize);\\n      }\\n    } catch (error) {\\n      console.error(`下载切片 ${i} 失败:`, error);\\n      // 继续下载下一个切片，不中断整个过程\\n    }\\n  }\\n\\n  // 合并所有切片\\n  const completeFile = new Uint8Array(totalSize);\\n  let position = 0;\\n\\n  for (let i = 0; i < chunks; i++) {\\n    const chunk = chunksData[i];\\n    completeFile.set(chunk, position);\\n    position += chunk.byteLength;\\n  }\\n\\n  // 创建Blob并下载\\n  const blob = new Blob([completeFile]);\\n  const objectUrl = URL.createObjectURL(blob);\\n\\n  const link = document.createElement('a');\\n  link.href = objectUrl;\\n  link.download = filename;\\n  document.body.appendChild(link);\\n  link.click();\\n\\n  // 清理\\n  document.body.removeChild(link);\\n  URL.revokeObjectURL(objectUrl);\\n\\n  // 清除本地存储中的下载进度\\n  localStorage.removeItem(storageKey);\\n}\\n```\\n\\n### 3.3 React 组件实现文件下载\\n\\n下面是一个React组件，实现了带进度条的文件下载功能：\\n\\n```jsx\\nimport React, { useCallback, useState } from 'react';\\n\\nconst FileDownloader = ({ url, filename, fileSize }) => {\\n  const [downloadProgress, setDownloadProgress] = useState(0);\\n  const [isDownloading, setIsDownloading] = useState(false);\\n  const [isPaused, setIsPaused] = useState(false);\\n\\n  // 带进度监控的下载\\n  const downloadWithProgress = useCallback(async () => {\\n    setIsDownloading(true);\\n    setIsPaused(false);\\n\\n    try {\\n      const response = await fetch(url);\\n\\n      if (!response.ok) {\\n        throw new Error(`HTTP error! status: ${response.status}`);\\n      }\\n\\n      // 获取文件大小\\n      const contentLength = response.headers.get('content-length');\\n      const total = parseInt(contentLength, 10) || fileSize;\\n\\n      // 创建可读流\\n      const reader = response.body.getReader();\\n\\n      // 接收数据块\\n      let receivedLength = 0;\\n      const chunks = [];\\n\\n      while (true) {\\n        if (isPaused) {\\n          // 如果暂停了，就退出循环\\n          break;\\n        }\\n\\n        const { done, value } = await reader.read();\\n\\n        if (done) {\\n          break;\\n        }\\n\\n        chunks.push(value);\\n        receivedLength += value.length;\\n\\n        // 更新进度\\n        setDownloadProgress(Math.round((receivedLength / total) * 100));\\n      }\\n\\n      if (!isPaused) {\\n        // 合并数据块\\n        const chunksAll = new Uint8Array(receivedLength);\\n        let position = 0;\\n        for (const chunk of chunks) {\\n          chunksAll.set(chunk, position);\\n          position += chunk.length;\\n        }\\n\\n        // 创建Blob并下载\\n        const blob = new Blob([chunksAll]);\\n        const objectUrl = URL.createObjectURL(blob);\\n\\n        const link = document.createElement('a');\\n        link.href = objectUrl;\\n        link.download = filename;\\n        document.body.appendChild(link);\\n        link.click();\\n\\n        // 清理\\n        document.body.removeChild(link);\\n        URL.revokeObjectURL(objectUrl);\\n\\n        setDownloadProgress(100);\\n      }\\n    } catch (error) {\\n      console.error('下载失败:', error);\\n      alert('下载失败，请重试');\\n    } finally {\\n      if (!isPaused) {\\n        setIsDownloading(false);\\n      }\\n    }\\n  }, [url, filename, fileSize, isPaused]);\\n\\n  // 开始下载\\n  const startDownload = useCallback(() => {\\n    downloadWithProgress();\\n  }, [downloadWithProgress]);\\n\\n  // 暂停下载\\n  const pauseDownload = useCallback(() => {\\n    setIsPaused(true);\\n  }, []);\\n\\n  // 继续下载\\n  const resumeDownload = useCallback(() => {\\n    // 实际上，当前的实现不支持真正的断点续传\\n    // 这里只是重新开始下载\\n    downloadWithProgress();\\n  }, [downloadWithProgress]);\\n\\n  return (\\n    <div className=\\\"file-downloader\\\">\\n      <h2>文件下载</h2>\\n\\n      <div className=\\\"download-info\\\">\\n        <p>文件名: {filename}</p>\\n        {fileSize && <p>文件大小: {(fileSize / 1024 / 1024).toFixed(2)} MB</p>}\\n      </div>\\n\\n      <div className=\\\"progress-container\\\">\\n        <div className=\\\"progress-bar\\\" style={{ width: `${downloadProgress}%` }}></div>\\n        <span className=\\\"progress-text\\\">{downloadProgress}%</span>\\n      </div>\\n\\n      <div className=\\\"button-group\\\">\\n        {!isDownloading && !isPaused && <button onClick={startDownload}>开始下载</button>}\\n\\n        {isDownloading && !isPaused && <button onClick={pauseDownload}>暂停下载</button>}\\n\\n        {isPaused && <button onClick={resumeDownload}>继续下载</button>}\\n      </div>\\n    </div>\\n  );\\n};\\n\\nexport default FileDownloader;\\n```\\n\\n## 四、使用 Web Worker 优化文件处理\\n\\n对于大文件处理，特别是计算MD5等耗时操作，可以使用Web Worker避免阻塞主线程：\\n\\n```js\\n// md5-worker.js\\nimportScripts('https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.0/spark-md5.min.js');\\n\\nself.onmessage = function (e) {\\n  const { file, chunkSize } = e.data;\\n  const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;\\n  const chunks = Math.ceil(file.size / chunkSize);\\n  let currentChunk = 0;\\n  const spark = new SparkMD5.ArrayBuffer();\\n\\n  const fileReader = new FileReader();\\n\\n  fileReader.onload = function (e) {\\n    spark.append(e.target.result);\\n    currentChunk++;\\n\\n    if (currentChunk < chunks) {\\n      loadNext();\\n      // 报告进度\\n      self.postMessage({\\n        type: 'progress',\\n        progress: (currentChunk / chunks) * 100,\\n      });\\n    } else {\\n      const md5 = spark.end();\\n      self.postMessage({\\n        type: 'complete',\\n        md5: md5,\\n      });\\n    }\\n  };\\n\\n  fileReader.onerror = function () {\\n    self.postMessage({\\n      type: 'error',\\n      error: 'FileReader error',\\n    });\\n  };\\n\\n  function loadNext() {\\n    const start = currentChunk * chunkSize;\\n    const end = Math.min(start + chunkSize, file.size);\\n    fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));\\n  }\\n\\n  loadNext();\\n};\\n```\\n\\n在 React 组件中使用 Web Worker：\\n\\n```jsx\\n// 在组件中使用\\nconst [md5Progress, setMd5Progress] = useState(0);\\n\\nconst calculateFileMD5WithWorker = useCallback((file) => {\\n  return new Promise((resolve, reject) => {\\n    const worker = new Worker('/md5-worker.js');\\n\\n    worker.onmessage = (e) => {\\n      const { type, progress, md5, error } = e.data;\\n\\n      if (type === 'progress') {\\n        setMd5Progress(progress);\\n      } else if (type === 'complete') {\\n        worker.terminate();\\n        resolve(md5);\\n      } else if (type === 'error') {\\n        worker.terminate();\\n        reject(error);\\n      }\\n    };\\n\\n    worker.onerror = reject;\\n\\n    worker.postMessage({\\n      file,\\n      chunkSize: 2097152, // 2MB\\n    });\\n  });\\n}, []);\\n```\\n\\n## 五、服务端实现要点\\n\\n虽然本文主要关注前端实现，但服务端的配合也很重要：\\n\\n### 5.1 接受切片\\n\\n```js\\n// Node.js Express 示例\\nconst express = require('express');\\nconst multer = require('multer');\\nconst fs = require('fs');\\nconst path = require('path');\\n\\nconst app = express();\\nconst upload = multer({ dest: 'uploads/chunks' });\\n\\n// 接收切片\\napp.post('/upload/chunk', upload.single('chunk'), (req, res) => {\\n  const { index, fileId, fileName, totalChunks } = req.body;\\n  const chunkDir = path.join(__dirname, 'uploads/chunks', fileId);\\n\\n  // 确保目录存在\\n  if (!fs.existsSync(chunkDir)) {\\n    fs.mkdirSync(chunkDir, { recursive: true });\\n  }\\n\\n  // 保存切片\\n  const chunkPath = path.join(chunkDir, index);\\n  fs.renameSync(req.file.path, chunkPath);\\n\\n  // 记录已上传的切片\\n  const uploadInfoPath = path.join(chunkDir, 'upload_info.json');\\n  let uploadInfo = { fileName, totalChunks, uploadedChunks: [] };\\n\\n  if (fs.existsSync(uploadInfoPath)) {\\n    uploadInfo = JSON.parse(fs.readFileSync(uploadInfoPath, 'utf-8'));\\n  }\\n\\n  if (!uploadInfo.uploadedChunks.includes(Number(index))) {\\n    uploadInfo.uploadedChunks.push(Number(index));\\n  }\\n\\n  fs.writeFileSync(uploadInfoPath, JSON.stringify(uploadInfo));\\n\\n  res.json({ success: true });\\n});\\n```\\n\\n### 5.2 获取已上传切片\\n\\n```js\\n// 获取已上传的切片\\napp.get('/upload/chunks', (req, res) => {\\n  const { fileId } = req.query;\\n  const chunkDir = path.join(__dirname, 'uploads/chunks', fileId);\\n  const uploadInfoPath = path.join(chunkDir, 'upload_info.json');\\n\\n  if (fs.existsSync(uploadInfoPath)) {\\n    const uploadInfo = JSON.parse(fs.readFileSync(uploadInfoPath, 'utf-8'));\\n    res.json({ uploadedChunks: uploadInfo.uploadedChunks });\\n  } else {\\n    res.json({ uploadedChunks: [] });\\n  }\\n});\\n```\\n\\n### 5.3 合并切片\\n\\n```js\\n// 合并切片\\napp.post('/upload/merge', (req, res) => {\\n  const { fileId, fileName, totalChunks } = req.body;\\n  const chunkDir = path.join(__dirname, 'uploads/chunks', fileId);\\n  const uploadDir = path.join(__dirname, 'uploads/files');\\n  const filePath = path.join(uploadDir, fileName);\\n\\n  // 确保目录存在\\n  if (!fs.existsSync(uploadDir)) {\\n    fs.mkdirSync(uploadDir, { recursive: true });\\n  }\\n\\n  // 创建写入流\\n  const writeStream = fs.createWriteStream(filePath);\\n\\n  // 按顺序合并切片\\n  for (let i = 0; i < totalChunks; i++) {\\n    const chunkPath = path.join(chunkDir, i.toString());\\n    const chunkBuffer = fs.readFileSync(chunkPath);\\n    writeStream.write(chunkBuffer);\\n  }\\n\\n  writeStream.end();\\n\\n  writeStream.on('finish', () => {\\n    // 清理切片\\n    fs.rm(chunkDir, { recursive: true }, (err) => {\\n      if (err) {\\n        console.error('清理切片失败:', err);\\n      }\\n    });\\n\\n    res.json({ success: true, url: `/uploads/files/${fileName}` });\\n  });\\n\\n  writeStream.on('error', (err) => {\\n    console.error('合并文件失败:', err);\\n    res.status(500).json({ success: false, error: '合并文件失败' });\\n  });\\n});\\n```\\n\\n### 5.4 支持Range请求的文件下载\\n\\n```js\\n// 支持Range请求的文件下载\\napp.get('/download/:filename', (req, res) => {\\n  const filename = req.params.filename;\\n  const filePath = path.join(__dirname, 'uploads/files', filename);\\n\\n  if (!fs.existsSync(filePath)) {\\n    return res.status(404).send('文件不存在');\\n  }\\n\\n  const stat = fs.statSync(filePath);\\n  const fileSize = stat.size;\\n  const range = req.headers.range;\\n\\n  if (range) {\\n    // 解析Range头\\n    const parts = range.replace(/bytes=/, '').split('-');\\n    const start = parseInt(parts[0], 10);\\n    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;\\n    const chunkSize = end - start + 1;\\n\\n    const file = fs.createReadStream(filePath, { start, end });\\n\\n    res.writeHead(206, {\\n      'Content-Range': `bytes ${start}-${end}/${fileSize}`,\\n      'Accept-Ranges': 'bytes',\\n      'Content-Length': chunkSize,\\n      'Content-Type': 'application/octet-stream',\\n      'Content-Disposition': `attachment; filename=\\\"${filename}\\\"`,\\n    });\\n\\n    file.pipe(res);\\n  } else {\\n    // 整个文件\\n    res.writeHead(200, {\\n      'Content-Length': fileSize,\\n      'Content-Type': 'application/octet-stream',\\n      'Content-Disposition': `attachment; filename=\\\"${filename}\\\"`,\\n    });\\n\\n    fs.createReadStream(filePath).pipe(res);\\n  }\\n});\\n```\\n\\n## 六、性能优化与最佳实践\\n\\n### 6.1 前端优化\\n\\n1. 合理的切片大小：通常2MB-5MB是比较合适的切片大小，太小会增加请求数，太大可能导致单个请求超时。\\n2. 动态调整并发数：根据网络状况动态调整并发上传的切片数量：\\n\\n```js\\nfunction getOptimalConcurrency() {\\n  // 根据网络状况动态调整\\n  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\\n  if (!connection) return 3; // 默认值\\n\\n  // 根据网络类型和带宽调整\\n  if (connection.type === 'wifi') return 6;\\n  if (connection.type === 'cellular' && connection.downlink < 1) return 2;\\n\\n  return 3; // 默认值\\n}\\n```\\n\\n3. 使用Web Worker：将MD5计算、文件切片等耗时操作放在Web Worker中执行，避免阻塞主线程。\\n4. 使用IndexedDB缓存切片：对于特别大的文件，可以使用IndexedDB临时存储切片，避免内存占用过大：\\n\\n```js\\n// 存储切片到IndexedDB\\nasync function storeChunk(fileId, index, chunk) {\\n  return new Promise((resolve, reject) => {\\n    const request = indexedDB.open('FileChunksDB', 1);\\n\\n    request.onupgradeneeded = (e) => {\\n      const db = e.target.result;\\n      if (!db.objectStoreNames.contains('chunks')) {\\n        db.createObjectStore('chunks', { keyPath: 'id' });\\n      }\\n    };\\n\\n    request.onsuccess = (e) => {\\n      const db = e.target.result;\\n      const transaction = db.transaction(['chunks'], 'readwrite');\\n      const store = transaction.objectStore('chunks');\\n\\n      const item = {\\n        id: `${fileId}_${index}`,\\n        chunk,\\n        timestamp: Date.now(),\\n      };\\n\\n      const storeRequest = store.put(item);\\n      storeRequest.onsuccess = () => resolve();\\n      storeRequest.onerror = () => reject(storeRequest.error);\\n    };\\n\\n    request.onerror = () => reject(request.error);\\n  });\\n}\\n```\\n\\n5. 预检查文件是否已上传：在开始上传前，先检查服务器是否已有相同MD5的文件，实现秒传功能。\\n\\n### 6.2 服务端优化\\n\\n1. 流式处理：使用流式处理而非一次性加载整个文件到内存。\\n2. 分布式存储：对于生产环境，考虑使用分布式存储系统如MinIO、S3等。\\n3. 定时清理过期切片：设置定时任务，清理长时间未完成上传的切片文件。\\n4. 限制上传大小和速率：根据服务器能力设置合理的限制，避免资源耗尽。\\n\\n## 七、兼容性与降级处理\\n\\n对于不支持现代API的浏览器，可以提供降级方案：\\n\\n```js\\n// 检测浏览器能力\\nfunction checkBrowserCapabilities() {\\n  const capabilities = {\\n    fileSlice: !!(File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice),\\n    fileReader: !!window.FileReader,\\n    formData: !!window.FormData,\\n    progress: 'onprogress' in new XMLHttpRequest(),\\n    blob: !!window.Blob,\\n    arrayBuffer: !!window.ArrayBuffer,\\n    webWorker: !!window.Worker,\\n    indexedDB: !!window.indexedDB,\\n  };\\n\\n  // 判断是否支持切片上传\\n  capabilities.sliceUpload = capabilities.fileSlice && capabilities.fileReader && capabilities.formData;\\n\\n  // 判断是否支持高级功能\\n  capabilities.advancedFeatures = capabilities.sliceUpload && capabilities.webWorker && capabilities.indexedDB;\\n\\n  return capabilities;\\n}\\n\\n// 根据浏览器能力选择上传方法\\nfunction selectUploadMethod(file, options) {\\n  const capabilities = checkBrowserCapabilities();\\n\\n  if (file.size <= 10 * 1024 * 1024) {\\n    // 小于10MB的文件直接上传\\n    return simpleUpload(file, options);\\n  } else if (capabilities.sliceUpload) {\\n    // 支持切片上传\\n    if (capabilities.advancedFeatures) {\\n      // 支持高级功能\\n      return advancedChunkUpload(file, options);\\n    } else {\\n      // 基本切片上传\\n      return basicChunkUpload(file, options);\\n    }\\n  } else {\\n    // 不支持切片，使用简单上传并提示用户\\n    alert('您的浏览器不支持大文件上传，可能会遇到超时问题');\\n    return simpleUpload(file, options);\\n  }\\n}\\n```\\n\\n### 7.1 降级上传方案\\n\\n```js\\n// 简单上传方案（不分片）\\nfunction simpleUpload(file, { onProgress, onSuccess, onError }) {\\n  const formData = new FormData();\\n  formData.append('file', file);\\n\\n  const xhr = new XMLHttpRequest();\\n\\n  if (xhr.upload && onProgress) {\\n    xhr.upload.onprogress = (e) => {\\n      if (e.lengthComputable) {\\n        const percent = Math.round((e.loaded / e.total) * 100);\\n        onProgress(percent);\\n      }\\n    };\\n  }\\n\\n  xhr.onload = () => {\\n    if (xhr.status >= 200 && xhr.status < 300) {\\n      onSuccess && onSuccess(xhr.responseText);\\n    } else {\\n      onError && onError(new Error('Upload failed with status: ' + xhr.status));\\n    }\\n  };\\n\\n  xhr.onerror = () => {\\n    onError && onError(new Error('Network error during upload'));\\n  };\\n\\n  xhr.open('POST', '/upload', true);\\n  xhr.send(formData);\\n\\n  return {\\n    abort: () => xhr.abort(),\\n  };\\n}\\n```\\n\\n### 7.2 降级下载方案\\n\\n```js\\n// 简单下载方案（不支持进度和断点续传）\\nfunction simpleDownload(url, filename) {\\n  // 方法1：使用a标签（最广泛支持）\\n  const link = document.createElement('a');\\n  link.href = url;\\n  link.download = filename || '';\\n  link.target = '_blank';\\n  document.body.appendChild(link);\\n  link.click();\\n  document.body.removeChild(link);\\n\\n  // 方法2：使用iframe（兼容旧浏览器）\\n  /*\\n  const iframe = document.createElement('iframe');\\n  iframe.style.display = 'none';\\n  iframe.src = url;\\n  document.body.appendChild(iframe);\\n  setTimeout(() => {\\n    document.body.removeChild(iframe);\\n  }, 5000);\\n  */\\n}\\n```\\n\\n## 八、安全性考虑\\n\\n### 8.1 文件类型验证\\n\\n```js\\n// 前端文件类型验证\\nfunction validateFileType(file, allowedTypes) {\\n  // 检查文件MIME类型\\n  if (allowedTypes && !allowedTypes.includes(file.type)) {\\n    return false;\\n  }\\n\\n  // 检查文件扩展名\\n  const extension = file.name.split('.').pop().toLowerCase();\\n  const allowedExtensions = ['jpg', 'jpeg', 'png', 'pdf', 'doc', 'docx', 'xls', 'xlsx'];\\n\\n  if (!allowedExtensions.includes(extension)) {\\n    return false;\\n  }\\n\\n  return true;\\n}\\n```\\n\\n### 8.2 文件大小限制\\n\\n```js\\n// 前端文件大小验证\\nfunction validateFileSize(file, maxSize = 1024 * 1024 * 100) {\\n  // 默认100MB\\n  return file.size <= maxSize;\\n}\\n```\\n\\n### 8.3 服务端安全措施\\n\\n服务端应实施以下安全措施：\\n\\n1. 文件类型验证：不仅检查扩展名，还应检查文件头信息\\n2. 病毒扫描：使用杀毒软件API扫描上传的文件\\n3. 存储隔离：将上传的文件存储在与应用程序隔离的位置\\n4. 访问控制：实施严格的访问控制，确保只有授权用户能访问文件\\n5. 文件重命名：避免使用用户提供的文件名，使用随机生成的名称\\n\\n## 九、总结与展望\\n\\n### 10.1 技术总结\\n\\n本文详细介绍了大文件上传和下载的前端实现技术，主要包括：\\n\\n1. 文件切片：将大文件分割成小块，分别上传\\n2. 断点续传：记录已上传的切片，支持中断后继续上传\\n3. 并发控制：限制同时上传的切片数量，避免资源耗尽\\n4. 进度监控：实时显示上传和下载进度\\n5. Web Worker：使用工作线程处理耗时操作，避免阻塞主线程\\n6. 流式下载：使用流式API处理大文件下载\\n7. 兼容性处理：为不同浏览器提供降级方案\\n\\n### 10.2 未来展望\\n\\n随着Web技术的发展，大文件处理将迎来更多创新：\\n\\n1. WebTransport API：提供更可靠和高效的数据传输\\n2. WebCodecs API：在浏览器中进行高效的媒体处理\\n3. File System Access API：直接访问用户文件系统，提供更好的文件处理体验\\n4. Shared Array Buffer：在Web Worker之间共享内存，提高处理效率\\n5. WebAssembly：使用接近原生的性能处理大文件计算\\n\\n### 10.3 最佳实践建议\\n\\n1. 根据文件大小选择策略：小文件可以直接上传，大文件使用切片上传\\n2. 动态调整切片大小：根据网络状况和文件类型调整切片大小\\n3. 实现预上传检查：检查文件是否已存在，实现秒传功能\\n4. 提供友好的用户界面：显示详细的进度信息和操作选项\\n5. 做好错误处理：捕获并处理各种异常情况，提供重试机制\\n6. 考虑移动设备：移动设备上网络可能不稳定，需要更强的容错能力\\n\",\"wordCount\":1696},{\"id\":\"2f467b9f\",\"title\":\"样式隔离方案汇总\",\"date\":\"2021-11-25\",\"tags\":[\"css\",\"工程化\"],\"fileName\":\"样式隔离方案汇总.md\",\"content\":\"\\n## 背景\\n\\n最近写了一个 webpack loader 来做项目中的样式隔离，方案是通过类名前缀进行隔离，因此想研究下前端中一共有哪些样式隔离的方案。\\n\\n## 方案\\n\\n### 一、CSS Module\\n\\n```jsx\\n// 文件名：Button.module.css\\n.button {\\n  color: red;\\n}\\n\\n// 使用方式\\nimport styles from './Button.module.css';\\n\\nfunction Button() {\\n  return <button className={styles.button}>Click me</button>;\\n}\\n```\\n\\n优点：\\n\\n- 自动生成唯一的类名\\n- 不需要特殊的配置\\n- 局部作用域\\n\\n缺点：\\n\\n- 需要使用特定的文件命名方式\\n- 动态类名处理相对麻烦\\n\\n### 二、CSS-in-JS\\n\\n```jsx\\n// styled-components 示例\\nimport styled from 'styled-components';\\n\\nconst StyledButton = styled.button`\\n  color: ${(props) => (props.primary ? 'blue' : 'red')};\\n  padding: 10px;\\n`;\\n\\nfunction Button() {\\n  return <StyledButton primary>Click me</StyledButton>;\\n}\\n```\\n\\n优点：\\n\\n- 完全的样式隔离\\n- 支持动态样式\\n- 支持主题\\n\\n缺点：\\n运行时开销\\n需要额外的库\\n调试相对困难\\n\\n### 三、BEM 命名规范\\n\\nBEM (Block Element Modifier) 是一种 CSS 命名规范，它通过一种特定的命名方式来创建可重用的组件。\\n\\n它的三个核心概念：\\n\\n1. Block（块）：独立的组件，可以被重用\\n\\n```css\\n.card {\\n}\\n.header {\\n}\\n.menu {\\n}\\n```\\n\\n2. Element（元素）：块的组成部分，使用双下划线 \\\\_\\\\_ 连接\\n\\n```css\\n.card__title {\\n}\\n.card__image {\\n}\\n.menu__item {\\n}\\n```\\n\\n3. Modifier（修饰符）：改变块或元素的外观或状态，使用双连字符 -- 连接\\n\\n```css\\n.card--featured {\\n}\\n.menu__item--active {\\n}\\n.button--disabled {\\n}\\n```\\n\\n实际例子：\\n\\n```css\\n.block__element--modifier {\\n  color: red;\\n}\\n\\n.button__icon--large {\\n  font-size: 20px;\\n}\\n```\\n\\n优点：\\n\\n- 无需工具支持\\n- 易于理解和维护\\n\\n缺点：\\n\\n- 类名较长\\n- 需要团队严格遵守规范\\n\\n### 四、Shadow DOM\\n\\n```js\\nclass CustomButton extends HTMLElement {\\n  constructor() {\\n    super();\\n    const shadow = this.attachShadow({ mode: 'closed' });\\n\\n    const button = document.createElement('button');\\n    const style = document.createElement('style');\\n\\n    style.textContent = `\\n      button {\\n        color: red;\\n      }\\n    `;\\n\\n    shadow.appendChild(style);\\n    shadow.appendChild(button);\\n  }\\n}\\n\\ncustomElements.define('custom-button', CustomButton);\\n```\\n\\n优点：\\n\\n- 完全隔离\\n- 原生支持\\n\\n缺点：\\n\\n- 兼容性问题\\n- 使用相对复杂\\n\\n### 五、CSS Scoped\\n\\n```vue\\n<template>\\n  <div class=\\\"button\\\">Click me</div>\\n</template>\\n\\n<style scoped>\\n.button {\\n  color: red;\\n}\\n</style>\\n```\\n\\n优点：\\n\\n- Vue 原生支持\\n- 使用简单\\n\\n缺点：\\n\\n- 仅限于 Vue\\n- 性能略差\\n\\n### 六、CSS-in-JS 工具（如 Emotion）\\n\\n```js\\n/** @jsx jsx */\\nimport { css, jsx } from '@emotion/core';\\n\\nconst buttonStyle = css`\\n  color: red;\\n  padding: 10px;\\n`;\\n\\nfunction Button() {\\n  return <button css={buttonStyle}>Click me</button>;\\n}\\n```\\n\\n优点：\\n\\n- 强大的动态样式能力\\n- 良好的开发体验\\n\\n缺点：\\n\\n- 需要额外的库\\n- 构建配置较复杂\\n\\n### 七、CSS Scope Loader（自定义前缀）\\n\\n```js\\n// webpack 配置\\n{\\n  loader: 'css-loader',\\n  options: {\\n    modules: {\\n      localIdentName: '[name]__[local]--[hash:base64:5]'\\n    }\\n  }\\n}\\n```\\n\\n优点：\\n\\n- 可自定义程度高\\n- 适用于任何项目\\n\\n缺点：\\n\\n- 需要配置 loader\\n- 可能影响构建性能\\n\\n### 八、CSS Namespace\\n\\n```css\\n/* 通过命名空间隔离 */\\n.app-button {\\n  color: red;\\n}\\n\\n.app-button__icon {\\n  size: 16px;\\n}\\n```\\n\\n优点：\\n\\n- 简单直接\\n- 无需工具支持\\n\\n缺点：\\n\\n- 可能出现命名冲突\\n- 需要手动维护\\n\\n### 九、原子化 CSS（如 Tailwind）\\n\\n```html\\n<button class=\\\"rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700\\\">Click me</button>\\n```\\n\\n优点：\\n\\n- 天然隔离\\n- 复用性强\\n\\n缺点：\\n\\n- 类名较多\\n- 学习成本高\\n\\n## 选择建议\\n\\n小型项目：\\n\\n- BEM 命名规范\\n- CSS Modules\\n\\n中型项目：\\n\\n- CSS Modules\\n- CSS-in-JS\\n- Scoped CSS (Vue)\\n\\n大型项目：\\n\\n- CSS-in-JS\\n- 原子化 CSS\\n- 自定义 CSS Loader\\n\\n组件库：\\n\\n- CSS-in-JS\\n- Shadow DOM\\n- CSS Scope Loader\\n\\n具体选择要根据：\\n\\n- 项目规模\\n- 团队熟悉度\\n- 性能要求\\n- 维护成本\\n- 浏览器兼容性要求\\n\",\"wordCount\":561},{\"id\":\"e615c1c3\",\"title\":\"从零开发一个 webpack loader\",\"date\":\"2021-11-18\",\"tags\":[\"webpack\",\"工程化\"],\"fileName\":\"从零开发一个 webpack loader.md\",\"content\":\"\\n## 背景\\n\\n由于近一段时间业务中开始需要经常开发、贡献物料组件，但是物料项目中对于样式隔离的方案不是那么的自动化，需要开发人员自己手动给每一个类名加上唯一且稳定的前缀（类似于作用域，进行样式隔离，防止业务中用到多个物料组件时有类名冲突的问题），这就使得开发体验不是很好。因此我打算给物料项目提供一个 webpack loader，来解决需要开发人员手动给样式添加类名前缀的问题。\\n\\n## 需求调研\\n\\n根据项目中的对于类名前缀的使用情况进行调研，发现为以下情形：\\n\\n**_一、每个 React 组件使用 className 时，必须通过一个设置前缀的函数对类名附加上前缀_**\\n\\n代码示例：\\n\\ngetScopedClassName 的定义:\\n\\n```ts\\nfunction getScopedClassName(className: string) {\\n  return className ? `${PREFIX_CLASSNAME}${className}` : '';\\n}\\n```\\n\\n组件使用 getScopedClassName：\\n\\n```jsx\\n<div className={getScopedClassName('f-table')}>...</div>\\n```\\n\\n**_二、less 文件（项目中用的样式是 less）中对应也需要加上前缀变量_**\\n\\n举个🌰：\\n\\n```less\\n.@{PREFIX_CLASSNAME}f-table {\\n  font-weight: bold;\\n  line-height: 40px;\\n  margin: 0 auto;\\n}\\n```\\n\\n## 方案设计\\n\\n针对于调研中的使用情况，我们不难设计：\\n\\n- 由于整体涉及到的是对代码文件内容的改动，因此 loader 比 plugin 更合适\\n- 类名前缀通过使用 loader 时传递参数传给 loader 里，供其内部处理\\n- loader 内部需要处理以下任务：\\n  - 把 tsx/jsx 文件里组件使用到的 className 属性值加上前缀\\n  - 把 css 文件里的类名添加上前缀（less 经过转译也会变为 css，因此只处理 css 即可）\\n\\n## 代码实现\\n\\n### 主入口文件（index.ts）\\n\\n主要用于对接受到文件内容进行分发处理，代码如下：\\n\\n```ts\\nimport type { LoaderContext } from 'webpack';\\n\\nimport processCSS from './processCSS';\\nimport processJS from './processJS';\\n\\ninterface CSSScopeLoaderOptions {\\n  scope?: string;\\n}\\n\\nfunction cssScopeLoader(this: LoaderContext<CSSScopeLoaderOptions>, source: string): string {\\n  // 告诉 webpack 这个 loader 的输出是否可以被缓存\\n  this.cacheable && this.cacheable();\\n\\n  // 获取配置的 scope 参数值\\n  const options = this.getOptions();\\n  const scope = options.scope || 'your-scope';\\n  const resourcePath = this.resourcePath.toLowerCase();\\n\\n  try {\\n    if (/\\\\.(jsx|tsx)$/.test(resourcePath)) {\\n      return processJS(source, scope);\\n    } else if (/\\\\.css$/.test(resourcePath)) {\\n      return processCSS(source, scope);\\n    }\\n    return source;\\n  } catch (error) {\\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\\n    this.emitError(new Error(`类名前缀处理错误: ${errorMessage}`));\\n    return source;\\n  }\\n}\\n\\n// 声明 loader 的 raw 属性\\n// 文本文件处理用 raw = false\\n// 二进制文件处理用 raw = true\\ncssScopeLoader.raw = false;\\n\\nexport default cssScopeLoader;\\n```\\n\\n### processJS 文件（处理 jsx、tsx）\\n\\n```ts\\nimport generate from '@babel/generator';\\nimport { parse as babelParse } from '@babel/parser';\\nimport traverse from '@babel/traverse';\\nimport * as t from '@babel/types';\\n\\n/**\\n * 处理 className 字符串\\n */\\nexport function addScopeToClassName(classNames: string, scope: string): string {\\n  return classNames\\n    .split(/\\\\s+/)\\n    .map((className) => (className ? `${scope}${className}` : className))\\n    .join(' ');\\n}\\n\\n/**\\n * 处理 JSX/TSX 中的 className 属性，保持原始代码格式不变\\n */\\nfunction processJS(content: string, scope: string): string {\\n  const ast = babelParse(content, {\\n    sourceType: 'module',\\n    plugins: ['jsx', 'typescript'],\\n    allowReturnOutsideFunction: true,\\n    createParenthesizedExpressions: true,\\n  });\\n\\n  // 处理字符串字面量中的类名\\n  const processStringLiteral = (node: t.StringLiteral) => {\\n    node.value = addScopeToClassName(node.value, scope);\\n  };\\n\\n  // 处理条件表达式中的类名\\n  const processConditionalExpression = (node: t.ConditionalExpression) => {\\n    if (t.isStringLiteral(node.consequent)) {\\n      processStringLiteral(node.consequent);\\n    }\\n    if (t.isStringLiteral(node.alternate)) {\\n      processStringLiteral(node.alternate);\\n    }\\n  };\\n\\n  traverse(ast, {\\n    JSXAttribute(path) {\\n      // 只处理 className 属性\\n      if (path.node.name.name !== 'className') {\\n        return;\\n      }\\n\\n      const value = path.node.value;\\n      if (!value) return;\\n\\n      // 处理字符串字面量\\n      if (t.isStringLiteral(value)) {\\n        processStringLiteral(value);\\n        return;\\n      }\\n\\n      // 处理表达式容器\\n      if (t.isJSXExpressionContainer(value)) {\\n        const expression = value.expression;\\n\\n        // 处理三元表达式\\n        if (t.isConditionalExpression(expression)) {\\n          processConditionalExpression(expression);\\n          return;\\n        }\\n\\n        // 处理模板字符串\\n        if (t.isTemplateLiteral(expression)) {\\n          // 处理模板字符串中的静态部分\\n          expression.quasis.forEach((quasi) => {\\n            if (quasi.value.raw.trim()) {\\n              quasi.value.raw = addScopeToClassName(quasi.value.raw, scope);\\n              quasi.value.cooked = addScopeToClassName(quasi.value.cooked || '', scope);\\n            }\\n          });\\n\\n          // 处理模板字符串中的表达式\\n          expression.expressions.forEach((expr) => {\\n            if (t.isConditionalExpression(expr)) {\\n              processConditionalExpression(expr);\\n            } else if (t.isLogicalExpression(expr)) {\\n              if (t.isStringLiteral(expr.right)) {\\n                processStringLiteral(expr.right);\\n              }\\n            } else if (t.isStringLiteral(expr)) {\\n              processStringLiteral(expr);\\n            }\\n          });\\n          return;\\n        }\\n\\n        // 处理逻辑表达式 (&&)\\n        if (t.isLogicalExpression(expression)) {\\n          if (t.isStringLiteral(expression.right)) {\\n            processStringLiteral(expression.right);\\n          }\\n          return;\\n        }\\n      }\\n    },\\n  });\\n\\n  return generate(ast).code;\\n}\\n\\nexport default processJS;\\n```\\n\\n### processCSS 文件（处理 css）\\n\\n```ts\\nimport { parse as cssParser, stringify as cssStringify } from 'css';\\n\\nimport type { CssAst, CssRule } from './types';\\n\\n/**\\n * 处理 CSS 规则\\n * @param rules CSS 规则数组\\n * @param scope 作用域\\n */\\nfunction processRules(rules: CssRule[], scope: string): void {\\n  rules.forEach((rule: CssRule) => {\\n    switch (rule.type) {\\n      case 'rule':\\n        // 处理普通规则\\n        if (rule.selectors) {\\n          rule.selectors = rule.selectors.map((selector: string) => {\\n            return selector.replace(/\\\\.([\\\\w-]+)/g, `.${scope}$1`);\\n          });\\n        }\\n        break;\\n\\n      case 'media':\\n      case 'supports':\\n      case 'document':\\n      case 'host':\\n      case 'layer':\\n        // 处理所有可能包含嵌套规则的 at-rules\\n        if (rule.rules) {\\n          processRules(rule.rules, scope);\\n        }\\n        break;\\n\\n      case 'keyframes':\\n        // 处理关键帧动画\\n        if (rule.keyframes) {\\n          processRules(rule.keyframes, scope);\\n        } else if (rule.rules) {\\n          // 某些 CSS 解析器可能将关键帧放在 rules 中\\n          processRules(rule.rules, scope);\\n        }\\n        break;\\n\\n      default:\\n        // 处理其他可能包含规则的节点\\n        if (rule.rules && Array.isArray(rule.rules)) {\\n          processRules(rule.rules, scope);\\n        }\\n        if (rule.keyframes && Array.isArray(rule.keyframes)) {\\n          processRules(rule.keyframes, scope);\\n        }\\n        break;\\n    }\\n  });\\n}\\n\\n/**\\n * 处理 CSS 内容\\n * @param content CSS 内容\\n * @param scope 作用域\\n * @returns 处理后的 CSS 内容\\n */\\nfunction processCSS(content: string, scope: string): string {\\n  try {\\n    // 确保输入内容不为空\\n    if (!content.trim()) {\\n      return '';\\n    }\\n\\n    // 如果是简单的空规则，直接处理\\n    if (content.match(/^\\\\.([\\\\w-]+)\\\\s*{\\\\s*}\\\\s*$/)) {\\n      return content.replace(/\\\\.([\\\\w-]+)/g, `.${scope}$1`);\\n    }\\n\\n    const ast = cssParser(content, {\\n      silent: false, // 不静默处理错误\\n    }) as CssAst;\\n\\n    // 确保 AST 和规则数组存在\\n    if (!ast || !ast.stylesheet || !Array.isArray(ast.stylesheet.rules)) {\\n      // 如果 AST 解析失败，尝试直接处理选择器\\n      return content.replace(/\\\\.([\\\\w-]+)/g, `.${scope}$1`);\\n    }\\n\\n    // 递归处理所有规则\\n    processRules(ast.stylesheet.rules, scope);\\n\\n    // 将 AST 转换回 CSS 代码\\n    const result = cssStringify(ast);\\n\\n    // 如果转换结果为空，尝试直接处理原始内容\\n    if (!result) {\\n      return content.replace(/\\\\.([\\\\w-]+)/g, `.${scope}$1`);\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // 发生错误时，尝试直接处理原始内容\\n    console.error('处理 CSS 内容时出错:', error);\\n    return content.replace(/\\\\.([\\\\w-]+)/g, `.${scope}$1`);\\n  }\\n}\\n\\nexport default processCSS;\\n```\\n\\n## 发布\\n\\n经过测试没问题后，需要将 loader 发布到 npm，有以下需要注意的点：\\n\\n1. 上传到 npm 的包需要在 package.json 中包含一些必要字段\\n\\n```js\\n{\\n  \\\"name\\\": \\\"css-scope-loader\\\",        // 包名，必须唯一\\n  \\\"version\\\": \\\"0.0.1\\\",                // 版本号，必须符合语义化版本\\n  \\\"description\\\": \\\"A webpack loader that adds scope to css in react projects\\\",  // 包描述\\n  \\\"main\\\": \\\"./dist/index.cjs\\\",        // 主入口文件\\n  \\\"author\\\": \\\"Percy Kuang\\\",           // 作者信息\\n  \\\"license\\\": \\\"MIT\\\"                   // 许可证\\n}\\n```\\n\\n2. 确保你已经登录 npm\\n\\n```bash\\nnpm login\\n```\\n\\n如果你还没有 npm 账号，需要先在 npm 官网 注册一个账号。\\n\\n3. 更新版本号\\n\\n在发布之前，建议更新版本号。遵循语义化版本（Semantic Versioning）：\\n\\n- 主版本号（Major）：当你做了不兼容的 API 修改\\n- 次版本号（Minor）：当你做了向下兼容的功能性新增\\n- 修订号（Patch）：当你做了向下兼容的问题修正\\n\\n你可以使用以下命令更新版本号：\\n\\n```bash\\nnpm version patch  # 0.0.1 -> 0.0.2\\n# 或\\nnpm version minor  # 0.0.1 -> 0.1.0\\n# 或\\nnpm version major  # 0.0.1 -> 1.0.0\\n```\\n\\n4. 构建项目\\n\\n确保你的代码已经构建完成：\\n\\n```bash\\nnpm run build\\n```\\n\\n5. 检查 .npmignore 或 files 字段\\n\\n确保正确配置了 files 字段，只包含 dist 目录\\n\\n6. 发布后进行验证\\n\\n发布完成后，可以：\\n\\n- 在 npm 官网上搜索包名\\n- 使用 npm view css-scope-loader 查看包信息\\n- 创建一个测试项目安装你的包：npm install css-scope-loader\\n\",\"wordCount\":705},{\"id\":\"ff05ecf2\",\"title\":\"理解 Cookie、Session 和 JWT：Web 应用中的用户状态管理\",\"date\":\"2021-02-24\",\"tags\":[\"浏览器\",\"http\"],\"fileName\":\"理解 Cookie、Session 和 JWT：Web 应用中的用户状态管理.md\",\"content\":\"\\n## 引言\\n\\n在现代 Web 应用中，HTTP 协议本身是无状态的。这意味着服务器默认不会\\\"记住\\\"来自同一用户的连续请求。然而，许多应用场景（如用户登录、购物车、个性化设置等）都需要在用户的多次请求之间保持其状态和信息。为了解决这个问题，开发者们引入了多种机制，其中 Cookie、Session 和 JWT (JSON Web Token) 是最常用和最重要的三种。理解它们的工作原理、各自的优缺点以及适用场景，对于构建安全、高效且用户友好的 Web 应用至关重要。本文将深入探讨这三种技术，帮助你更好地在项目中做出选择。\\n\\n## Cookie\\n\\n### 什么是 Cookie？\\n\\nCookie 是一小段文本信息，由网站服务器发送给浏览器，并存储在用户的计算机上。当用户再次访问该网站时，浏览器会将这些 Cookie 信息发送回服务器，从而让服务器能够识别用户并记住一些信息，例如用户的登录状态、偏好设置、购物车内容等。\\n\\n### Cookie 是如何工作的？\\n\\n1.  **服务器发送 Cookie**：当用户首次访问一个网站时，如果服务器需要记录用户信息，它会在 HTTP 响应头中添加一个 `Set-Cookie` 字段，其中包含 Cookie 的名称、值以及其他可选属性（如过期时间、作用域等）。\\n2.  **浏览器存储 Cookie**：浏览器接收到响应后，会解析 `Set-Cookie` 头部，并将 Cookie 信息存储起来。\\n3.  **浏览器发送 Cookie**：在后续的每次请求中，只要请求的域名和路径与 Cookie 的作用域匹配，浏览器就会自动在 HTTP 请求头中添加一个 `Cookie` 字段，将之前存储的 Cookie 发送给服务器。\\n4.  **服务器读取 Cookie**：服务器接收到请求后，会读取请求头中的 `Cookie` 信息，并根据这些信息来识别用户、恢复会话或提供个性化服务。\\n\\n### Cookie 的常见用途\\n\\n- **会话管理**：跟踪用户登录状态、购物车内容、游戏得分等。\\n- **个性化设置**：记住用户的偏好，如语言选择、主题偏好、自定义布局等。\\n- **追踪和分析**：记录用户的浏览历史、点击行为等，用于广告投放和网站分析。\\n\\n### Cookie 的重要属性\\n\\n- **`Name=Value`**：Cookie 的名称和值。这是 Cookie 的核心部分。\\n- **`Expires=Date`**：Cookie 的过期时间。如果设置了此属性，Cookie 会在该时间点后被删除。如果未设置，则为会话 Cookie，浏览器关闭时即被删除。\\n- **`Max-Age=Seconds`**：Cookie 的生命周期，以秒为单位。优先级高于 `Expires`。\\n- **`Domain=domain`**：指定 Cookie 可以发送到的域名。如果未指定，则默认为当前文档的域名（不包括子域名）。\\n- **`Path=path`**：指定 Cookie 可以发送到的服务器路径。如果未指定，则默认为当前文档的路径。\\n- **`Secure`**：标记此 Cookie 只应通过 HTTPS 加密连接发送给服务器。这有助于防止 Cookie 在传输过程中被窃听。\\n- **`HttpOnly`**：标记此 Cookie 不能通过客户端 JavaScript (如 `document.cookie`) 访问。这有助于缓解跨站脚本攻击 (XSS)，防止恶意脚本窃取 Cookie。\\n- **`SameSite=Strict|Lax|None`**：控制 Cookie 是否可以随跨站请求发送，以帮助防止跨站请求伪造 (CSRF) 攻击。\\n  - `Strict`：完全禁止第三方 Cookie，只有在当前站点发起的请求才会携带 Cookie。\\n  - `Lax`：允许部分第三方请求携带 Cookie，例如通过链接导航到目标站点。\\n  - `None`：允许任何第三方请求携带 Cookie，但必须同时设置 `Secure` 属性 (即只能在 HTTPS 连接下使用)。\\n\\n### Cookie 的优点与缺点\\n\\n**优点：**\\n\\n- **简单易用**：实现简单，被广泛支持。\\n- **持久性**：可以设置过期时间，实现长时间的用户状态保持。\\n- **客户端存储**：减轻了服务器的存储压力 (相对于 Session 而言)。\\n\\n**缺点：**\\n\\n- **大小限制**：大多数浏览器对单个 Cookie 的大小（通常为 4KB）和每个域名下的 Cookie 数量（通常为 20-50 个）有限制。\\n- **安全性风险**：如果 Cookie 未加密或未正确设置 `HttpOnly` 和 `Secure` 属性，容易被窃取或篡改，导致 XSS 或 CSRF 攻击。\\n- **性能影响**：在每次 HTTP 请求中都会携带 Cookie，即使某些请求并不需要这些 Cookie，也会增加网络流量。\\n- **用户可禁用**：用户可以在浏览器设置中禁用 Cookie，导致依赖 Cookie 的功能失效。\\n\\n## Session\\n\\n### 什么是 Session？\\n\\nSession（会话）是一种在服务器端存储用户特定信息的机制。与 Cookie 不同，Session 数据本身存储在服务器上，而只将一个唯一的 Session ID（会话标识符）通过 Cookie（或 URL 参数）发送给客户端浏览器。浏览器在后续请求中带上这个 Session ID，服务器据此找到对应的 Session 数据，从而实现状态保持。\\n\\n### Session 是如何工作的？\\n\\n1.  **用户发起请求**：用户首次访问应用或进行需要状态管理的操作（如登录）。\\n2.  **服务器创建 Session**：如果服务器端启用了 Session 管理，并且当前请求没有有效的 Session ID，服务器会为该用户创建一个新的 Session 对象，并生成一个唯一的 Session ID。同时，服务器会将需要跟踪的用户信息（如用户 ID、权限、购物车内容等）存储在这个 Session 对象中。这些 Session 数据通常存储在服务器的内存、数据库或专门的 Session 存储服务（如 Redis、Memcached）中。\\n3.  **服务器发送 Session ID 给客户端**：服务器通过 HTTP 响应头中的 `Set-Cookie` 字段，将这个 Session ID 发送给客户端浏览器。这个 Cookie 通常是临时的（会话 Cookie），且通常命名为 `JSESSIONID` (Java)、`PHPSESSID` (PHP)、`ASPSESSIONID` (ASP) 等，具体名称取决于服务器端技术栈。\\n4.  **客户端存储 Session ID**：浏览器接收到包含 Session ID 的 Cookie 后，会将其存储起来。\\n5.  **客户端发送 Session ID**：在后续的每次请求中，浏览器会自动将这个 Session ID Cookie 发送给服务器。\\n6.  **服务器验证 Session ID 并检索 Session 数据**：服务器接收到请求后，会从 Cookie 中提取 Session ID，并根据这个 ID 在服务器端的 Session 存储中查找对应的 Session 数据。如果找到了有效的 Session，服务器就可以使用这些数据来处理当前请求。\\n7.  **Session 的销毁**：Session 通常有过期时间。当用户长时间未活动、关闭浏览器（如果 Session ID 是会话 Cookie），或者服务器主动销毁 Session 时，Session 数据会被清除。\\n\\n### Session 的优点与缺点\\n\\n**优点：**\\n\\n- **安全性较高**：敏感数据存储在服务器端，只在客户端存储一个无意义的 Session ID，降低了数据泄露的风险。即使 Session ID 被截获，攻击者也难以直接获取到实际的用户信息，除非他们能利用这个 ID 劫持会话。\\n- **存储容量较大**：Session 数据存储在服务器端，理论上可以存储比 Cookie 更多的数据，不受浏览器对 Cookie 大小的限制。\\n- **数据类型灵活**：可以在 Session 中存储各种类型的数据，如对象、数组等，而不仅仅是字符串。\\n\\n**缺点：**\\n\\n- **服务器压力**：每个用户的 Session 数据都需要在服务器端存储，当并发用户量较大时，会占用较多的服务器资源（内存或存储空间），增加服务器的压力。\\n- **可扩展性问题**：在分布式或集群环境下，Session 共享和同步是一个挑战。如果用户请求被负载均衡到不同的服务器，需要确保这些服务器都能访问到同一个用户的 Session 数据。常见的解决方案包括 Session 复制、Session 持久化到共享存储（如数据库或 Redis）、或使用粘性 Session (Sticky Session) 将用户请求固定到同一台服务器。\\n- **依赖 Cookie（通常）**：虽然 Session ID 也可以通过 URL 重写等方式传递，但最常见和推荐的方式还是通过 Cookie。如果客户端禁用了 Cookie，Session 机制也会受影响。\\n- **CSRF 风险**：如果仅依赖 Session ID Cookie 进行认证，仍然存在跨站请求伪造 (CSRF) 的风险，需要配合其他 CSRF 防御措施。\\n\\n## JWT (JSON Web Token)\\n\\n### 什么是 JWT？\\n\\nJWT (JSON Web Token) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息（声明，Claims）。这些信息可以被验证和信任，因为它们是数字签名的。JWT 可以使用密钥（使用 HMAC 算法）或公钥/私钥对（使用 RSA 或 ECDSA）进行签名。\\n\\n与 Session 不同，JWT 本身就包含了用户信息（或其他声明），而不是在服务器上存储这些信息然后通过 ID 引用。这意味着服务器不需要在后端存储用户会话状态，从而使得应用更具可伸缩性和无状态性。\\n\\n### JWT 的结构\\n\\nJWT 通常由三部分组成，用点 (`.`) 分隔：\\n\\n1.  **Header (头部)**：包含关于如何处理令牌的元数据，通常由两部分组成：\\n\\n    - `typ` (Type)：令牌的类型，通常是 `JWT`。\\n    - `alg` (Algorithm)：用于签名的算法，例如 `HS256` (HMAC SHA256) 或 `RS256` (RSA SHA256)。\\n      头部会进行 Base64Url 编码形成 JWT 的第一部分。\\n\\n    ```json\\n    {\\n      \\\"alg\\\": \\\"HS256\\\",\\n      \\\"typ\\\": \\\"JWT\\\"\\n    }\\n    ```\\n\\n2.  **Payload (负载/声明)**：包含实际要传输的信息，即声明 (Claims)。声明是关于实体（通常是用户）和附加数据的陈述。有三种类型的声明：\\n\\n    - **Registered Claims (注册声明)**：这些是一组预定义的声明，非强制性的，但推荐使用，以提供一组有用的、可互操作的声明。例如：\\n      - `iss` (Issuer)：令牌签发者。\\n      - `sub` (Subject)：令牌主题（通常是用户 ID）。\\n      - `aud` (Audience)：令牌接收者。\\n      - `exp` (Expiration Time)：令牌过期时间戳。\\n      - `nbf` (Not Before)：令牌生效时间戳。\\n      - `iat` (Issued At)：令牌签发时间戳。\\n      - `jti` (JWT ID)：令牌的唯一标识符。\\n    - **Public Claims (公共声明)**：可以随意定义，但为了避免冲突，应该在 IANA JSON Web Token Registry 中定义它们，或者使用包含防冲突命名空间的 URI。\\n    - **Private Claims (私有声明)**：这些是创建它们的应用的特定声明，既非注册声明也非公共声明。是令牌的签发者和使用者共同定义的声明。\\n      负载也会进行 Base64Url 编码形成 JWT 的第二部分。\\n\\n    ```json\\n    {\\n      \\\"sub\\\": \\\"1234567890\\\",\\n      \\\"name\\\": \\\"John Doe\\\",\\n      \\\"admin\\\": true,\\n      \\\"iat\\\": 1516239022\\n    }\\n    ```\\n\\n3.  **Signature (签名)**：用于验证消息在传递过程中没有被篡改，并且对于使用私钥签名的令牌，它还可以验证 JWT 的发送者是谁。\\n    签名是通过将编码后的头部、编码后的负载、一个密钥（secret）、头部中指定的签名算法（如 HMAC SHA256）组合计算得出的。\\n    例如，如果使用 HMAC SHA256 算法，签名的创建方式如下：\\n    ```\\n    HMACSHA256(\\n      base64UrlEncode(header) + \\\".\\\" +\\n      base64UrlEncode(payload),\\n      secret\\n    )\\n    ```\\n    签名部分用于确保 JWT 的完整性。只有持有密钥的一方才能生成有效的签名，也只有持有密钥（或公钥，取决于算法）的一方才能验证签名。\\n\\n将这三部分用点 (`.`) 连接起来就构成了完整的 JWT：`xxxxx.yyyyy.zzzzz`\\n\\n### JWT 是如何工作的？\\n\\n1.  **用户认证**：用户使用其凭据（例如，用户名和密码）登录。\\n2.  **服务器生成并签发 JWT**：服务器验证凭据。如果凭据有效，服务器会创建一个 JWT，其中包含用户的身份信息和其他必要的声明，并使用密钥对其进行签名。然后将此 JWT 返回给客户端。\\n3.  **客户端存储 JWT**：客户端（通常是 Web 浏览器或移动应用）接收到 JWT 后，通常会将其存储在本地，例如浏览器的 Local Storage、Session Storage 或 Cookie 中。\\n4.  **客户端发送 JWT**：当客户端需要访问受保护的路由或资源时，它会在请求的 `Authorization` 头部中以 `Bearer <token>` 的形式附带 JWT。\\n    ```\\n    Authorization: Bearer <token>\\n    ```\\n5.  **服务器验证 JWT**：服务器接收到请求后，会检查 `Authorization` 头部中的 JWT。\\n    - **验证签名**：服务器使用之前签发 JWT 时使用的密钥（或公钥）来验证 JWT 的签名。如果签名无效，说明令牌已被篡改或不是由可信方签发的，请求将被拒绝。\\n    - **验证声明**：如果签名有效，服务器会进一步检查 JWT 中的声明，例如 `exp` (过期时间) 是否已过，`iss` (签发者) 和 `aud` (接收者) 是否符合预期等。\\n6.  **处理请求**：如果 JWT 有效且声明通过验证，服务器将信任 JWT 中的信息，并根据这些信息处理用户的请求，授权其访问相应的资源。\\n\\n### JWT 的优点与缺点\\n\\n**优点：**\\n\\n- **无状态与可扩展性**：由于用户信息和声明都存储在 JWT 本身，服务器端不需要存储会话信息。这使得应用更容易实现无状态架构，从而提高了可伸缩性。在分布式系统中，任何一台服务器只要拥有相同的密钥（或公钥），都可以验证 JWT 并处理请求，无需 Session 同步。\\n- **自包含性**：JWT 中包含了所有必要的用户信息，避免了多次查询数据库来获取用户信息。\\n- **解耦和跨域友好**：JWT 不依赖于 Cookie，因此在跨域认证 (CORS) 和移动应用场景中非常方便。令牌可以直接在 HTTP 头部或请求体中传递。\\n- **安全性**：通过签名机制，可以保证 JWT 在传输过程中不被篡改。可以使用 HTTPS 来进一步保证传输安全。\\n- **适用性广**：可用于身份验证、授权、信息交换等多种场景。\\n\\n**缺点：**\\n\\n- **令牌体积较大**：由于包含了用户信息和声明，JWT 的体积通常比 Session ID 要大，如果包含的声明过多，可能会增加网络传输的开销。\\n- **无法主动吊销**：一旦 JWT 签发，在它过期之前会一直有效，除非采取额外的措施。如果用户的权限发生变更或账户被盗，无法像 Session 那样在服务器端立即将其作废。常见的缓解方案包括：\\n  - 设置较短的过期时间，并配合刷新令牌 (Refresh Token) 机制。\\n  - 维护一个已吊销令牌的黑名单，每次验证 JWT 时查询黑名单 (但这又引入了状态)。\\n- **安全性依赖密钥**：用于签名的密钥 (secret) 至关重要。如果密钥泄露，攻击者就可以伪造有效的 JWT。因此，密钥必须妥善保管。\\n- **不应存储敏感数据**：JWT 的负载部分是 Base64Url 编码的，可以被轻易解码。因此，不应在 JWT 的负载中存储任何敏感信息，除非对负载本身也进行了加密 (JWE - JSON Web Encryption)。签名只保证完整性，不保证机密性。\\n- **续签问题**：如果 JWT 过期时间设置得较短，用户可能需要频繁重新登录。使用刷新令牌可以缓解此问题，但会增加实现的复杂性。\\n\\n## Cookie vs. Session vs. JWT：详细对比\\n\\n| 特性           | Cookie                                                               | Session                                 | JWT (JSON Web Token)                               |\\n| -------------- | -------------------------------------------------------------------- | --------------------------------------- | -------------------------------------------------- |\\n| **存储位置**   | 客户端 (浏览器)                                                      | 服务器端 (客户端存 Session ID)          | 客户端 (如 Local Storage, Session Storage, Cookie) |\\n| **状态管理**   | 客户端存储状态                                                       | 服务器端存储状态                        | 客户端存储状态 (令牌自包含信息)                    |\\n| **数据大小**   | 较小 (约 4KB/个, 域名下数量有限)                                     | 较大 (理论上仅受服务器资源限制)         | 可能较大 (取决于声明内容)                          |\\n| **安全性**     | 较低 (易被 XSS, CSRF 攻击，需 `HttpOnly`, `Secure`, `SameSite` 防护) | 较高 (敏感数据在服务端，ID 被盗有风险)  | 中高 (签名防篡改，依赖密钥安全，不加密则内容可见)  |\\n| **服务器压力** | 较小                                                                 | 较大 (存储和管理 Session 数据)          | 较小 (无状态，仅需验证签名和声明)                  |\\n| **可扩展性**   | -                                                                    | 较低 (分布式环境下需 Session 共享机制)  | 较高 (无状态，易于水平扩展)                        |\\n| **跨域支持**   | 有限 (受同源策略限制，可通过配置支持)                                | 有限 (通常依赖 Cookie 传递 Session ID)  | 良好 (不依赖 Cookie，可在头部或请求体传递)         |\\n| **数据类型**   | 字符串                                                               | 多种数据类型 (对象、数组等)             | JSON 对象 (声明)                                   |\\n| **吊销机制**   | 可通过设置过期时间或服务器端逻辑间接实现                             | 服务器端可主动销毁 Session              | 较难 (默认无法主动吊销，需黑名单或短时效+刷新令牌) |\\n| **依赖性**     | 客户端支持 Cookie                                                    | 通常依赖客户端 Cookie (传递 Session ID) | -                                                  |\\n\\n### 存储位置\\n\\n- **Cookie**：数据直接存储在客户端浏览器中。\\n- **Session**：数据存储在服务器端，客户端仅存储一个 Session ID (通常通过 Cookie)。\\n- **JWT**：令牌本身存储在客户端（例如，浏览器的 Local Storage、Session Storage，或者也可以放在 Cookie 中）。JWT 包含了所有必要的信息，服务器端不需要存储任何与令牌直接相关的会话数据。\\n\\n### 状态管理\\n\\n- **Cookie**：由于数据在客户端，一定程度上可以说是客户端管理状态，但服务器通过读取 Cookie 来识别用户。\\n- **Session**：完全由服务器端管理状态。服务器根据客户端传来的 Session ID 查找对应的会话数据。\\n- **JWT**：服务器是无状态的。所有必要的状态信息（声明）都包含在 JWT 中，由客户端在每次请求时提供给服务器。服务器只需验证令牌的有效性即可。\\n\\n### 安全性\\n\\n- **Cookie**：安全性相对较低。如果未正确配置 `HttpOnly`、`Secure` 和 `SameSite` 属性，容易受到 XSS 和 CSRF 攻击。数据直接暴露在客户端。\\n- **Session**：安全性相对较高，因为敏感数据存储在服务器端。客户端只有一个无意义的 Session ID。但 Session ID 如果被劫持，攻击者可能冒充用户。仍需防范 CSRF。\\n- **JWT**：安全性取决于实现。签名机制可以防止数据篡改。如果密钥泄露，则 JWT 可以被伪造。JWT 的负载部分是 Base64Url 编码的，不是加密的，因此不应在负载中存储敏感信息，除非对 JWT 进行了加密（JWE）。传输时应使用 HTTPS。\\n\\n### 可扩展性\\n\\n- **Cookie**：本身与服务器可扩展性关系不大，但由于其无状态特性，通常用于配合无状态的服务器架构。\\n- **Session**：在分布式或集群环境中，Session 管理会变得复杂。需要额外的机制（如 Session 共享、粘性会话）来确保不同服务器能访问同一用户的 Session 数据，这可能影响可扩展性。\\n- **JWT**：具有良好的可扩展性。由于服务器是无状态的（不需要存储 Session 数据），可以轻松地对应用进行水平扩展。任何一台服务器只要拥有用于验证签名的密钥（或公钥），就可以处理来自客户端的请求。\\n\\n### 跨域支持\\n\\n- **Cookie**：受到浏览器同源策略的限制。跨域发送 Cookie 需要服务器进行正确的 CORS 配置 (如 `Access-Control-Allow-Credentials`)，并且 Cookie 本身也可能需要设置 `SameSite=None; Secure`。\\n- **Session**：通常依赖 Cookie 来传递 Session ID，因此也间接受到 Cookie 跨域问题的制约。\\n- **JWT**：非常适合跨域场景。JWT 可以放在 HTTP 请求的 `Authorization` 头部（作为 Bearer Token）或请求体中发送，不依赖于 Cookie，因此可以轻松绕过 Cookie 的跨域限制。\\n\\n## 何时选择哪种技术？\\n\\n选择哪种技术取决于具体的应用需求、架构以及安全考虑。\\n\\n**选择 Cookie 的场景：**\\n\\n- **简单状态保持**：如果只需要存储少量非敏感信息，例如用户偏好（主题、语言）、\\\"记住我\\\"功能（存储一个长期有效的令牌）、或简单的追踪分析。\\n- **兼容性要求高**：几乎所有浏览器都支持 Cookie，且实现简单。\\n- **与传统 Session 机制配合**：即使使用 Session，通常也需要 Cookie 来存储 Session ID。\\n\\n**不宜单独使用 Cookie 的场景：**\\n\\n- 存储大量或敏感数据。\\n- 对安全性要求极高，且没有充分的 XSS/CSRF 防护措施。\\n\\n**选择 Session 的场景：**\\n\\n- **需要存储敏感或复杂数据**：用户身份信息、权限、购物车详情等，这些数据不适合直接暴露在客户端。\\n- **服务器端状态管理**：希望由服务器完全控制用户会话的状态和生命周期。\\n- **传统单体应用或小型应用**：在非分布式或小型集群环境中，Session 管理相对简单直接。\\n- **需要主动使会话失效**：例如用户修改密码或登出后，服务器可以立即销毁对应的 Session。\\n\\n**使用 Session 时需要注意：**\\n\\n- **服务器资源消耗**：大量并发用户会增加服务器内存或存储压力。\\n- **分布式环境下的扩展性**：需要考虑 Session 共享或同步的解决方案。\\n\\n**选择 JWT 的场景：**\\n\\n- **无状态 API 和微服务**：JWT 的核心优势在于无状态性，非常适合构建可水平扩展的 API 和微服务架构。\\n- **跨域认证 (CORS)**：JWT 不依赖 Cookie，可以轻松用于跨不同域名的服务之间的认证。\\n- **移动应用 (App)**：移动应用通常不使用 Cookie 进行会话管理，JWT 是一个很好的选择。\\n- **单点登录 (SSO)**：JWT 可以在多个相关应用之间安全地传递用户信息，实现单点登录。\\n- **信息交换**：JWT 可以作为一种安全的方式在不同系统或服务之间交换信息，利用其签名机制保证信息未被篡改。\\n- **希望将认证逻辑与应用服务器解耦**：可以使用专门的认证服务器来签发和验证 JWT。\\n\\n**使用 JWT 时需要注意：**\\n\\n- **令牌吊销的复杂性**：需要额外的机制（如黑名单或短有效期+刷新令牌）来处理令牌吊销。\\n- **密钥安全**：签发 JWT 的密钥必须妥善保管，一旦泄露，系统安全性将受到严重威胁。\\n- **令牌体积**：不要在 JWT 中存放过多非必要信息，以免令牌过大影响性能。\\n- **不要存放敏感信息**：JWT 的负载部分默认是可读的，敏感信息需要额外加密（JWE）或不应放入 JWT。\\n\\n**总结选择思路：**\\n\\n1.  **简单、非敏感、客户端信息** -> 优先考虑 Cookie。\\n2.  **敏感信息、服务器端控制、传统应用** -> Session 是经典选择。\\n3.  **无状态、可扩展、API、微服务、跨域、移动端** -> JWT 通常是更现代和灵活的选择。\\n\\n在实际应用中，这些技术也可能组合使用。例如，使用 Session 进行 Web 应用的会话管理，同时使用 JWT 为移动 App 或第三方应用提供 API 认证。或者使用 Cookie 来存储 JWT（但要注意设置 `HttpOnly` 以增强安全性）。\\n\\n## 总结\\n\\nCookie、Session 和 JWT 是 Web 开发中用于管理用户状态和实现认证授权的三种核心技术。它们各有特点，适用于不同的场景：\\n\\n- **Cookie** 以其简单性和广泛的浏览器支持，在存储少量非敏感数据和基本的用户偏好设置方面非常有用。然而，其安全性较低和大小限制使其不适合存储敏感信息或大量数据。\\n\\n- **Session** 通过在服务器端存储用户数据，提供了更高的安全性，适合管理敏感的用户会话信息。但它给服务器带来了存储和管理开销，并且在分布式环境下存在扩展性挑战。\\n\\n- **JWT** 作为一种现代的、基于令牌的无状态认证机制，凭借其自包含性、可扩展性和跨域友好性，在 API 认证、微服务架构和移动应用中表现出色。其主要挑战在于令牌的吊销管理和密钥的安全性。\\n\\n理解这三种技术的内在机制、权衡它们的优缺点，并根据应用的具体需求（如安全性要求、系统架构、可扩展性、用户体验等）做出明智的选择，是每一位 Web 开发者的必备技能。没有一种技术是万能的，合适的才是最好的。希望本文能帮助你更清晰地认识 Cookie、Session 和 JWT，并在你的项目中做出更优的技术选型。\\n\",\"wordCount\":6168},{\"id\":\"de5fa13e\",\"title\":\"垃圾回收\",\"date\":\"2021-02-19\",\"tags\":[\"浏览器\"],\"fileName\":\"垃圾回收.md\",\"content\":\"\\n## 浏览器垃圾回收机制详解\\n\\n在现代 Web 应用程序中，内存管理是一个至关重要的话题。JavaScript 作为一种高级编程语言，提供了自动垃圾回收机制，帮助开发者管理内存。本文将深入探讨浏览器中的垃圾回收机制，包括其必要性、常见算法、优缺点以及与闭包相关的内存泄漏问题。\\n\\n## 为什么需要垃圾回收\\n\\n在编程语言中，内存管理主要有两种方式：手动管理和自动管理。像 C/C++ 这样的语言需要程序员手动分配和释放内存，而 JavaScript 等高级语言则采用自动垃圾回收机制。\\n\\n垃圾回收的必要性主要体现在以下几个方面：\\n\\n1. **避免内存泄漏**：如果不及时释放不再使用的内存，应用程序会逐渐消耗更多的系统资源，最终导致性能下降甚至崩溃。\\n\\n2. **提高开发效率**：自动垃圾回收让开发者可以专注于业务逻辑，而不必担心内存管理的细节。\\n\\n3. **减少错误**：手动内存管理容易出现错误，如忘记释放内存、重复释放内存或使用已释放的内存，这些都可能导致程序崩溃或不可预测的行为。\\n\\n4. **优化资源使用**：通过自动识别和回收不再需要的内存，系统可以更有效地利用有限的资源。\\n\\n## 垃圾回收的算法和原理\\n\\nJavaScript 引擎中实现了多种垃圾回收算法，每种算法都有其特点和适用场景。以下是几种主要的垃圾回收算法：\\n\\n### 1. 引用计数（Reference Counting）\\n\\n**原理**：\\n\\n引用计数是最简单的垃圾回收算法之一。它的基本思想是跟踪记录每个对象被引用的次数。当一个对象被创建并赋值给一个变量时，其引用计数为1；当另一个变量也指向这个对象时，引用计数加1；当指向该对象的变量被赋予新值或离开作用域时，引用计数减1。当引用计数降为0时，表示该对象不再被使用，可以被回收。\\n\\n```javascript\\nlet obj = { name: '示例对象' }; // 引用计数为1\\nlet reference = obj; // 引用计数为2\\nreference = null; // 引用计数减为1\\nobj = null; // 引用计数减为0，对象可被回收\\n```\\n\\n**优点**：\\n\\n- 实现简单直观\\n- 对象可以立即被回收\\n- 不会出现暂停应用程序的情况\\n\\n**缺点**：\\n\\n- 无法处理循环引用问题\\n- 需要额外的内存来存储引用计数\\n- 频繁更新引用计数会带来性能开销\\n\\n**循环引用问题示例**：\\n\\n```javascript\\nfunction createCycle() {\\n  let obj1 = {};\\n  let obj2 = {};\\n\\n  obj1.ref = obj2; // obj1引用obj2\\n  obj2.ref = obj1; // obj2引用obj1\\n\\n  return '循环引用创建完成';\\n}\\n\\ncreateCycle(); // 即使函数执行完毕，obj1和obj2由于互相引用，引用计数不为0，无法被回收\\n```\\n\\n### 2. 标记-清除（Mark-Sweep）\\n\\n**原理**：\\n\\n标记-清除算法是现代浏览器中最常用的垃圾回收算法之一。它分为两个阶段：\\n\\n1. **标记阶段**：从根对象（如全局对象、当前执行上下文中的变量）开始，递归遍历所有可达对象，并标记它们为\\\"活动\\\"。\\n2. **清除阶段**：遍历整个内存空间，回收所有未被标记的对象。\\n\\n```javascript\\n// 假设有以下对象\\nlet obj1 = { data: 'some data' };\\nlet obj2 = { data: 'more data' };\\nlet obj3 = { data: 'extra data' };\\n\\n// 建立引用关系\\nobj1.next = obj2;\\n// obj3没有被任何变量引用\\n\\n// 垃圾回收执行时：\\n// 1. 标记阶段：obj1和obj2被标记为活动\\n// 2. 清除阶段：obj3未被标记，将被回收\\n```\\n\\n**优点**：\\n\\n- 可以解决循环引用问题\\n- 相对引用计数，内存开销较小\\n\\n**缺点**：\\n\\n- 回收过程中会暂停应用程序执行（\\\"Stop The World\\\"）\\n- 可能导致内存碎片化\\n- 回收效率可能不高，尤其是在大量对象存活的情况下\\n\\n### 3. 标记-整理（Mark-Compact）\\n\\n**原理**：\\n\\n标记-整理算法是标记-清除算法的改进版本，增加了一个整理阶段：\\n\\n1. **标记阶段**：与标记-清除算法相同，标记所有可达对象。\\n2. **整理阶段**：将所有存活的对象移动到内存的一端，形成连续的内存空间。\\n3. **清除阶段**：清除边界外的所有内存。\\n\\n**优点**：\\n\\n- 解决了内存碎片化问题\\n- 提高了内存分配的效率\\n\\n**缺点**：\\n\\n- 比标记-清除算法更复杂\\n- 移动对象需要额外的计算资源\\n- 同样会暂停应用程序执行\\n\\n### 4. 分代回收（Generational Collection）\\n\\n**原理**：\\n\\n分代回收基于一个经验法则：大多数对象在创建后很快就变得不可用，而存活较长时间的对象往往会继续存活。因此，将内存分为新生代和老生代：\\n\\n1. **新生代**：存放新创建的对象，采用较频繁的垃圾回收。\\n2. **老生代**：存放经过多次垃圾回收仍然存活的对象，采用较少频率的垃圾回收。\\n\\n**优点**：\\n\\n- 针对不同生命周期的对象采用不同的回收策略，提高效率\\n- 减少了全堆扫描的次数\\n- 减少了应用程序暂停的时间\\n\\n**缺点**：\\n\\n- 实现复杂\\n- 需要额外的内存空间来管理代际信息\\n\\n## 现代浏览器中的垃圾回收\\n\\n现代浏览器的JavaScript引擎（如V8、SpiderMonkey、JavaScriptCore）通常采用组合策略：\\n\\n- **V8引擎（Chrome、Node.js）**：使用分代回收，新生代使用Scavenge算法（一种复制算法），老生代使用标记-清除和标记-整理的结合。\\n- **SpiderMonkey（Firefox）**：使用增量标记-清除算法，减少垃圾回收对性能的影响。\\n- **JavaScriptCore（Safari）**：使用分代回收和多种优化技术。\\n\\n## 内存泄漏与闭包的关系\\n\\n闭包是JavaScript中一个强大的特性，但如果使用不当，容易导致内存泄漏。\\n\\n### 什么是闭包\\n\\n闭包是指一个函数可以访问其词法作用域外的变量，即使该函数在其定义环境之外执行。\\n\\n```javascript\\nfunction createCounter() {\\n  let count = 0;\\n  return function () {\\n    return ++count;\\n  };\\n}\\n\\nconst counter = createCounter();\\nconsole.log(counter()); // 1\\nconsole.log(counter()); // 2\\n```\\n\\n在上面的例子中，返回的函数形成了一个闭包，它可以访问并修改`count`变量，即使`createCounter`函数已经执行完毕。\\n\\n### 闭包导致的内存泄漏\\n\\n闭包本身不会导致内存泄漏，但不恰当的使用可能会。主要有以下几种情况：\\n\\n1. **长时间持有闭包**：如果一个闭包被长时间持有（如全局变量），那么它引用的所有变量也会被长时间保留在内存中，即使这些变量可能不再需要。\\n\\n```javascript\\n// 全局变量持有闭包\\nlet globalFunction;\\n\\nfunction setupFunction() {\\n  let largeData = new Array(1000000).fill('potentially large data');\\n\\n  globalFunction = function () {\\n    // 使用largeData做一些操作\\n    console.log(largeData.length);\\n  };\\n}\\n\\nsetupFunction(); // largeData会一直存在于内存中，因为globalFunction引用了它\\n```\\n\\n2. **DOM引用**：在闭包中引用DOM元素，但后续该元素被移除，如果闭包仍然存在，会阻止垃圾回收器回收该DOM元素。\\n\\n```javascript\\nfunction addHandler() {\\n  let element = document.getElementById('button');\\n\\n  element.addEventListener('click', function () {\\n    // 这个闭包引用了外部的element变量\\n    console.log(element.id);\\n  });\\n\\n  // 即使后续移除了这个元素，由于事件处理器中的闭包引用了它，它不会被垃圾回收\\n  document.body.removeChild(element);\\n}\\n```\\n\\n3. **定时器**：在setInterval或setTimeout中使用闭包，如果不清除定时器，闭包及其引用的变量会一直存在。\\n\\n```javascript\\nfunction startTimer() {\\n  let data = loadLargeData();\\n\\n  setInterval(function () {\\n    // 使用data\\n    console.log(data.length);\\n  }, 1000);\\n\\n  // 如果不调用clearInterval，data将永远存在于内存中\\n}\\n```\\n\\n4. **多个函数共享词法环境**：当多个函数共享同一个词法环境时，如果其中一个函数被长时间持有，那么其他函数引用的变量也会被长时间保留在内存中。\\n\\n```javascript\\nfunction createFunctions() {\\n  let arr = new Array(1000000).fill('large data');\\n\\n  return [\\n    // 即使手动销毁了这个函数，arr 占用的内存也不会被释放，因为还有一个函数能够访问的到 arr\\n    function () {\\n      console.log(arr[0]);\\n    },\\n    function () {\\n      // 没有用到词法环境中的任何变量\\n    },\\n  ];\\n}\\n```\\n\\n### 如何避免闭包导致的内存泄漏\\n\\n1. **及时清除引用**：当不再需要某个闭包时，将其设置为null。\\n\\n```javascript\\nlet closure = (function () {\\n  let largeData = new Array(1000000);\\n  return function () {\\n    return largeData.length;\\n  };\\n})();\\n\\n// 使用完毕后\\nclosure = null; // 允许垃圾回收器回收闭包及其引用的数据\\n```\\n\\n2. **避免循环引用**：特别是在涉及DOM元素时。\\n\\n```javascript\\nfunction addHandler() {\\n  let element = document.getElementById('button');\\n\\n  let onClick = function () {\\n    console.log('Button clicked');\\n  };\\n\\n  element.addEventListener('click', onClick);\\n\\n  // 当不再需要这个元素时\\n  element.removeEventListener('click', onClick);\\n  element = null;\\n}\\n```\\n\\n3. **使用弱引用**：在ES6中，可以使用WeakMap和WeakSet来存储对象的弱引用，这些引用不会阻止垃圾回收。\\n\\n```javascript\\n// 使用WeakMap存储与DOM元素相关的数据\\nconst cache = new WeakMap();\\n\\nfunction processElement(element) {\\n  // 检查缓存\\n  if (cache.has(element)) {\\n    return cache.get(element);\\n  }\\n\\n  // 处理元素\\n  const result = expensiveComputation(element);\\n\\n  // 存储结果\\n  cache.set(element, result);\\n\\n  return result;\\n}\\n\\n// 当element被垃圾回收时，cache中对应的条目也会自动被回收\\n```\\n\\n## 总结\\n\\n浏览器的垃圾回收机制是JavaScript内存管理的核心部分，它通过自动识别和回收不再使用的内存，帮助开发者构建高效、稳定的Web应用。\\n\\n不同的垃圾回收算法各有优缺点：\\n\\n- 引用计数简单直观但无法处理循环引用\\n- 标记-清除可以解决循环引用但可能导致内存碎片\\n- 标记-整理解决了内存碎片问题但需要额外的计算资源\\n- 分代回收针对不同生命周期的对象采用不同策略，提高了效率\\n\\n闭包是JavaScript中的强大特性，但不恰当的使用可能导致内存泄漏。了解闭包与垃圾回收的关系，采取适当的措施（如及时清除引用、避免循环引用、使用弱引用等），可以有效避免内存泄漏问题。\\n\\n作为开发者，我们不需要手动触发垃圾回收，但了解其工作原理有助于编写更高效、更可靠的代码，避免潜在的内存问题。\\n\",\"wordCount\":2016},{\"id\":\"8949c858\",\"title\":\"async 和 await 详解\",\"date\":\"2020-10-25\",\"tags\":[\"javascript\",\"es6\"],\"fileName\":\"async 和 await 详解.md\",\"content\":\"\\n## 基本概念\\n\\nasync/await 是 Promise 的语法糖，让异步代码看起来像同步代码。\\n\\n```js\\n// Promise 方式\\nfunction getData() {\\n  return fetch('https://api.example.com/data')\\n    .then(response => response.json())\\n    .then(data => console.log(data));\\n}\\n\\n// async/await 方式\\nasync function getData() {\\n  const response = await fetch('https://api.example.com/data');\\n  const data = await response.json();\\n  console.log(data);\\n}\\n```\\n\\n## async 函数\\n\\n```js\\n// async 函数总是返回 Promise\\nasync function example() {\\n  return 'hello';  // 自动包装成 Promise\\n}\\n\\n// 等价于\\nfunction example() {\\n  return Promise.resolve('hello');\\n}\\n\\n// 使用\\nexample().then(result => console.log(result)); // 'hello'\\n```\\n\\n## await 关键字\\n\\n```js\\nasync function example() {\\n  // await 等待 Promise 完成\\n  const result1 = await promise1;\\n  const result2 = await promise2;\\n  return result1 + result2;\\n}\\n\\n// await 可以等待任何值\\nconst str = await 'hello'; // 直接返回\\nconst num = await 123; // 直接返回\\nconst p = await Promise.resolve('world'); // 等待 Promise 完成\\n```\\n\\n## 错误处理\\n\\n```js\\n// 方式1：try/catch\\nasync function example() {\\n  try {\\n    const response = await fetch('https://api.example.com/data');\\n    const data = await response.json();\\n    return data;\\n  } catch (error) {\\n    console.error('Error:', error);\\n  }\\n}\\n\\n// 方式2：链式调用\\nasync function example() {\\n  const data = await fetch('https://api.example.com/data')\\n    .then(response => response.json())\\n    .catch(error => console.error(error));\\n  return data;\\n}\\n```\\n\\n## 并行执行\\n\\n```js\\n// 串行执行 - 较慢\\nasync function serial() {\\n  const result1 = await asyncOperation1();\\n  const result2 = await asyncOperation2();\\n  return [result1, result2];\\n}\\n\\n// 并行执行 - 较快\\nasync function parallel() {\\n  // Promise.all\\n  const [result1, result2] = await Promise.all([\\n    asyncOperation1(),\\n    asyncOperation2()\\n  ]);\\n  return [result1, result2];\\n\\n  // 或者\\n  const promise1 = asyncOperation1();  // 立即开始执行\\n  const promise2 = asyncOperation2();  // 立即开始执行\\n  const result1 = await promise1;      // 等待完成\\n  const result2 = await promise2;      // 等待完成\\n}\\n```\\n\\n## 实际应用场景\\n\\n```js\\n// 1. API 请求\\nasync function fetchUserData(userId) {\\n  try {\\n    const response = await fetch(`/api/users/${userId}`);\\n    const userData = await response.json();\\n    return userData;\\n  } catch (error) {\\n    console.error('Failed to fetch user:', error);\\n    throw error;\\n  }\\n}\\n\\n// 2. 多个依赖请求\\nasync function getUserWithPosts(userId) {\\n  // 并行请求用户信息和文章\\n  const [user, posts] = await Promise.all([fetchUser(userId), fetchUserPosts(userId)]);\\n\\n  return {\\n    ...user,\\n    posts,\\n  };\\n}\\n\\n// 3. 条件请求\\nasync function conditionalFetch(id) {\\n  const data = await fetchInitialData(id);\\n\\n  if (data.needsExtra) {\\n    const extraData = await fetchExtraData(id);\\n    return { ...data, ...extraData };\\n  }\\n\\n  return data;\\n}\\n```\\n\\n## 循环中的 async/await\\n\\n```js\\n// 串行处理\\nasync function processArray(array) {\\n  for (const item of array) {\\n    await processItem(item);  // 一个接一个处理\\n  }\\n}\\n\\n// 并行处理\\nasync function processArray(array) {\\n  const promises = array.map(item => processItem(item));\\n  await Promise.all(promises);  // 同时处理所有项\\n}\\n\\n// forEach 不能正确处理 async/await\\narray.forEach(async item => {  // 错误！不会等待\\n  await processItem(item);\\n});\\n```\\n\\n## 最佳实践\\n\\n```js\\n// 1. 总是使用 try/catch 处理错误\\nasync function example() {\\n  try {\\n    const result = await riskyOperation();\\n    return result;\\n  } catch (error) {\\n    // 处理错误\\n    console.error(error);\\n    // 可以选择重新抛出\\n    throw error;\\n  }\\n}\\n\\n// 2. 合理使用并行处理\\nasync function fetchAllData() {\\n  const [users, posts, comments] = await Promise.all([\\n    fetchUsers(),\\n    fetchPosts(),\\n    fetchComments()\\n  ]);\\n  return { users, posts, comments };\\n}\\n\\n// 3. 避免无谓的 await\\nasync function example() {\\n  const promise = fetchData();  // 立即开始\\n  // 做其他事情\\n  const result = await promise; // 需要结果时才等待\\n}\\n```\\n\\n## async/await 向 promise 转换示例\\n\\n### async 函数\\n\\n```js\\n// async 函数\\nasync function foo() {\\n  return 'hello';\\n}\\n\\n// 转换为 Promise\\nfunction foo() {\\n  return Promise.resolve('hello');\\n}\\n```\\n\\n### await 表达式\\n\\n```js\\n// async/await 版本\\nasync function example() {\\n  const result = await somePromise();\\n  return result + 1;\\n}\\n\\n// 转换为 Promise 版本\\nfunction example() {\\n  return new Promise((resolve, reject) => {\\n    somePromise()\\n      .then(result => {\\n        resolve(result + 1);\\n      })\\n      .catch(reject);\\n  });\\n}\\n```\\n\\n### 多个 await 表达式\\n\\n```js\\n// async/await 版本\\nasync function getData() {\\n  const data1 = await fetch('/api/data1');\\n  const data2 = await fetch('/api/data2');\\n  return data1 + data2;\\n}\\n\\n// 转换为 Promise 版本\\nfunction getData() {\\n  return new Promise((resolve, reject) => {\\n    fetch('/api/data1')\\n      .then(data1 => {\\n        return fetch('/api/data2')\\n          .then(data2 => {\\n            resolve(data1 + data2);\\n          });\\n      })\\n      .catch(reject);\\n  });\\n}\\n```\\n\\n### try/catch\\n\\n```js\\n// async/await 版本\\nasync function example() {\\n  try {\\n    const result = await riskyOperation();\\n    return result;\\n  } catch (error) {\\n    console.error(error);\\n    return 'default';\\n  }\\n}\\n\\n// 转换为 Promise 版本\\nfunction example() {\\n  return new Promise((resolve) => {\\n    riskyOperation()\\n      .then(result => {\\n        resolve(result);\\n      })\\n      .catch(error => {\\n        console.error(error);\\n        resolve('default');\\n      });\\n  });\\n}\\n```\\n\\n### 复杂流程控制\\n\\n```js\\n// async/await 版本\\nasync function processData() {\\n  const data = await fetchData();\\n  if (data.needsExtra) {\\n    const extra = await fetchExtra();\\n    return { ...data, ...extra };\\n  }\\n  return data;\\n}\\n\\n// 转换为 Promise 版本\\nfunction processData() {\\n  return new Promise((resolve, reject) => {\\n    fetchData()\\n      .then(data => {\\n        if (data.needsExtra) {\\n          return fetchExtra()\\n            .then(extra => {\\n              resolve({ ...data, ...extra });\\n            });\\n        }\\n        resolve(data);\\n      })\\n      .catch(reject);\\n  });\\n}\\n```\\n\\n### 循环\\n\\n```js\\n// async/await 版本\\nasync function processItems(items) {\\n  const results = [];\\n  for (const item of items) {\\n    const result = await processItem(item);\\n    results.push(result);\\n  }\\n  return results;\\n}\\n\\n// 转换为 Promise 版本\\nfunction processItems(items) {\\n  return new Promise((resolve, reject) => {\\n    const results = [];\\n    let promise = Promise.resolve();\\n\\n    items.forEach(item => {\\n      promise = promise\\n        .then(() => processItem(item))\\n        .then(result => {\\n          results.push(result);\\n        });\\n    });\\n\\n    promise\\n      .then(() => resolve(results))\\n      .catch(reject);\\n  });\\n}\\n```\\n\\n### 并行操作\\n\\n```js\\n// async/await 版本\\nasync function parallel() {\\n  const [result1, result2] = await Promise.all([\\n    asyncOp1(),\\n    asyncOp2()\\n  ]);\\n  return result1 + result2;\\n}\\n\\n// 转换为 Promise 版本\\nfunction parallel() {\\n  return Promise.all([asyncOp1(), asyncOp2()])\\n    .then(([result1, result2]) => {\\n      return result1 + result2;\\n    });\\n}\\n```\\n\\n**转换的核心原则：**\\n\\n- async 函数总是返回 Promise\\n- await 表达式转换为 .then() 调用\\n- 错误处理转换为 .catch()\\n- 保持执行顺序\\n- 维护变量作用域\\n\\n这种转换通常是由 JavaScript 引擎或转译器（如 Babel）自动完成的，我们不需要手动进行这种转换。理解这个转换过程有助于我们更好地理解 async/await 的工作原理。\\n\\n## 注意事项\\n\\n1. async 函数总是返回 Promise\\n2. await 只能在 async 函数内使用\\n3. 错误会沿着调用链传播\\n4. 注意区分串行和并行操作\\n5. 小心循环中的 async/await\\n\\nasync/await 是现代 JavaScript 中处理异步操作的最佳方式，它让异步代码更容易理解和维护。合理使用 async/await 可以大大提高代码的可读性和可维护性。\\n\",\"wordCount\":303},{\"id\":\"9787dfb3\",\"title\":\"手写一个简易版的 Promise\",\"date\":\"2020-10-21\",\"tags\":[\"javascript\",\"es6\"],\"fileName\":\"手写一个简易版的 Promise.md\",\"content\":\"\\n## 前言\\n\\nPromise 是 JavaScript 中用于处理异步操作的对象，它代表了一个异步操作的最终完成（或失败）及其结果值。\\n\\n## 用法\\n\\n### 创建 Promise\\n\\n```js\\nconst promise = new Promise((resolve, reject) => {\\n  setTimeout(() => {\\n    resolve('成功');\\n  }, 1000);\\n});\\n```\\n\\n### 使用 Promise\\n\\n```js\\npromise.then((result) => {\\n  console.log(result);\\n});\\n```\\n\\n## 实现原理\\n\\n### 基础结构和构造函数\\n\\n```js\\nclass MyPromise {\\n  constructor(fn) {\\n    // Promise 状态\\n    this.status = 'pending';\\n    // 成功值\\n    this.value = null;\\n    // 失败原因\\n    this.reason = null;\\n    // 成功回调队列\\n    this.onFulfilledCallbacks = [];\\n    // 失败回调队列\\n    this.onRejectedCallbacks = [];\\n\\n    // resolve 处理函数\\n    const resolve = (value) => {\\n      if (this.status === 'pending') {\\n        this.status = 'fulfilled';\\n        this.value = value;\\n        this.onFulfilledCallbacks.forEach((callback) => callback(value));\\n      }\\n    };\\n\\n    // reject 处理函数\\n    const reject = (reason) => {\\n      if (this.status === 'pending') {\\n        this.status = 'rejected';\\n        this.reason = reason;\\n        this.onRejectedCallbacks.forEach((callback) => callback(reason));\\n      }\\n    };\\n\\n    // 执行传入的函数\\n    try {\\n      fn(resolve, reject);\\n    } catch (error) {\\n      reject(error);\\n    }\\n  }\\n}\\n```\\n\\n关键点：\\n\\n- 维护 Promise 的三种状态：pending、fulfilled、rejected\\n- 使用回调队列存储异步操作的回调函数\\n- 状态一旦改变就不可逆\\n\\n### then 方法实现\\n\\n```js\\nthen(onFulfilled, onRejected) {\\n  // 参数校验，确保是函数\\n  onFulfilled =\\n    typeof onFulfilled === \\\"function\\\" ? onFulfilled : (value) => value;\\n  onRejected =\\n    typeof onRejected === \\\"function\\\"\\n      ? onRejected\\n      : (reason) => {\\n          throw reason;\\n        };\\n  // 返回新的 Promise 以支持链式调用\\n  const promise2 = new MyPromise((resolve, reject) => {\\n    if (this.status === \\\"fulfilled\\\") {\\n      setTimeout(() => {\\n        try {\\n          const x = onFulfilled(this.value);\\n          resolvePromise(promise2, x, resolve, reject);\\n        } catch (error) {\\n          reject(error);\\n        }\\n      });\\n    }\\n    if (this.status === \\\"rejected\\\") {\\n      setTimeout(() => {\\n        try {\\n          const x = onRejected(this.reason);\\n          resolvePromise(promise2, x, resolve, reject);\\n        } catch (error) {\\n          reject(error);\\n        }\\n      });\\n    }\\n    if (this.status === \\\"pending\\\") {\\n      this.onFulfilledCallbacks.push(() => {\\n        setTimeout(() => {\\n          try {\\n            const x = onFulfilled(this.value);\\n            resolvePromise(promise2, x, resolve, reject);\\n          } catch (error) {\\n            reject(error);\\n          }\\n        });\\n      });\\n      this.onRejectedCallbacks.push(() => {\\n        setTimeout(() => {\\n          try {\\n            const x = onRejected(this.reason);\\n            resolvePromise(promise2, x, resolve, reject);\\n          } catch (error) {\\n            reject(error);\\n          }\\n        });\\n      });\\n    }\\n  });\\n  return promise2;\\n}\\n```\\n\\n关键点：\\n\\n- 支持链式调用\\n- 使用 setTimeout 确保异步执行\\n- 处理返回值的 Promise 状态\\n\\n### resolvePromise 方法实现\\n\\n```js\\nfunction resolvePromise(promise2, x, resolve, reject) {\\n  // 防止循环引用\\n  if (promise2 === x) {\\n    return reject(new TypeError('Chaining cycle detected for promise'));\\n  }\\n\\n  // 处理返回值为 Promise 的情况\\n  if (x instanceof MyPromise) {\\n    x.then((value) => {\\n      resolvePromise(promise2, value, resolve, reject);\\n    }).catch(reject);\\n  } else {\\n    // 普通值直接 resolve\\n    resolve(x);\\n  }\\n}\\n```\\n\\n关键点：\\n\\n- 处理循环引用问题\\n- 处理返回值为 Promise 的情况\\n- 递归解析 Promise\\n\\n### 静态方法实现\\n\\n```js\\n// 创建一个已完成的 Promise\\nstatic resolve(value) {\\n  return new MyPromise(resolve => resolve(value));\\n}\\n\\n// 创建一个已拒绝的 Promise\\nstatic reject(reason) {\\n  return new MyPromise((_, reject) => reject(reason));\\n}\\n\\n// 等待所有 Promise 完成\\nstatic all(promises) {\\n  return new MyPromise((resolve, reject) => {\\n    const results = [];\\n    promises.forEach((promise, index) => {\\n      MyPromise.resolve(promise)\\n        .then(value => {\\n          results[index] = value;\\n          if (results.length === promises.length) {\\n            resolve(results);\\n          }\\n        })\\n        .catch(reject);\\n    });\\n  });\\n}\\n\\n// 返回最先完成的 Promise\\nstatic race(promises) {\\n  return new MyPromise((resolve, reject) => {\\n    promises.forEach(promise => {\\n      MyPromise.resolve(promise)\\n        .then(resolve)\\n        .catch(reject);\\n    });\\n  });\\n}\\n\\n// 返回所有 Promise 的状态和结果\\nstatic allSettled(promises) {\\n  return new MyPromise((resolve) => {\\n    const results = [];\\n    promises.forEach((promise, index) => {\\n      MyPromise.resolve(promise)\\n        .then((value) => {\\n          results[index] = { status: \\\"fulfilled\\\", value };\\n          if (results.length === promises.length) {\\n            resolve(results);\\n          }\\n        })\\n        .catch((reason) => {\\n          results[index] = { status: \\\"rejected\\\", reason };\\n          if (results.length === promises.length) {\\n            resolve(results);\\n          }\\n        });\\n    });\\n  });\\n}\\n```\\n\\n### 辅助方法实现\\n\\n```js\\n// 错误处理\\ncatch(onRejected) {\\n  return this.then(null, onRejected);\\n}\\n\\n// 无论成功失败都会执行\\nfinally(callback) {\\n  return this.then(callback, callback);\\n}\\n```\\n\\n## 完整代码\\n\\n```js\\n// 手写简版 promise\\nclass MyPromise {\\n  constructor(fn) {\\n    this.status = 'pending';\\n    this.value = null;\\n    this.reason = null;\\n    this.onFulfilledCallbacks = [];\\n    this.onRejectedCallbacks = [];\\n    const resolve = (value) => {\\n      if (this.status === 'pending') {\\n        this.status = 'fulfilled';\\n        this.value = value;\\n        this.onFulfilledCallbacks.forEach((callback) => callback(value));\\n      }\\n    };\\n    const reject = (reason) => {\\n      if (this.status === 'pending') {\\n        this.status = 'rejected';\\n        this.reason = reason;\\n        this.onRejectedCallbacks.forEach((callback) => callback(reason));\\n      }\\n    };\\n    try {\\n      fn(resolve, reject);\\n    } catch (error) {\\n      reject(error);\\n    }\\n  }\\n  then(onFulfilled, onRejected) {\\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (value) => value;\\n    onRejected =\\n      typeof onRejected === 'function'\\n        ? onRejected\\n        : (reason) => {\\n            throw reason;\\n          };\\n    const promise2 = new MyPromise((resolve, reject) => {\\n      if (this.status === 'fulfilled') {\\n        setTimeout(() => {\\n          try {\\n            const x = onFulfilled(this.value);\\n            resolvePromise(promise2, x, resolve, reject);\\n          } catch (error) {\\n            reject(error);\\n          }\\n        });\\n      }\\n      if (this.status === 'rejected') {\\n        setTimeout(() => {\\n          try {\\n            const x = onRejected(this.reason);\\n            resolvePromise(promise2, x, resolve, reject);\\n          } catch (error) {\\n            reject(error);\\n          }\\n        });\\n      }\\n      if (this.status === 'pending') {\\n        this.onFulfilledCallbacks.push(() => {\\n          setTimeout(() => {\\n            try {\\n              const x = onFulfilled(this.value);\\n              resolvePromise(promise2, x, resolve, reject);\\n            } catch (error) {\\n              reject(error);\\n            }\\n          });\\n        });\\n        this.onRejectedCallbacks.push(() => {\\n          setTimeout(() => {\\n            try {\\n              const x = onRejected(this.reason);\\n              resolvePromise(promise2, x, resolve, reject);\\n            } catch (error) {\\n              reject(error);\\n            }\\n          });\\n        });\\n      }\\n    });\\n    return promise2;\\n  }\\n  catch(onRejected) {\\n    return this.then(null, onRejected);\\n  }\\n  finally(callback) {\\n    return this.then(callback, callback);\\n  }\\n  static resolve(value) {\\n    return new MyPromise((resolve) => resolve(value));\\n  }\\n  static reject(reason) {\\n    return new MyPromise((_, reject) => reject(reason));\\n  }\\n  static all(promises) {\\n    return new MyPromise((resolve, reject) => {\\n      const results = [];\\n      promises.forEach((promise, index) => {\\n        MyPromise.resolve(promise)\\n          .then((value) => {\\n            results[index] = value;\\n            if (results.length === promises.length) {\\n              resolve(results);\\n            }\\n          })\\n          .catch(reject);\\n      });\\n    });\\n  }\\n  static race(promises) {\\n    return new MyPromise((resolve, reject) => {\\n      promises.forEach((promise) => {\\n        MyPromise.resolve(promise).then(resolve).catch(reject);\\n      });\\n    });\\n  }\\n  static allSettled(promises) {\\n    return new MyPromise((resolve) => {\\n      const results = [];\\n      promises.forEach((promise, index) => {\\n        MyPromise.resolve(promise)\\n          .then((value) => {\\n            results[index] = { status: 'fulfilled', value };\\n            if (results.length === promises.length) {\\n              resolve(results);\\n            }\\n          })\\n          .catch((reason) => {\\n            results[index] = { status: 'rejected', reason };\\n            if (results.length === promises.length) {\\n              resolve(results);\\n            }\\n          });\\n      });\\n    });\\n  }\\n}\\n\\nfunction resolvePromise(promise2, x, resolve, reject) {\\n  if (promise2 === x) {\\n    return reject(new TypeError('Chaining cycle detected for promise'));\\n  }\\n  if (x instanceof MyPromise) {\\n    x.then((value) => {\\n      resolvePromise(promise2, value, resolve, reject);\\n    }).catch(reject);\\n  } else {\\n    resolve(x);\\n  }\\n}\\n```\\n\\n## 总结\\n\\n这个实现涵盖了 Promise 的主要特性：\\n\\n- Promise 状态管理\\n- 异步操作处理\\n- 链式调用\\n- 错误处理\\n- 常用静态方法\\n\\n需要注意的是，这是一个简化版的实现，完整的 Promise/A+ 规范还包括更多的边界情况处理。但这个实现已经可以满足大多数使用场景。\\n\",\"wordCount\":274},{\"id\":\"b38cfa01\",\"title\":\"Promise 指南\",\"date\":\"2020-10-15\",\"tags\":[\"javascript\",\"es6\"],\"fileName\":\"Promise 指南.md\",\"content\":\"\\n## Promise 是什么\\n\\nPromise 是 JavaScript 中用于处理异步操作的对象，它代表了一个异步操作的最终完成（或失败）及其结果值。\\n\\n## Promise 的状态\\n\\nPromise 有三种状态：\\n\\n```js\\n// 1. pending（进行中）\\nconst promise = new Promise((resolve, reject) => {\\n  // 异步操作尚未完成\\n});\\n\\n// 2. fulfilled（已成功）\\nconst promise = new Promise((resolve, reject) => {\\n  resolve('success');\\n});\\n\\n// 3. rejected（已失败）\\nconst promise = new Promise((resolve, reject) => {\\n  reject('error');\\n});\\n```\\n\\n特点：\\n\\n- 状态只能从 pending 转为 fulfilled 或 rejected\\n- 状态一旦改变，就不会再变\\n\\n## Promise 的基本用法\\n\\n```js\\n// 创建 Promise\\nconst promise = new Promise((resolve, reject) => {\\n  // 异步操作\\n  setTimeout(() => {\\n    if (/* 操作成功 */) {\\n      resolve('success');\\n    } else {\\n      reject('error');\\n    }\\n  }, 1000);\\n});\\n\\n// 使用 Promise\\npromise\\n  .then(result => {\\n    console.log(result); // 处理成功\\n  })\\n  .catch(error => {\\n    console.log(error);  // 处理失败\\n  })\\n  .finally(() => {\\n    console.log('完成'); // 无论成功失败\\n  });\\n```\\n\\n## Promise 的链式调用\\n\\n```js\\n// 链式调用示例\\nnew Promise((resolve, reject) => {\\n  resolve(1);\\n})\\n  .then((value) => {\\n    return value + 1; // 2\\n  })\\n  .then((value) => {\\n    return value * 2; // 4\\n  })\\n  .then((value) => {\\n    console.log(value); // 4\\n  });\\n```\\n\\n## Promise 的静态方法\\n\\n```js\\n// Promise.resolve\\nPromise.resolve('success').then((value) => {\\n  console.log(value); // 'success'\\n});\\n\\n// Promise.reject\\nPromise.reject('error').catch((error) => {\\n  console.log(error); // 'error'\\n});\\n\\n// Promise.all - 所有Promise都成功才成功\\nPromise.all([promise1, promise2, promise3]).then((results) => {\\n  console.log(results); // [result1, result2, result3]\\n});\\n\\n// Promise.race - 返回最快的Promise结果\\nPromise.race([promise1, promise2]).then((result) => {\\n  console.log('最快完成的结果:', result);\\n});\\n\\n// Promise.allSettled - 等待所有Promise完成\\nPromise.allSettled([promise1, promise2]).then((results) => {\\n  // 返回所有Promise的结果，包括成功和失败\\n});\\n```\\n\\n## 错误处理\\n\\n```js\\n// 方式1：使用 catch\\npromise\\n  .then((result) => {})\\n  .catch((error) => {\\n    console.log('捕获错误:', error);\\n  });\\n\\n// 方式2：then 的第二个参数\\npromise.then(\\n  (result) => {},\\n  (error) => {\\n    console.log('捕获错误:', error);\\n  }\\n);\\n```\\n\\n## Promise 的优势\\n\\n1. 解决回调地狱\\n\\n```js\\n// 回调地狱\\nasyncFunc1(function (result1) {\\n  asyncFunc2(result1, function (result2) {\\n    asyncFunc3(result2, function (result3) {\\n      console.log(result3);\\n    });\\n  });\\n});\\n\\n// Promise 方式\\nasyncFunc1()\\n  .then((result1) => asyncFunc2(result1))\\n  .then((result2) => asyncFunc3(result2))\\n  .then((result3) => console.log(result3));\\n```\\n\\n2. 更好的错误处理\\n3. 链式调用更清晰\\n4. 支持并行操作\\n\\n## 实际应用场景\\n\\n```js\\n// 1. 网络请求\\nfetch('https://api.example.com/data')\\n  .then((response) => response.json())\\n  .then((data) => console.log(data));\\n\\n// 2. 文件操作\\nreadFile('file.txt')\\n  .then((content) => writeFile('new.txt', content))\\n  .then(() => console.log('完成'));\\n\\n// 3. 延时操作\\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\\ndelay(1000).then(() => console.log('1秒后执行'));\\n```\\n\\n## 注意事项\\n\\n1. Promise 一旦创建就会执行\\n2. then 方法返回新的 Promise\\n3. 错误会沿着链式调用传递\\n4. Promise 状态一旦改变就不可逆\\n5. finally 不接收参数\\n\\n## 最佳实践\\n\\n```js\\n// 1. 始终使用 catch 处理错误\\n// 2. 合理使用 Promise.all 和 Promise.race\\n// 3. 避免嵌套 Promise\\n// 4. 使用 async/await 让代码更简洁\\nasync function example() {\\n  try {\\n    const result = await somePromise();\\n    return result;\\n  } catch (error) {\\n    console.error(error);\\n  }\\n}\\n```\\n\",\"wordCount\":187},{\"id\":\"f383987b\",\"title\":\"Set、Map 和 WeakMap 全解\",\"date\":\"2020-09-27\",\"tags\":[\"javascript\",\"es6\"],\"fileName\":\"Set、Map 和 WeakMap 全解.md\",\"content\":\"\\n## Set\\n\\n### 前言\\n\\n- Set 是 ES6 引入的一种新的数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n- Set 本身是一个构造函数，可以接受一个数组（或具有 iterable 接口的其他数据结构）作为参数，用来初始化。\\n\\n### 基础使用\\n\\n```js\\n// 创建 Set\\nconst set = new Set();\\n\\n// 添加值\\nset.add(1);\\nset.add('text');\\nset.add({ x: 10 });\\n\\n// 链式调用\\nset.add(1).add(2).add(3);\\n\\n// 检查值是否存在\\nconsole.log(set.has(1)); // true\\n\\n// 删除值\\nset.delete(1);\\n\\n// 获取大小\\nconsole.log(set.size);\\n\\n// 清空 Set\\nset.clear();\\n```\\n\\n### 特点\\n\\n```js\\n// 1. 值的唯一性\\nconst set = new Set([1, 1, 2, 2, 3, 3]);\\nconsole.log(set); // Set(3) {1, 2, 3}\\n\\n// 2. NaN 的处理\\nconst set = new Set([NaN, NaN]);\\nconsole.log(set.size); // 1\\n\\n// 3. +0 和 -0 被视为相同\\nconst set = new Set([+0, -0]);\\nconsole.log(set.size); // 1\\n\\n// 4. 对象引用不同则视为不同值\\nconst set = new Set();\\nset.add({});\\nset.add({});\\nconsole.log(set.size); // 2\\n```\\n\\n### 常用操作\\n\\n```js\\n// 1. 数组去重\\nconst array = [1, 2, 2, 3, 3, 4];\\nconst uniqueArray = [...new Set(array)];\\nconsole.log(uniqueArray); // [1, 2, 3, 4]\\n\\n// 2. 字符串去重\\nconst str = 'hello';\\nconst uniqueStr = [...new Set(str)].join('');\\nconsole.log(uniqueStr); // 'helo'\\n\\n// 3. Set 转数组\\nconst set = new Set([1, 2, 3]);\\nconst array1 = Array.from(set);\\nconst array2 = [...set];\\n\\n// 4. 遍历操作\\nconst set = new Set(['a', 'b', 'c']);\\n\\n// forEach\\nset.forEach(value => {\\n  console.log(value);\\n});\\n\\n// for...of\\nfor (const value of set) {\\n  console.log(value);\\n}\\n```\\n\\n### 集合操作\\n\\n```js\\n// 1. 并集\\nfunction union(setA, setB) {\\n  return new Set([...setA, ...setB]);\\n}\\n\\n// 2. 交集\\nfunction intersection(setA, setB) {\\n  return new Set([...setA].filter((x) => setB.has(x)));\\n}\\n\\n// 3. 差集\\nfunction difference(setA, setB) {\\n  return new Set([...setA].filter((x) => !setB.has(x)));\\n}\\n\\n// 使用示例\\nconst setA = new Set([1, 2, 3]);\\nconst setB = new Set([2, 3, 4]);\\n\\nconsole.log(union(setA, setB)); // Set(4) {1, 2, 3, 4}\\nconsole.log(intersection(setA, setB)); // Set(2) {2, 3}\\nconsole.log(difference(setA, setB)); // Set(1) {1}\\n```\\n\\n## Map\\n\\n### 前言\\n\\nMap 是 ES6 引入的一种新的数据结构，它类似于对象，但是键值对的键可以是任意类型。\\n\\n### 基础使用\\n\\n```js\\n// 创建 Map\\nconst map = new Map();\\n\\n// 设置键值对\\nmap.set('name', 'Alice');\\nmap.set(1, 'number one');\\nmap.set({}, 'object');\\n\\n// 链式调用\\nmap.set('a', 1).set('b', 2).set('c', 3);\\n\\n// 获取值\\nconsole.log(map.get('name')); // 'Alice'\\n\\n// 检查键是否存在\\nconsole.log(map.has('name')); // true\\n\\n// 删除键值对\\nmap.delete('name');\\n\\n// 获取大小\\nconsole.log(map.size);\\n\\n// 清空 Map\\nmap.clear();\\n```\\n\\n### 特点\\n\\n```js\\n// 1. 任何类型都可以作为键\\nconst map = new Map();\\n\\n// 使用对象作为键\\nconst objKey = { id: 1 };\\nmap.set(objKey, 'object value');\\n\\n// 使用函数作为键\\nconst fnKey = function () {};\\nmap.set(fnKey, 'function value');\\n\\n// 使用 NaN 作为键\\nmap.set(NaN, 'NaN value');\\nconsole.log(map.get(NaN)); // 'NaN value'\\n\\n// 2. 键的比较使用 Same-value-zero 算法\\nmap.set(-0, 'negative zero');\\nconsole.log(map.get(+0)); // 'negative zero'\\n\\n// 3. 保持插入顺序\\nconst orderedMap = new Map([\\n  ['first', 1],\\n  ['second', 2],\\n  ['third', 3],\\n]);\\n\\n// 遍历按插入顺序进行\\nfor (const [key, value] of orderedMap) {\\n  console.log(key, value);\\n}\\n```\\n\\n## WeakMap\\n\\n### 前言\\n\\nWeakMap 和 Map 功能类似，只不过它具有弱引用的特点且只能使用对象作为键。\\n\\n### 基础使用\\n\\n```js\\n// 创建 WeakMap\\nconst weakMap = new WeakMap();\\n\\n// 只能使用对象作为键\\nconst obj = { id: 1 };\\nweakMap.set(obj, 'object data');\\n\\n// 获取值\\nconsole.log(weakMap.get(obj));\\n\\n// 检查键是否存在\\nconsole.log(weakMap.has(obj));\\n\\n// 删除键值对\\nweakMap.delete(obj);\\n```\\n\\n### 特点\\n\\n```js\\n// 1. 弱引用特性\\nlet obj = { id: 1 };\\nconst weakMap = new WeakMap();\\nweakMap.set(obj, 'data');\\n\\nobj = null; // 对象可被垃圾回收\\n// weakMap 中的键值对会自动被清除\\n\\n// 2. 不可遍历\\n// 没有 size 属性\\n// 没有 clear() 方法\\n// 不能使用 for...of\\n\\n// 3. 只接受对象作为键\\n// 这些都会报错\\nweakMap.set(1, 'value');\\nweakMap.set('key', 'value');\\nweakMap.set(true, 'value');\\n```\\n\\n## Map vs WeakMap\\n\\n### 引用区别\\n\\n```js\\n// Map：强引用\\nconst map = new Map();\\nlet obj = { id: 1 };\\nmap.set(obj, 'data');\\nobj = null; // 原对象仍然在 map 中\\n\\n// WeakMap：弱引用\\nconst weakMap = new WeakMap();\\nlet obj2 = { id: 2 };\\nweakMap.set(obj2, 'data');\\nobj2 = null; // 对象可被垃圾回收\\n```\\n\\n### 性能区别\\n\\n```js\\n// 1. 频繁增删键值对\\nconst map = new Map(); // 适合\\n\\n// 2. 存储对象关联数据，且需要自动清理\\nconst weakMap = new WeakMap(); // 适合\\n\\n// 3. 需要遍历操作\\nconst map = new Map(); // 适合\\n// WeakMap 不支持遍历\\n\\n// 4. 内存敏感的场景\\nconst weakMap = new WeakMap(); // 适合\\n```\\n\\n### 最佳实践\\n\\n```js\\n// 1. 使用 Map 的场景\\n// - 需要频繁添加/删除键值对\\n// - 需要遍历键值对\\n// - 需要获取键值对数量\\nconst userRoles = new Map();\\nuserRoles.set(user1, ['admin']);\\nuserRoles.set(user2, ['user']);\\n\\n// 2. 使用 WeakMap 的场景\\n// - 存储对象的元数据\\n// - DOM 节点相关数据\\n// - 需要自动垃圾回收\\nconst domData = new WeakMap();\\ndomData.set(element, {\\n  clickCount: 0,\\n  lastClicked: null,\\n});\\n```\\n\\n选择使用 Map 还是 WeakMap 主要考虑：\\n\\n1. 键的类型（是否只用对象）\\n2. 是否需要遍历\\n3. 内存管理需求\\n4. 是否需要获取集合大小\\n5. 是否需要清空操作\\n\",\"wordCount\":242},{\"id\":\"e20c2948\",\"title\":\"对 MVC 和 MVVM 的理解\",\"date\":\"2020-09-13\",\"tags\":[\"软件架构\",\"react\",\"vue\"],\"fileName\":\"对 MVC 和 MVVM 的理解.md\",\"content\":\"\\n## MVC（Model-View-Controller）与 React\\n\\n### MVC 核心思想\\n\\n- Model（模型）：管理数据和业务逻辑（如数据获取、存储、验证）。\\n- View（视图）：负责 UI 的呈现（如 HTML、CSS）。\\n- Controller（控制器）：处理用户输入，协调 Model 和 View 的交互。\\n\\n### React 如何体现 MVC 模式\\n\\nReact 本身更侧重 View 层，但结合其他库（如 Redux、Context API）可实现类似 MVC 的架构：\\n\\n| 角色       | React 中的对应                                                                    |\\n| ---------- | --------------------------------------------------------------------------------- |\\n| Model      | 状态管理工具（如 Redux Store、Context API 的全局状态、组件内部的 useState）       |\\n| View       | React 组件（JSX 描述 UI，通过 Props 和 State 渲染）                               |\\n| Controller | 事件处理函数（如 onClick）、Redux 的 Actions/Reducers、自定义 Hooks（业务逻辑）。 |\\n\\n### React 的 MVC 数据流\\n\\n1. 用户触发事件（如点击按钮），调用 Controller 逻辑（如 Redux Action）。\\n2. Controller 更新 Model（如修改 Redux Store 的状态）。\\n3. Model 变化触发 View 更新（React 组件重新渲染）。\\n\\n示例（React + Redux）：\\n\\n```jsx\\n// Model (Redux Store)\\nconst initialState = { count: 0 };\\nfunction counterReducer(state = initialState, action) {\\n  switch (action.type) {\\n    case 'INCREMENT':\\n      return { ...state, count: state.count + 1 };\\n    default:\\n      return state;\\n  }\\n}\\n\\n// View (React Component)\\nconst Counter = ({ count, increment }) => (\\n  <div>\\n    <p>{count}</p>\\n    <button onClick={increment}>+</button>\\n  </div>\\n);\\n\\n// Controller (Redux Action)\\nconst mapDispatch = (dispatch) => ({\\n  increment: () => dispatch({ type: 'INCREMENT' }),\\n});\\nexport default connect(mapState, mapDispatch)(Counter);\\n```\\n\\n### React MVC 的特点\\n\\n- 单向数据流：数据从 Model → View → Controller → Model 循环。\\n- 职责分离：状态管理（Model）、UI 渲染（View）、逻辑处理（Controller）解耦。\\n- 灵活性：需要手动管理状态和逻辑的传递（如 Props Drilling）。\\n\\n## MVVM（Model-View-ViewModel）与 Vue\\n\\n### MVVM 核心思想\\n\\n- Model（模型）：管理数据和业务逻辑（与 MVC 的 Model 类似）。\\n- View（视图）：UI 的声明式描述（如 Vue 模板）。\\n- ViewModel（视图模型）：连接 View 和 Model 的桥梁，通过数据绑定自动同步两者。\\n\\n### Vue 如何实现 MVVM？\\n\\nVue 是典型的 MVVM 框架，其核心是 响应式系统 和 模板语法：\\n\\n| 角色      | Vue 中的对应                                           |\\n| --------- | ------------------------------------------------------ |\\n| Model     | Vue 组件的 data 属性、Pinia/Vuex 的状态                |\\n| View      | Vue 模板（.vue 文件中的 <template> 部分）              |\\n| ViewModel | Vue 实例（自动生成的响应式系统，处理模板与数据的绑定） |\\n\\n### Vue 的 MVVM 数据流\\n\\n1. View 中声明数据绑定（如 {{ count }} 或 v-model）。\\n\\n2. ViewModel 监听 Model 变化，自动更新 View。\\n\\n3. 用户操作 View（如输入框输入），ViewModel 自动更新 Model。\\n\\n示例：\\n\\n```vue\\n<template>\\n  \x3c!-- View --\x3e\\n  <div>\\n    <p>{{ count }}</p>\\n    <button @click=\\\"increment\\\">+</button>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  // Model\\n  data() {\\n    return { count: 0 };\\n  },\\n  // ViewModel (逻辑处理)\\n  methods: {\\n    increment() {\\n      this.count++;\\n    }\\n  }\\n};\\n<\/script>\\n```\\n\\n### Vue MVVM 的特点\\n\\n- 双向数据绑定：通过 v-model 实现 View 和 Model 的自动同步。\\n- 声明式编程：模板中直接绑定数据和事件，无需手动操作 DOM。\\n- 响应式系统：基于依赖追踪的自动更新（无需手动触发渲染）。\\n\\n## MVC（React） vs MVVM（Vue）对比\\n\\n| 特性     | React MVC                           | Vue MVVM                               |\\n| -------- | ----------------------------------- | -------------------------------------- |\\n| 数据流   | 单向数据流（需手动管理状态传递）    | 双向数据绑定（自动同步 View 和 Model） |\\n| 状态管理 | 依赖外部库（如 Redux、Context API） | 内置响应式系统（data + reactive）      |\\n| UI 更新  | 通过 Virtual DOM Diff 优化渲染      | 基于依赖追踪的精准更新                 |\\n| 代码风格 | 函数式编程（Hooks + JSX）           | 声明式模板 + 选项式/组合式 API         |\\n| 适用场景 | 大型复杂应用，需高度定制化架构      | 中小型应用，快速开发，注重开发体验     |\\n\\n## 总结\\n\\nReact 的 MVC 模式\\n\\n- 强调单向数据流和职责分离，适合需要精细控制状态和逻辑的场景。\\n- 需要结合其他库实现完整的 MVC 架构。\\n\\nVue 的 MVVM 模式\\n\\n- 通过响应式系统和双向绑定简化开发，适合快速迭代和中小型项目。\\n- 内置的 ViewModel 自动处理数据与视图的同步。\\n\\n根据项目需求选择框架：\\n\\n- 选择 React：需要高度灵活性和可扩展性的大型应用。\\n- 选择 Vue：追求开发效率和简洁性的中小型应用。\\n\",\"wordCount\":844},{\"id\":\"20669e11\",\"title\":\"React 工程中 SVG 的高级使用方法\",\"date\":\"2020-09-09\",\"tags\":[\"react\",\"webpack\",\"svg\",\"工程化\"],\"fileName\":\"React 工程中 SVG 的高级使用方法.md\",\"content\":\"\\n## 比较 low 的做法\\n\\n打开 create-react-app 的官方文档，它会告诉你使用 svg，将 svg 进行导入（实际导入的是 svg 的路径字符串），然后放到 img 的 src 上。这种方法我们称为将 svg 当做图片使用。\\n\\n为什么这种方式不好？\\n\\n比如：无法改变 svg 的颜色\\n\\n## 使用 svg-sprite-loader（自己配置法）\\n\\n使用 svg-sprite-loader 要在 webpack.config.js 里配置，但是我们用 create-react-app 搭建起来的项目里没有 webpack 的配置文件。\\n\\n使用 `yarn eject` 命令，可以把配置文件弄出来。运行后，发现项目下多了两个目录，其中就有 webpack.config.js，我们就可以修改它进行配置。按照官网配置即可。\\n\\n注意：一定要先进行 git commit，才能运行 eject，否则会无法成功弹出配置。\\n\\n### 步骤\\n\\n1. 安装两个 loader\\n\\n```\\nyarn add --dev svg-sprite-loader\\nyarn add --dev svgo-loader\\n```\\n\\n2. 在 webpack.config.js 中配置这两个 loader\\n\\n```js\\n{\\n  test: /\\\\.svg$/,\\n  use: [\\n    { loader: 'svg-sprite-loader', options: {} },\\n    { loader: 'svgo-loader', options: {} },\\n  ]\\n},\\n```\\n\\n3. 使用\\n\\nApp.tsx\\n\\n```tsx\\nimport x from \\\"icons/apple.svg\\\";\\n\\nconsole.log(x) // 查看浏览器dom树，可以发现多了一个svg\\n\\n// 多出来的svg如下：\\n<svg fill='red'>\\n   <use xlinkHref='#apple'/>\\n</svg>\\n```\\n\\napple 就是文件名。svg 上还可以直接加 fill 属性来改变颜色。\\n引入的 x 如果不使用，就是如果不打印，页面上的图标就看不到了。必须用一下图标才能生效。这是因为treeshaking，意思是，如果你用不上一个东西，我就把他从树上摇下来。react 发现你引入了 x，但是没使用，就会把它删了。\\n那我怎么样既能引入也不需要打印呢？\\ntreeshaking 不适用于 require，所以可以用 require导入\\n\\n4. 封装 svg 成 icon 组件\\n\\n现在每次使用 svg 都要写三句代码，还要 require 引入。避免重复，把它封装成组件。\\n\\n```tsx\\nimport React from 'react';\\n\\nconst importAll = (requireContext: __WebpackModuleApi.RequireContext) => requireContext.keys().forEach(requireContext);\\ntry {\\n  importAll(require.context('../icons', true, /\\\\.svg$/));\\n} catch (error) {\\n  console.log(error);\\n}\\n\\ntype Props = {\\n  name: string;\\n};\\n\\nfunction Icon(props: Props) {\\n  return (\\n    <svg className=\\\"icon\\\">\\n      <use xlinkHref={'#' + props.name} />\\n    </svg>\\n  );\\n}\\n\\nexport default Icon;\\n```\\n\\n说明：\\n\\n把 require 导入也放进来。但是如果有 100 个 svg，就要写 100 次 require。所以我们选择直接导入一个目录，这个目录里存放所有的 svg。这里封装为 importAll。\\n\\n但是有报错，说找不到 `__WebpackModuleApi`，这是因为在 ts 里不支持这个的问题。去谷歌搜索解决方案。\\n安装：`yarn add --dev @types/webpack-env` 就可以解决。\\n\\n其他组件想使用 Icon，一句话引入即可 `<Icon name='chart'/>` name 属性是文件名。\\n\\nIcon 如果想改变颜色，可以直接在 css 里用 fill 改变：\\n\\n```css\\n.icon {\\n  fill: rgb(140, 177, 253);\\n}\\n```\\n\\n可是有一些svg图标是自带颜色的，在它们的文件里会通过 fill 属性指定颜色。如果是这种情况，就改不了颜色了。我们可以选择手动去它们的 svg 文件里删除 fill 属性，但是如果有很多图标，一个个删除太慢了。\\n\\nsvgo-loader 有一个功能，可以删除fill属性，只需要把需要的语句添加到配置文件的 svgo-loader 后边的选项options 里边就可以。\\nsvgo 就是 svg optimizer 优化器的意思。\\n\\n```js\\n{ loader: 'svgo-loader', options: {\\n  plugins:[\\n      {removeAttrs: {attrs:'fill'}}\\n    ]\\n  }\\n},\\n```\\n\",\"wordCount\":682},{\"id\":\"03a64eb3\",\"title\":\"前端常见设计模式\",\"date\":\"2020-08-24\",\"tags\":[\"javascript\",\"设计模式\"],\"fileName\":\"前端常见设计模式.md\",\"content\":\"\\n## 引言\\n\\n设计模式是软件开发中解决特定问题的通用解决方案。它们是经过验证的、可重用的设计，旨在提高代码的可维护性、可扩展性和可读性。这里我们主要介绍前端开发中常见的几种设计模式。\\n\\n## 常见设计模式\\n\\n### 观察者模式（发布-订阅）\\n\\n最常用的设计模式之一，用于处理事件通信\\n\\n```ts\\n// 简单的事件总线\\nclass EventEmitter {\\n  private events: Record<string, Function[]> = {};\\n\\n  // 订阅\\n  on(event: string, callback: Function) {\\n    if (!this.events[event]) {\\n      this.events[event] = [];\\n    }\\n    this.events[event].push(callback);\\n  }\\n\\n  // 发布\\n  emit(event: string, data?: any) {\\n    if (this.events[event]) {\\n      this.events[event].forEach((callback) => callback(data));\\n    }\\n  }\\n}\\n\\n// 使用示例\\nconst bus = new EventEmitter();\\nbus.on('userLogin', (user) => console.log('用户登录:', user));\\nbus.emit('userLogin', { name: 'John' });\\n```\\n\\n### 单例模式\\n\\n确保一个类只有一个实例，常用于全局状态管理\\n\\n```ts\\n// 全局状态管理\\nclass Store {\\n  private static instance: Store;\\n  private state: Record<string, any> = {};\\n\\n  private constructor() {}\\n\\n  static getInstance() {\\n    if (!Store.instance) {\\n      Store.instance = new Store();\\n    }\\n    return Store.instance;\\n  }\\n\\n  setState(key: string, value: any) {\\n    this.state[key] = value;\\n  }\\n\\n  getState(key: string) {\\n    return this.state[key];\\n  }\\n}\\n\\n// 使用示例\\nconst store1 = Store.getInstance();\\nconst store2 = Store.getInstance();\\nconsole.log(store1 === store2); // true\\n```\\n\\n### 策略模式\\n\\n定义一系列算法，把它们封装起来，并且使它们可以相互替换\\n\\n```ts\\n// 表单验证策略\\ninterface ValidateStrategy {\\n  validate(value: string): boolean;\\n}\\n\\nclass EmailValidator implements ValidateStrategy {\\n  validate(email: string): boolean {\\n    return /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$/.test(email);\\n  }\\n}\\n\\nclass PasswordValidator implements ValidateStrategy {\\n  validate(password: string): boolean {\\n    return password.length >= 6;\\n  }\\n}\\n\\n// 使用示例\\nconst validators = {\\n  email: new EmailValidator(),\\n  password: new PasswordValidator(),\\n};\\n\\nfunction validate(type: string, value: string) {\\n  return validators[type].validate(value);\\n}\\n```\\n\\n### 装饰器模式\\n\\n动态地给对象添加额外的职责\\n\\n```ts\\n// 组件装饰器\\nfunction log(target: any, key: string, descriptor: PropertyDescriptor) {\\n  const original = descriptor.value;\\n\\n  descriptor.value = function(...args: any[]) {\\n    console.log(`Calling ${key} with:`, args);\\n    const result = original.apply(this, args);\\n    console.log(`Result:`, result);\\n    return result;\\n  };\\n\\n  return descriptor;\\n}\\n\\nclass UserService {\\n  @log\\n  getUserInfo(id: string) {\\n    return { id, name: 'John' };\\n  }\\n}\\n```\\n\\n### 工厂模式\\n\\n用于创建对象的接口，让子类决定实例化哪个类\\n\\n```ts\\n// 组件工厂\\ninterface Component {\\n  render(): void;\\n}\\n\\nclass Button implements Component {\\n  render() {\\n    console.log('渲染按钮');\\n  }\\n}\\n\\nclass Input implements Component {\\n  render() {\\n    console.log('渲染输入框');\\n  }\\n}\\n\\nclass ComponentFactory {\\n  createComponent(type: string): Component {\\n    switch (type) {\\n      case 'button':\\n        return new Button();\\n      case 'input':\\n        return new Input();\\n      default:\\n        throw new Error('未知组件类型');\\n    }\\n  }\\n}\\n```\\n\\n### 代理模式\\n\\n为其他对象提供一种代理以控制对这个对象的访问\\n\\n```ts\\n// 图片懒加载代理\\nclass ImageLoader {\\n  loadImage(url: string) {\\n    console.log('加载图片:', url);\\n  }\\n}\\n\\nclass ProxyImage {\\n  private realImage: ImageLoader | null = null;\\n  private cache: Record<string, boolean> = {};\\n\\n  loadImage(url: string) {\\n    // 如果图片在可视区域内才加载\\n    if (this.isInViewport()) {\\n      if (!this.realImage) {\\n        this.realImage = new ImageLoader();\\n      }\\n      if (!this.cache[url]) {\\n        this.realImage.loadImage(url);\\n        this.cache[url] = true;\\n      }\\n    }\\n  }\\n\\n  private isInViewport(): boolean {\\n    // 判断是否在可视区域的逻辑\\n    return true;\\n  }\\n}\\n```\\n\\n### 适配器模式\\n\\n将一个类的接口转换成客户希望的另外一个接口\\n\\n```ts\\n// API 适配器\\ninterface LegacyAPI {\\n  getData(): { oldProp: string };\\n}\\n\\ninterface NewAPI {\\n  getData(): { newProp: string };\\n}\\n\\nclass APIAdapter implements NewAPI {\\n  constructor(private legacyAPI: LegacyAPI) {}\\n\\n  getData() {\\n    const oldData = this.legacyAPI.getData();\\n    return {\\n      newProp: oldData.oldProp,\\n    };\\n  }\\n}\\n```\\n\\n### 组合模式\\n\\n将对象组合成树形结构以表示\\\"部分-整体\\\"的层次结构\\n\\n```ts\\n// 虚拟 DOM 的实现\\ninterface VNode {\\n  render(): string;\\n}\\n\\nclass Element implements VNode {\\n  constructor(\\n    private tag: string,\\n    private children: VNode[] = []\\n  ) {}\\n\\n  render(): string {\\n    const childrenStr = this.children.map((child) => child.render()).join('');\\n    return `<${this.tag}>${childrenStr}</${this.tag}>`;\\n  }\\n}\\n\\nclass TextNode implements VNode {\\n  constructor(private text: string) {}\\n\\n  render(): string {\\n    return this.text;\\n  }\\n}\\n```\\n\\n## 总结\\n\\n这些设计模式在前端开发中非常常见，它们可以帮助我们：\\n\\n- 提高代码复用性\\n- 增加可维护性\\n- 提升代码质量\\n- 降低耦合度\\n\",\"wordCount\":336},{\"id\":\"f52ee4b7\",\"title\":\"SOLID 原则\",\"date\":\"2020-08-23\",\"tags\":[\"javascript\",\"设计模式\"],\"fileName\":\"SOLID 原则.md\",\"content\":\"\\n## 引言\\n\\nSOLID 是面向对象设计的五个基本原则，分别是：\\n\\n- 单一职责原则（Single Responsibility Principle）\\n- 开放封闭原则（Open/Closed Principle）\\n- 里氏替换原则（Liskov Substitution Principle）\\n- 接口隔离原则（Interface Segregation Principle）\\n- 依赖倒置原则（Dependency Inversion Principle）\\n\\n##\\n\\n### 单一职责原则\\n\\n一个类应该只负责一件事\\n\\n```ts\\n// ❌ 错误示例：一个类做多件事\\nclass UserManager {\\n  createUser() { /* ... */ }\\n  sendEmail() { /* ... */ }  // 不应该处理邮件\\n  generateReport() { /* ... */ }  // 不应该处理报告\\n}\\n\\n// ✅ 正确示例：职责分离\\nclass UserManager {\\n  createUser() { /* ... */ }\\n  updateUser() { /* ... */ }\\n  deleteUser() { /* ... */ }\\n}\\n\\nclass EmailService {\\n  sendEmail() { /* ... */ }\\n}\\n\\nclass ReportGenerator {\\n  generateReport() { /* ... */ }\\n}\\n```\\n\\n### 开放封闭原则\\n\\n对扩展开放，对修改封闭\\n\\n```ts\\n// ❌ 错误示例：每增加形状都需要修改计算方法\\nclass AreaCalculator {\\n  calculateArea(shape: string) {\\n    if (shape === 'circle') {\\n      /* ... */\\n    }\\n    if (shape === 'square') {\\n      /* ... */\\n    }\\n    // 新增形状需要修改代码\\n  }\\n}\\n\\n// ✅ 正确示例：通过继承扩展\\ninterface Shape {\\n  calculateArea(): number;\\n}\\n\\nclass Circle implements Shape {\\n  calculateArea() {\\n    /* ... */\\n  }\\n}\\n\\nclass Square implements Shape {\\n  calculateArea() {\\n    /* ... */\\n  }\\n}\\n\\n// 新增形状不需要修改现有代码\\nclass Triangle implements Shape {\\n  calculateArea() {\\n    /* ... */\\n  }\\n}\\n```\\n\\n### 里氏替换原则\\n\\n子类必须能够替换其父类\\n\\n```ts\\n// ❌ 错误示例：违反 LSP\\nclass Bird {\\n  fly() {\\n    /* ... */\\n  }\\n}\\n\\nclass Penguin extends Bird {\\n  fly() {\\n    throw new Error('企鹅不能飞！'); // 违反了父类的行为\\n  }\\n}\\n\\n// ✅ 正确示例：正确的继承关系\\ninterface Bird {\\n  move(): void;\\n}\\n\\nclass FlyingBird implements Bird {\\n  move() {\\n    this.fly();\\n  }\\n  private fly() {\\n    /* ... */\\n  }\\n}\\n\\nclass WalkingBird implements Bird {\\n  move() {\\n    this.walk();\\n  }\\n  private walk() {\\n    /* ... */\\n  }\\n}\\n```\\n\\n### 接口隔离原则\\n\\n客户端不应该依赖它不需要的接口\\n\\n```ts\\n// ❌ 错误示例：一个大而全的接口\\ninterface Worker {\\n  work(): void;\\n  eat(): void;\\n  sleep(): void;\\n}\\n\\n// ✅ 正确示例：接口分离\\ninterface Workable {\\n  work(): void;\\n}\\n\\ninterface Eatable {\\n  eat(): void;\\n}\\n\\ninterface Sleepable {\\n  sleep(): void;\\n}\\n\\nclass Human implements Workable, Eatable, Sleepable {\\n  work() {\\n    /* ... */\\n  }\\n  eat() {\\n    /* ... */\\n  }\\n  sleep() {\\n    /* ... */\\n  }\\n}\\n\\nclass Robot implements Workable {\\n  work() {\\n    /* ... */\\n  }\\n  // 机器人不需要实现 eat 和 sleep\\n}\\n```\\n\\n### 依赖倒置原则\\n\\n高层模块不应该依赖低层模块，两者都应该依赖抽象\\n\\n```ts\\n// ❌ 错误示例：直接依赖具体实现\\nclass EmailNotifier {\\n  sendEmail() { /* ... */ }\\n}\\n\\nclass UserService {\\n  private emailNotifier = new EmailNotifier();  // 直接依赖具体类\\n\\n  notifyUser() {\\n    this.emailNotifier.sendEmail();\\n  }\\n}\\n\\n// ✅ 正确示例：依赖抽象接口\\ninterface Notifier {\\n  notify(): void;\\n}\\n\\nclass EmailNotifier implements Notifier {\\n  notify() { /* 发送邮件 */ }\\n}\\n\\nclass SMSNotifier implements Notifier {\\n  notify() { /* 发送短信 */ }\\n}\\n\\nclass UserService {\\n  constructor(private notifier: Notifier) {}  // 依赖注入\\n\\n  notifyUser() {\\n    this.notifier.notify();\\n  }\\n}\\n\\n// 使用时可以灵活切换通知方式\\nconst userService1 = new UserService(new EmailNotifier());\\nconst userService2 = new UserService(new SMSNotifier());\\n```\\n\",\"wordCount\":164},{\"id\":\"c6002de5\",\"title\":\"try catch 详解\",\"date\":\"2020-08-21\",\"tags\":[\"javascript\"],\"fileName\":\"try catch 详解.md\",\"content\":\"\\n## try...catch 能否捕获异步错误？\\n\\n只能捕获同步代码块中的异常，不能捕获异步回调中的异常。\\n\\n### 例子1：同步 throw，能捕获\\n\\n```js\\ntry {\\n  throw new Error('同步错误');\\n} catch (e) {\\n  console.log('捕获到：', e.message); // 捕获到：同步错误\\n}\\n```\\n\\n### 例子2：setTimeout 里的 throw，不能捕获\\n\\n```js\\ntry {\\n  setTimeout(() => {\\n    throw new Error('异步错误');\\n  }, 0);\\n} catch (e) {\\n  console.log('捕获到：', e.message); // 不会执行\\n}\\n```\\n\\n**_原因：setTimeout 的回调是在主线程事件队列的下一个宏任务执行，已经脱离了 try...catch 的作用域。_**\\n\\n## Promise 的异常捕获\\n\\npromise 内部的异常（无论同步还是异步），都能被 .catch 捕获\\n\\n### 例子3：Promise 内 throw，catch 能捕获\\n\\n```js\\nPromise.resolve()\\n  .then(() => {\\n    throw new Error('Promise错误');\\n  })\\n  .catch((e) => {\\n    console.log('捕获到：', e.message); // 捕获到：Promise错误\\n  });\\n```\\n\\n### 例子4：Promise 内 setTimeout throw，catch 不能捕获\\n\\n```js\\nPromise.resolve()\\n  .then(() => {\\n    setTimeout(() => {\\n      throw new Error('定时器里的错误');\\n    }, 0);\\n  })\\n  .catch((e) => {\\n    console.log('捕获到：', e.message); // 不会执行\\n  });\\n```\\n\\n原因：setTimeout 里的 throw 依然是脱离了 Promise 链的，catch 捕获不到。\\n\\n## async/await 与 try...catch\\n\\n如果你用 await 等待一个 Promise，try...catch 可以捕获 await 抛出的异常：\\n\\n```js\\nasync function test() {\\n  try {\\n    await Promise.reject(new Error('异步错误'));\\n  } catch (e) {\\n    console.log('捕获到：', e.message); // 捕获到：异步错误\\n  }\\n}\\ntest();\\n```\\n\\n上面的代码等价于：\\n\\n```js\\nfunction test() {\\n  return Promise.reject(new Error('异步错误')).catch((e) => {\\n    console.log('捕获到：', e.message);\\n  });\\n}\\n```\\n\\nasync/await + try...catch 就是 Promise.then().catch() 的语法糖，本质一样，只是写法更直观\\n\\n## 总结\\n\\n- try...catch 只能捕获同步代码块里的异常，不能捕获异步回调（如 setTimeout、事件监听器）里的异常。\\n- Promise.prototype.catch 能捕获 Promise 链中抛出的异常（无论同步还是异步的 then 回调），但不能捕获 Promise 链外的异步异常（如 setTimeout 里的 throw）。\\n- async/await + try...catch 可以捕获 await 的 Promise 抛出的异常。\\n\\n如果你想让所有异步异常都能被捕获，建议把异步操作写进 Promise 里，并用 catch 处理。\\n\",\"wordCount\":341},{\"id\":\"2b6c59a4\",\"title\":\"使用 useReducer 和 Context 实现 redux 的功能\",\"date\":\"2020-07-24\",\"tags\":[\"react\",\"redux\",\"状态管理\"],\"fileName\":\"使用 useReducer 和 Context 实现 redux 的功能.md\",\"content\":\"\\n## 使用 useReducer 和 Context 实现 redux 的功能\\n\\n步骤：\\n\\n1. 将数据集中在一个 store 对象\\n2. 将所有操作集中在 reducer\\n3. 创建一个 Context\\n4. 创建对数据的读写 API\\n5. 将第4步的内容放到第 3 步的 Context 中\\n6. 用 Context.Provider 将 Context 提供给所有组件\\n7. 各个组件用 useContext 获取读写 API\\n\\n代码演示：\\n\\n```tsx\\nimport React, { Dispatch, createContext, useContext, useEffect, useReducer } from 'react';\\n\\nimport './App.css';\\n\\ninterface IPersonState {\\n  books: string[];\\n  movies: string[];\\n}\\n\\ntype IPersonAction = {\\n  type: 'getBooks' | 'getMovies';\\n  payload: string[];\\n};\\n\\nconst initialState: IPersonState = {\\n  books: [],\\n  movies: [],\\n};\\n\\nfunction reducer(state: IPersonState = initialState, action: IPersonAction) {\\n  if (action.type === 'getBooks') {\\n    return { ...state, books: action.payload };\\n  }\\n  if (action.type === 'getMovies') {\\n    return { ...state, movies: action.payload };\\n  }\\n  return state;\\n}\\n\\nexport interface IContextValue {\\n  state: IPersonState;\\n  dispatch: Dispatch<IPersonAction>;\\n}\\n\\nconst Context = createContext<IContextValue | undefined>(undefined);\\n\\nfunction Person() {\\n  const [state, dispatch] = useReducer(reducer, initialState);\\n\\n  return (\\n    <Context.Provider value={{ state, dispatch }}>\\n      <div>\\n        <Books />\\n        <Movies />\\n      </div>\\n    </Context.Provider>\\n  );\\n}\\n\\nfunction Books() {\\n  const { state, dispatch } = useContext(Context)!;\\n  useEffect(() => {\\n    fetch('http://api.kuanglinfeng.com')\\n      .then((response) => response.json())\\n      .then((data) => dispatch({ type: 'getBooks', payload: data.books }));\\n  }, []);\\n\\n  return (\\n    <div>\\n      <h1>我的书籍</h1>\\n      <ul>\\n        {state.books!.map((book) => (\\n          <li key={book}>{book}</li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n}\\n\\nfunction Movies() {\\n  const { state, dispatch } = useContext(Context)!;\\n\\n  useEffect(() => {\\n    fetch('http://api.kuanglinfeng.com')\\n      .then((response) => response.json())\\n      .then((data) => dispatch({ type: 'getMovies', payload: data.movies }));\\n  }, []);\\n  return (\\n    <div>\\n      <h1>我的电影</h1>\\n      {state.movies.map((movie) => (\\n        <li key={movie}>{movie}</li>\\n      ))}\\n    </div>\\n  );\\n}\\n\\nfunction App() {\\n  return (\\n    <div className=\\\"App\\\">\\n      <Person />\\n    </div>\\n  );\\n}\\n\\nexport default App;\\n```\\n\\n如何对 reducer 进行拆分？\\n\\n答：可将 reducer 写成多个对象的形式，合并所有的子 reducer 时只需要 `{...reducer1, ...reducer2, ...}` 即可\\n\",\"wordCount\":121},{\"id\":\"6ef92744\",\"title\":\"Icon 的所有方案\",\"date\":\"2020-07-21\",\"tags\":[\"icon\"],\"fileName\":\"Icon 的所有方案.md\",\"content\":\"\\n## icon 的各种做法\\n\\n1. img 法\\n2. background 法\\n3. background 合一法\\n4. font 法\\n5. svg-symbol 法\\n6. css 就是干法\\n\\n### img 法\\n\\n1. 搞一张图片\\n2. 使用`<img src=\\\"图片路径\\\"/>`来使用图片\\n3. 通过其它 css 属性来控制图片的大小，位置等\\n\\n优点：可以利用图片默认自动缩放的特性，通过仅设置宽度或者高度来改变图片的大小\\n\\n### background 法\\n\\n1. 搞一张图片\\n2. 利用 css 属性`background: url(./image.png)`\\n3. 通过其它 css 属性来控制图片的大小，位置等\\n\\n### background 合一法\\n\\n1. 将几张图片拼成一张图，可以用网上的 css sprites generator 工具\\n2. 利用 css 属性`width，height, overflow, background-position`来显示某一张图片\\n\\n### font 法\\n\\n使用 icon-font，字体即图标，图标即字体。常用网站：http://iconfont.cn\\n\\n注意：一般来说，字体图标的 Entity Number 一般都以`&#xe6`开头，因为这一段范围通常不表示任何字符\\n\\n- inconfont 的 HTML 形式（对应 iconfont.cn 里的 unicode 功能）\\n\\n用法：\\n\\n1. 在样式里引入@font-face\\n\\n```css\\n@font-face {\\n  font-family: 'iconfont'; /* project id 1958405 */\\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\\n  src:\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\\n}\\n```\\n\\n2. 使用字体对应的 Entity Number（unicode）并指定 font-family\\n\\n```html\\n<div style=\\\"font-family: iconfont;\\\">&#xe600;</div>\\n```\\n\\n- inconfont 的 CSS 形式（对应 iconfont.cn 里的 Font class 功能）\\n\\n1. 在样式里引入@font-face，并使用伪类指定对应 iconfont 的 Entity Number\\n\\n```css\\n@font-face {\\n  font-family: 'iconfont'; /* project id 1958405 */\\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\\n  src:\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\\n}\\n.xxx:before {\\n  content: '\\\\e600';\\n}\\n```\\n\\n2. 指定 font-family 和伪类\\n\\n```html\\n<div class=\\\"xxx\\\" style=\\\"font-family: iconfont;\\\"></div>\\n```\\n\\n### svg-symbol 法\\n\\n这种方式是最推荐的做法。与以上方式相比有如下特点：\\n\\n1. 支持多色图标，不再受单色限制\\n2. 通过一些技巧，支持像字体那样，通过 font-size，color 来调样式\\n3. 兼容性较差，支持 ie9+即现代浏览器\\n4. 浏览器渲染 svg 的性能一般，还不如 png\\n\\n使用步骤：\\n\\n1. 从 iconfont.cn 上拷贝项目下生成的 symbol 代码\\n\\n```js\\n//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js\\n```\\n\\n2. 加入通用 css 代码（引入一次就行）\\n\\n```html\\n<style type=\\\"text/css\\\">\\n  .icon {\\n    width: 1em;\\n    height: 1em;\\n    vertical-align: -0.15em;\\n    fill: currentColor;\\n    overflow: hidden;\\n  }\\n</style>\\n```\\n\\n3. 挑选相应的图标并获取类名，应用于页面\\n\\n```html\\n<svg class=\\\"icon\\\" aria-hidden=\\\"true\\\">\\n  <use xlink:href=\\\"#icon-xxx\\\"></use>\\n</svg>\\n```\\n\\n### 「CSS 就是干」法\\n\\n纯 css 技巧来实现 icon。\\n\\n推荐一个网站，这个网站是一个设计师写的，全是用 css 实现的 icon。\\n\\nhttps://cssicon.space\\n\",\"wordCount\":481},{\"id\":\"033dbcf4\",\"title\":\"bind 函数全解\",\"date\":\"2020-07-19\",\"tags\":[\"javascript\"],\"fileName\":\"bind 函数全解.md\",\"content\":\"\\n## 功能\\n\\nbind 函数是 JavaScript 中一个非常重要的函数，它可以将一个函数的上下文绑定到指定的对象上，从而改变函数执行时的上下文。bind 的传参结构为`function.bind(thisArg, arg1, arg2, ...)`，`thisArg` 表示绑定的 this 上下文，`arg1, arg2, ...`表示预设的参数。\\n\\n## 用法\\n\\n### 绑定 this\\n\\n```js\\nconst person = {\\n  name: 'Alice',\\n  greet() {\\n    console.log(`Hello, I'm ${this.name}`);\\n  },\\n};\\n\\nconst greet = person.greet;\\n// 直接调用会丢失 this 上下文\\ngreet(); // Hello, I'm undefined\\n\\nconst boundGreet = person.greet.bind(person);\\n// bind 后保持了正确的 this 指向\\nboundGreet(); // Hello, I'm Alice\\n```\\n\\n### 参数预设\\n\\n```js\\nfunction multiply(a, b) {\\n  return a * b;\\n}\\n\\n// 创建一个新函数，第一个参数固定为 2\\nconst double = multiply.bind(null, 2);\\nconsole.log(double(4)); // 8\\nconsole.log(double(5)); // 10\\n```\\n\\n### 在类/构造函数中使用\\n\\n```js\\nclass Button {\\n  constructor() {\\n    this.clicked = false;\\n    // 在事件处理中保持 this 指向\\n    this.onClick = this.onClick.bind(this);\\n  }\\n\\n  onClick() {\\n    this.clicked = true;\\n    console.log('Button clicked');\\n  }\\n}\\n```\\n\\n### 支持作为构造函数使用\\n\\n```js\\nfunction Person(name, age) {\\n  this.name = name;\\n  this.age = age;\\n}\\n\\n// 创建一个预设年龄的构造函数\\nconst CreateTeenager = Person.bind(null, 'Unknown', 16);\\nconst teen = new CreateTeenager();\\nconsole.log(teen.age); // 16\\n```\\n\\n## 实现原理\\n\\n具体代码实现：\\n\\n```js\\nFunction.prototype.myBind = function (context, ...args) {\\n  if (typeof this !== 'function') {\\n    throw new Error('Function.prototype.bind - what is trying to be bound is not callable');\\n  }\\n\\n  const self = this; // 保存原函数的引用\\n  // 改用普通函数，这样可以作为构造函数使用\\n  const fBound = function (...boundArgs) {\\n    return self.apply(\\n      // 使用 instanceof 检查是否是通过 new 调用\\n      this instanceof fBound ? this : context,\\n      [...args, ...boundArgs]\\n    );\\n  };\\n\\n  // 设置 fBound.__proto__ 指向 self，使之可以访问 self 对象上的静态方法\\n  Object.setPrototypeOf(fBound, self);\\n  // 设置 fBound.prototype 为 self.prototype 的副本，这样 fBound 的实例可以继承 self 的原型对象上的方法\\n  fBound.prototype = Object.create(self.prototype);\\n\\n  return fBound;\\n};\\n```\\n\\n代码解析：\\n\\n1. 参数检查\\n\\n```js\\nif (typeof this !== 'function') {\\n  throw new Error('Function.prototype.bind - what is trying to be bound is not callable');\\n}\\n```\\n\\n- 因为 myBind 是定义在 Function.prototype 上的方法\\n- 检查调用 myBind 的对象是否为函数\\n- 如果不是函数则抛出错误\\n\\n2. 保存原函数引用\\n\\n```js\\nconst self = this;\\n```\\n\\n- this 在这里指向原始函数\\n- 保存引用是为了在后面的函数中使用\\n\\n3. 创建绑定函数\\n\\n```js\\nconst fBound = function (...boundArgs) {\\n  // 函数体\\n};\\n```\\n\\n- 创建一个新函数作为返回值\\n- 使用剩余参数语法收集调用时传入的参数\\n\\n4. 处理 this 指向\\n\\n```js\\nthis instanceof fBound ? this : context;\\n```\\n\\n- 判断 fBound 是否被作为构造函数调用（使用 new）\\n- 如果是构造函数调用：使用新创建的实例（this）\\n- 如果是普通调用：使用传入的上下文（context）\\n\\n5. 合并参数\\n\\n```js\\n[...args, ...boundArgs];\\n```\\n\\n- args：调用 bind 时预设的参数\\n- boundArgs：调用绑定函数时传入的参数\\n- 使用扩展运算符合并两组参数\\n\\n6. 继承原型链\\n\\n```js\\nObject.setPrototypeOf(fBound, self);\\nfBound.prototype = Object.create(self.prototype);\\n```\\n\\n- 设置 fBound 函数对象的原型（**proto**）指向原函数，继承静态属性/方法\\n- 创建原函数原型的副本作为 fBound 的 prototype，继承实例方法\\n\",\"wordCount\":372},{\"id\":\"6263d108\",\"title\":\"call 和 apply 函数全解\",\"date\":\"2020-07-17\",\"tags\":[\"javascript\"],\"fileName\":\"call 和 apply 函数全解.md\",\"content\":\"\\n## 功能\\n\\ncall 和 apply 函数是 JavaScript 中用于改变函数执行上下文（this 值）的函数。它们可以调用一个函数，并指定函数执行时的上下文（this 值）。他们两个的差异在于传参方式不同，call 的传参结构为`function.call(thisArg, arg1, arg2, ...)`，apply 的传参结构为`function.apply(thisArg, [argsArray])`。\\n\\n## 用法\\n\\n### 绑定函数 this\\n\\n```js\\nfunction greet(greeting) {\\n  console.log(`${greeting}, ${this.name}!`);\\n}\\n\\nconst person = { name: 'Alice' };\\ngreet.call(person, 'Hello'); // Hello, Alice!\\n```\\n\\n### 多参数\\n\\n```js\\nfunction introduce(greeting, profession) {\\n  console.log(`${greeting}, I'm ${this.name}, I'm a ${profession}`);\\n}\\n\\nconst person = { name: 'Bob' };\\nintroduce.myCall(person, 'Hi', 'developer'); // Hi, I'm Bob, I'm a developer\\n```\\n\\n## 实现原理\\n\\n具体代码实现（call）：\\n\\n```js\\nFunction.prototype.myCall = function (context, ...args) {\\n  if (typeof this !== 'function') {\\n    throw new Error('Function.prototype.call - what is trying to be bound is not callable');\\n  }\\n  context = context || window;\\n  const fn = Symbol('fn');\\n  context.fn = fn;\\n  const res = context.fn(...args);\\n  delete context.fn;\\n  return res;\\n};\\n```\\n\\n具体代码实现（apply）：\\n\\n```js\\nFunction.prototype.myApply = function (context, args) {\\n  if (typeof this !== 'function') {\\n    throw new Error('Function.prototype.apply - what is trying to be bound is not callable');\\n  }\\n  context = context || window;\\n  const fn = Symbol('fn');\\n  context.fn = fn;\\n  const res = context.fn(...args);\\n  delete context.fn;\\n  return res;\\n};\\n```\\n\\n不难看出，call 和 apply 的底层实现都是类似的：\\n\\n1. 函数临时添加为目标对象的方法\\n2. 通过对象调用这个方法（此时 this 自然指向该对象）\\n3. 调用完成后删除这个临时方法\\n\\n这种实现方式巧妙地利用了 JavaScript 中 this 的指向规则：当函数作为对象的方法调用时，this 指向该对象。\\n\\n## 注意事项\\n\\n- 在严格模式下，需要特别处理 context 为 null/undefined 的情况\\n- 在实际项目中，可能需要考虑 Symbol 的兼容性\\n- 在 Node.js 环境中需要使用 global 替代 window\\n- 需要注意属性名冲突的问题（虽然使用 Symbol 已经很好地解决了这个问题）\\n\",\"wordCount\":293},{\"id\":\"90ac0d80\",\"title\":\"XSS 和 CSRF 攻击详解\",\"date\":\"2020-06-03\",\"tags\":[\"前端安全\"],\"fileName\":\"XSS 和 CSRF 攻击详解.md\",\"content\":\"\\n## XSS （跨站脚本攻击）\\n\\n### 攻击原理\\n\\nXSS（Cross-Site Scripting）攻击的核心是让恶意脚本在受害者的浏览器中执行。攻击者通过注入恶意代码（通常是 JavaScript）到网页中，当其他用户访问该页面时，代码会被浏览器解析并执行，从而实现窃取用户数据、会话劫持、篡改页面内容等攻击行为。\\n\\n### 攻击类型\\n\\n- 反射型 XSS\\n\\n**原理**：恶意脚本通过 URL 参数注入，服务端未过滤直接返回给客户端。\\n\\n例如：用户点击一个精心构造的链接：\\n\\n```\\nhttps://example.com/search?query=<script>alert('XSS')<\/script>\\n```\\n\\n服务端将`query`参数直接插入到页面中，导致脚本执行\\n\\n**特点**：需要诱导用户主动点击恶意链接，常见于钓鱼攻击。\\n\\n- 存储型 XSS\\n\\n**原理**：恶意脚本被存储到服务器数据库（如评论、留言板），其他用户访问页面时触发。\\n\\n例如：攻击者在评论区提交内容：\\n\\n```html\\n<script>\\n  stealCookie(document.cookie);\\n<\/script>\\n```\\n\\n所有用户访问该页面时，脚本自动执行，窃取 Cookie。\\n\\n**特点**：危害范围广，持续时间长（数据长期存储在服务端）。\\n\\n- DOM 型 XSS\\n\\n**原理**：前端 JavaScript 动态操作 DOM 时未对用户输入转义，导致恶意脚本执行。\\n\\n例如：面通过 location.hash 获取 URL 片段并插入到 DOM 中：\\n\\n```js\\ndocument.getElementById('content').innerHTML = location.hash.substring(1);\\n```\\n\\n攻击者构造 URL：\\n\\n```\\nhttps://example.com#<img src=x onerror=alert('XSS')>\\n```\\n\\n用户访问该 URL 时，恶意脚本执行。\\n**特点**：完全在客户端触发，无需服务端参与。\\n\\n### 攻击危害\\n\\n- 窃取用户 Cookie 或会话信息（Session Hijacking）。\\n- 伪造用户操作（如转账、修改密码）。\\n- 篡改页面内容（如插入钓鱼表单）。\\n- 劫持用户浏览器（如发起 DDoS 攻击）。\\n\\n### 防御措施\\n\\n#### 输入过滤与输出编码\\n\\n- **输入过滤**：对用户输入进行严格校验（如正则表达式、白名单）。\\n\\n- **输出编码**：根据输出位置选择不同的转义规则：\\n  - **HTML 上下文**：转义 <, >, &, \\\", ' 等字符。\\n  ```js\\n  function escapeHTML(str) {\\n    return str.replace(\\n      /[&<>\\\"']/g,\\n      (c) =>\\n        ({\\n          '&': '&amp;',\\n          '<': '&lt;',\\n          '>': '&gt;',\\n          '\\\"': '&quot;',\\n          \\\"'\\\": '&#39;',\\n        })[c]\\n    );\\n  }\\n  ```\\n  - **JavaScript 上下文**：使用 JSON.stringify 或 encodeURIComponent。\\n  - **URL 上下文**：使用 encodeURIComponent 编码参数。\\n\\n#### CSP（内容安全策略）\\n\\n通过 HTTP 头限制资源加载来源：\\n\\n```http\\nContent-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;\\n```\\n\\n- 禁止内联脚本（unsafe-inline）和 eval。\\n- 仅允许加载指定域名的脚本、样式、图片等资源。\\n\\n#### 安全的 Cookie 设置\\n\\n敏感 Cookie 设置 HttpOnly（禁止 JavaScript 访问）：\\n\\n```http\\nSet-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Lax;\\n```\\n\\n### 避免危险 API\\n\\n- 使用 textContent 替代 innerHTML。\\n- 避免直接执行用户输入的字符串（如 eval）。\\n\\n## CSRF （跨站请求伪造）\\n\\n### 攻击原理\\n\\nCSRF（Cross-Site Request Forgery）攻击的核心是利用用户的登录状态，诱导用户访问恶意页面，伪造一个合法请求（如转账、修改密码），而用户并不知情。\\n\\n**典型场景**：\\n\\n1. 用户登录银行网站 bank.com，Cookie 中保存了会话信息。\\n2. 用户访问恶意页面 evil.com，该页面自动发起一个向 bank.com/transfer 的请求：\\n\\n```js\\n<img src=\\\"https://bank.com/transfer?to=hacker&amount=1000000\\\">\\n```\\n\\n3. 浏览器自动携带 bank.com 的 Cookie，请求被服务器认为是合法的。\\n\\n### 攻击危害\\n\\n- 以用户身份执行敏感操作（如转账、删除数据）。\\n- 修改用户账户信息（如邮箱、密码）。\\n\\n### 防御措施\\n\\n#### CSRF Token\\n\\n**原理**：服务端生成随机 Token，嵌入表单或请求头，提交时验证 Token 合法性。\\n**实现步骤**：\\n\\n1. 用户访问页面时，服务端生成 Token 并存储在 Session 或 Cookie 中。\\n2. 页面表单中插入 Token：\\n\\n```html\\n<input type=\\\"hidden\\\" name=\\\"csrf_token\\\" value=\\\"随机Token\\\" />\\n```\\n\\n3. 提交表单时，服务端验证 Token 合法性。\\n   **关键点**：Token 需随机、一次性，且绑定用户会话。\\n\\n#### SameSite Cookie\\n\\n**原理**：通过 Cookie 的 SameSite 属性限制跨站请求携带 Cookie。\\n\\n```http\\nSet-Cookie: sessionId=abc123; SameSite=Lax;\\n```\\n\\n- Lax：允许部分安全请求（如导航跳转）携带 Cookie。\\n- Strict：完全禁止跨站携带 Cookie。\\n- None：允许跨站携带 Cookie（需配合 Secure）。\\n\\n#### 验证 Referer/Origin 头\\n\\n检查请求头中的 Referer 或 Origin 是否为可信域名。\\n\\n```js\\n// 服务端校验示例（Node.js）\\nif (req.headers.referer !== 'https://trusted-domain.com') {\\n  throw new Error('非法请求来源');\\n}\\n```\\n\\n**局限性**：某些浏览器会禁用 Referer，且可能被伪造。\\n\\n#### 关键操作二次验证\\n\\n对敏感操作（如支付、修改密码）要求用户输入密码或短信验证码。\\n\\n## XSS 和 CSRF 的区别\\n\\n| 区别       | XSS                      | CSRF                           |\\n| ---------- | ------------------------ | ------------------------------ |\\n| 攻击目标   | 窃取用户数据或劫持会话   | 伪造用户身份执行操作           |\\n| 依赖条件   | 需要注入恶意脚本         | 依赖用户已登录目标网站         |\\n| 攻击发起者 | 用户访问含恶意脚本的页面 | 用户访问恶意页面或点击恶意链接 |\\n| 防御核心   | 控制不可信数据的输出     | 验证请求来源和合法性           |\\n\\n## 总结\\n\\n- **XSS** 的核心是防止恶意脚本执行，需重点关注**输出编码**和 **CSP 策略**。\\n- **CSRF** 的核心是验证请求是否由用户主动发起，需依赖 **CSRF Token** 和 **SameSite Cookie**。\\n- 安全是系统工程，需前后端协作，结合多种防御手段降低风险。\\n\",\"wordCount\":1198}]"),vn=s.memo((()=>{const n=s.useMemo((()=>kn),[]);return tn.jsx(mn,{articles:n})}));var Sn,yn;const wn=o(function(){if(yn)return Sn;yn=1;var n=p();return n.registerLanguage("xml",m()),n.registerLanguage("bash",h()),n.registerLanguage("c",f()),n.registerLanguage("cpp",g()),n.registerLanguage("csharp",b()),n.registerLanguage("css",k()),n.registerLanguage("markdown",v()),n.registerLanguage("diff",S()),n.registerLanguage("ruby",y()),n.registerLanguage("go",w()),n.registerLanguage("graphql",C()),n.registerLanguage("ini",x()),n.registerLanguage("java",j()),n.registerLanguage("javascript",T()),n.registerLanguage("json",P()),n.registerLanguage("kotlin",R()),n.registerLanguage("less",M()),n.registerLanguage("lua",I()),n.registerLanguage("makefile",E()),n.registerLanguage("perl",H()),n.registerLanguage("objectivec",D()),n.registerLanguage("php",W()),n.registerLanguage("php-template",A()),n.registerLanguage("plaintext",L()),n.registerLanguage("python",N()),n.registerLanguage("python-repl",F()),n.registerLanguage("r",O()),n.registerLanguage("rust",V()),n.registerLanguage("scss",U()),n.registerLanguage("shell",J()),n.registerLanguage("sql",q()),n.registerLanguage("swift",B()),n.registerLanguage("yaml",z()),n.registerLanguage("typescript",G()),n.registerLanguage("vbnet",_()),n.registerLanguage("wasm",$()),n.HighlightJS=n,n.default=n,Sn=n}()),Cn="code-copy-btn",xn=()=>{const n=async function(){var n;const e=null==(n=this.nextElementSibling)?void 0:n.querySelector("code");if(e){const n=e.textContent||"";try{if(navigator.clipboard&&window.isSecureContext)await navigator.clipboard.writeText(n);else{const e=document.createElement("textarea");e.value=n,e.style.position="fixed",e.style.left="-999999px",document.body.appendChild(e),e.select(),document.execCommand("copy"),e.remove()}const e=this;e.textContent="复制成功！",setTimeout((()=>{e.textContent="复制"}),1e3)}catch(t){const n=this;n.textContent="复制失败！",setTimeout((()=>{n.textContent="复制"}),1e3)}}};return{registerCopy:()=>{document.querySelectorAll(`.${Cn}`).forEach((e=>{e.addEventListener("click",n)}))},unregisterCopy:()=>{document.querySelectorAll(`.${Cn}`).forEach((e=>{e.removeEventListener("click",n)}))}}};function jn(n){return n.replace(/</g,"&lt;").replace(/>/g,"&gt;")}const Tn=X({langPrefix:"hljs language-",highlight(n,e){const t=wn.getLanguage(e)?e:"plaintext";return wn.highlight(n,{language:t}).value}}),Pn={code(n,e){const t=wn.getLanguage(e||"")?e:"plaintext";return`\n      <div class="relative group">\n        <button\n          class="${Cn} hover:cursor-pointer\n          absolute right-2 top-2 opacity-0\n          group-hover:opacity-100 transition-opacity\n          duration-200 px-2 py-1 rounded text-sm\n          bg-white/10 hover:bg-white/20 text-gray-400\n          hover:text-gray-300"\n        >\n          复制\n        </button>\n        <pre><code class="hljs language-${t}">${n.text}</code></pre>\n      </div>`},codespan:({text:n})=>`<code class="inline-code">${jn(n)}</code>`,html:({text:n})=>jn(n),image:({href:n,title:e,text:t})=>(null==n?void 0:n.match(/\.(mp4|webm|ogg)$/i))?`\n        <a \n          href="${n}" \n          data-fancybox="gallery"\n          data-type="video"\n        >\n          <video class="w-full rounded-lg">\n            <source src="${n}" type="video/${n.split(".").pop()}" />\n          </video>\n        </a>\n      `:`\n      <a \n        href="${n}" \n        data-fancybox="gallery"\n      >\n        <img \n          src="${n}" \n          alt="${t||""}" \n          title="${e||""}"\n          class="cursor-zoom-in rounded-lg"\n          loading="lazy"\n        />\n      </a>\n    `,link({href:n,title:e,tokens:t}){var o;return`<a href="${n}" target="_blank" rel="noopener noreferrer" title="${e}">${null==(o=null==t?void 0:t[0])?void 0:o.raw}</a>`},heading:({text:n,depth:e})=>`<h${e} id="${n.toLowerCase().replace(/[^a-zA-Z0-9\u4e00-\u9fa5]+/g,"-")}">${n}</h${e}>`},Rn={gfm:!0,breaks:!0,renderer:Pn},Mn=s.lazy((()=>an((()=>import("./LazyFancybox-BSCIBjqy.js")),__vite__mapDeps([0,1,2,3,4]))));Q.use(Tn);const In=Object.freeze(Object.defineProperty({__proto__:null,default:()=>{const{registerCopy:n,unregisterCopy:e}=xn(),t=r(),[o,a]=s.useState(),[i,c]=s.useState(!0);s.useEffect((()=>{if(c(!0),!t.id)return void c(!1);const n=kn.find((n=>n.id===t.id));a(n),c(!1)}),[t.id]),s.useEffect((()=>{if(o)return n(),()=>{e()}}),[o,n,e]);const l=s.useMemo((()=>{if(!o)return{content:"",headings:[]};const n=Q.lexer(o.content).filter((n=>"heading"===n.type&&n.depth>=2)),e=new Map,t=n=>{const t=n.toLowerCase().replace(/[^a-zA-Z0-9\u4e00-\u9fa5]+/g,"-"),o=e.get(n)||[],s=0===o.length?t:`${t}-${o.length}`;return o.push(s),e.set(n,o),s},s=n.map((n=>({id:t(n.text),text:n.text,level:n.depth})));e.clear(),Q.use({...Rn,renderer:{...Pn,heading:({text:n,depth:e})=>`<h${e} id="${t(n)}">${n}</h${e}>`}});return{content:d.sanitize(Q.parse(o.content),{ADD_ATTR:["target"]}),headings:s}}),[o]);return i?null:o?tn.jsx("div",{className:"mt-10",children:tn.jsxs("div",{className:"relative",children:[tn.jsx(gn,{headings:l.headings,title:o.title}),tn.jsxs("div",{className:"max-w-192 mx-auto",children:[tn.jsx("h1",{id:"article-title",className:"my-6 text-3xl font-bold",children:o.title}),tn.jsx("div",{className:"mb-4 text-xs text-stone-400",children:`发布于 ${un(o.date).format("YYYY.MM.DD")} | 字数 ${o.wordCount}`}),tn.jsx(s.Suspense,{fallback:tn.jsx("div",{className:"flex min-h-[200px] w-full items-center justify-center",children:tn.jsx(bn,{size:32,className:"mx-auto"})}),children:tn.jsx(Mn,{children:tn.jsx("article",{className:"prose prose-stone lg:prose-lg dark:prose-invert prose-headings:font-bold prose-h1:text-2xl prose-h2:text-xl prose-h3:text-lg prose-a:text-blue-600 max-w-none !font-normal [&_pre]:!m-0 [&_pre]:!bg-transparent [&_pre]:!p-0 [&_pre_code]:!font-mono [&_pre_code]:!text-sm",dangerouslySetInnerHTML:{__html:l.content}})})})]})]})}):tn.jsx(hn,{message:"文章地址已改变，请回到主页重新浏览"})}},Symbol.toStringTag,{value:"Module"})),En=()=>{const[n,e]=s.useState([]);return s.useEffect((()=>{const n=kn.reduce(((n,e)=>(e.tags.forEach((e=>{n[e]=(n[e]||0)+1})),n)),{}),t=Object.entries(n).map((([n,e])=>({name:n,count:e})));e(t)}),[kn]),tn.jsx("div",{className:"mt-10 text-center",children:tn.jsx("ul",{className:"m-0 flex flex-wrap justify-center p-0",children:n.map((n=>tn.jsxs("li",{className:"m-2 ml-0 flex flex-[46%] items-center text-left",children:[tn.jsx(ln,{}),tn.jsx(t,{to:`/tags/${n.name}`,children:tn.jsx("span",{className:"hover:text-[#3370FF] active:text-[#3370FF]",children:n.name})}),tn.jsx("span",{className:"relative left-[4px] top-[-6px] text-xs text-[#999]",children:n.count})]},n.name)))})})},Hn=()=>{const{tag:n}=r(),e=kn.filter((e=>e.tags.includes(n||"")));return tn.jsx(mn,{articles:e})},Dn=()=>tn.jsxs("div",{className:"relative mt-10",children:[tn.jsx("h1",{className:"text-2xl font-bold",children:"👋 Hi, I'm Percy Kuang 👨‍💻‍"}),tn.jsx("p",{className:"mt-4 text-base leading-10",children:"一个专注于前端开发的工程师，喜欢研究技术，喜欢分享，喜欢学习，喜欢思考。大学毕业后在字节跳动的飞书部门工作了三年，对 B 端产品有深入的了解，对用户体验有深入的思考，享受将一个个想法落地成现实的过程。具体到技术方面，对工程化、组件化、 框架原理、性能优化、代码规范等都有深入的了解和实践，我也喜欢将这些技术以及思考记录下来，如果你对我研究的东西感兴趣，可以关注我的博客内容。"}),tn.jsx("p",{className:"mt-1 text-base leading-10",children:"工作之外，我喜欢看电影、听音乐、打游戏，如果假期时间比较长，我也会出去旅游，看看外面的世界。"})]}),Wn=s.lazy((()=>an((()=>Promise.resolve().then((()=>In))),void 0))),An=()=>tn.jsx(a,{children:tn.jsxs("div",{className:"max-w-192 mx-auto mb-0 mt-10 pb-20",children:[tn.jsx(cn,{}),tn.jsx("div",{className:"max-md:mx-4 max-md:my-0",children:tn.jsx(s.Suspense,{fallback:tn.jsx("div",{className:"mt-32 flex items-center justify-center",children:tn.jsx(bn,{size:32})}),children:tn.jsxs(i,{children:[tn.jsx(c,{path:"/",element:tn.jsx(vn,{})}),tn.jsx(c,{path:"/tags",element:tn.jsx(En,{})}),tn.jsx(c,{path:"/tags/:tag",element:tn.jsx(Hn,{})}),tn.jsx(c,{path:"/articles/:id",element:tn.jsx(Wn,{})}),tn.jsx(c,{path:"/about-me",element:tn.jsx(Dn,{})}),tn.jsx(c,{path:"*",element:tn.jsx(hn,{})})]})})})]})});sn.createRoot(document.getElementById("root")).render(tn.jsx(s.StrictMode,{children:tn.jsx(An,{})}));export{tn as j};
