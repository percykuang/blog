const n=JSON.parse("[{\"id\":\"1726424687\",\"title\":\"Webpack 常见问题\",\"date\":\"2022-07-16\",\"tags\":[\"webpack\"],\"fileName\":\"Webpack 常见问题.md\",\"content\":\"\\n## Webpack5 和 Webpack4 之间重要的区别\\n\\n1. 性能改进：Webpack5 在构建速度和打包体积方面进行了一些优化。它引入了持久缓存，可以减少构建时间。此外，Webpack5 还引入了更好的树摇（tree shaking）算法，可以更好地优化打包体积。\\n2. 模块联邦（Module Federation）：这是 Webpack5 中最重要的新功能之一。模块联邦允许不同的应用程序共享模块，从而实现更好的代码复用和拆分。\\n   这对于构建大型的微服务架构非常有用。\\n3. 支持 WebAssembly：Webpack5 对 WebAssembly 提供了更好的支持。它可以直接导入和导出 WebAssembly 模块，并且可以通过配置进行优化。\\n4. 改进的缓存策略：Webpack5 引入了更好的缓存策略，可以更好地利用浏览器缓存。这可以减少用户在更新应用程序时需要下载的文件数量。\\n5. 改进的 Tree Shaking：Webpack5 引入了更好的 Tree Shaking 算法，可以更好地识别和删除未使用的代码。这可以进一步减少打包体积。\\n6. 改进的持久缓存：Webpack5 引入了更好的持久缓存策略，可以更好地利用缓存。这可以减少构建时间。\\n\\n## 安装\\n\\n```js\\nnpm init -y     // 初始化package.json\\nnpm install webpack webpack-cli --save-dev\\n\\nnpx webpack --watch     // 监听文件修改\\nnpx webpack-dev-server  // 以server的方式启动项目，不会打包物理文件，而是输出到内存\\n```\\n\\n## 生命周期钩子\\n\\n- beforeRun：在 Webpack 开始运行之前调用，可以在此处执行一些准备工作。\\n\\n- run：在 Webpack 开始运行时调用，可以在此处执行一些初始化操作。\\n\\n- beforeCompile：在 Webpack 开始编译之前调用，可以在此处执行一些准备工作。\\n\\n- compile：在 Webpack 开始编译时调用，可以在此处执行一些初始化操作。\\n\\n- make：在 Webpack 开始构建编译器时调用，可以在此处执行一些准备工作。\\n\\n- afterCompile：在 Webpack 完成编译之后调用，可以在此处执行一些后处理操作。\\n\\n- emit：在 Webpack 生成最终的资源之前调用，可以在此处执行一些额外的操作，如生成额外的文件。\\n\\n- afterEmit：在 Webpack 生成最终的资源之后调用，可以在此处执行一些后处理操作。\\n\\n- done：在 Webpack 完成构建之后调用，可以在此处执行一些清理工作。\\n\\n### 使用钩子\\n\\n```js\\nmodule.exports = {\\n  // ...\\n  plugins: [\\n    {\\n      apply: (compiler) => {\\n        compiler.hooks.beforeRun.tap('MyPlugin', () => {\\n          console.log('Before run');\\n        });\\n\\n        compiler.hooks.done.tap('MyPlugin', () => {\\n          console.log('Build done');\\n        });\\n      },\\n    },\\n  ],\\n};\\n\\n//在上述示例中，我们定义了一个自定义插件，并在其中使用了beforeRun和done两个生命周期钩子函数。\\n//在这些钩子函数中，我们可以执行一些自定义的操作，如输出日志信息。\\n```\\n\\n## Loader（转换器）\\n\\nWebpack Loader 在 Webpack 构建过程中的生命周期中的工作主要分为以下几个阶段：\\n\\n- 解析阶段：Webpack 会根据配置文件中的入口文件，递归解析所有的依赖模块。在这个阶段，Webpack 会根据文件的后缀名来确定使用哪个 Loader 来处理该文件。\\n\\n- 编译阶段：在这个阶段，Webpack 会将解析后的模块转换成 AST（抽象语法树），并且根据配置文件中的规则，将模块中的代码进行转换和处理。这个阶段是 Loader 的主要工作阶段，Loader 可以对模块进行各种处理，例如转换代码、添加额外的功能等。\\n\\n- 生成阶段：在这个阶段，Webpack 会根据处理后的模块生成最终的输出文件。输出文件的格式和路径可以通过配置文件进行配置。\\n\\n在这些阶段中，Loader 主要在编译阶段发挥作用。Loader 可以通过导出一个函数来定义自己的处理逻辑，这个函数接收一个参数，即待处理的模块的源代码，然后返回处理后的代码。\\n\\n### 常用 Loader\\n\\n以下是一些常用的 Webpack Loader：\\n\\n- babel-loader：用于将 ES6+ 的 JavaScript 代码转换为 ES5 代码，以便在旧版本浏览器中运行。\\n\\n- css-loader：用于解析 CSS 文件，并处理其中的 import 和 url() 等语法。\\n\\n- style-loader：将解析后的 CSS 代码以 `<style>` 标签的形式插入到 HTML 文件中。\\n\\n- file-loader：用于处理文件资源（如图片、字体等），并将其复制到输出目录中。\\n\\n- url-loader：类似于 file-loader，但可以根据文件大小将文件转换为 DataURL，以减少 HTTP 请求。\\n\\n- sass-loader：用于将 SASS/SCSS 代码转换为 CSS 代码。\\n\\n- less-loader：用于将 Less 代码转换为CSS代码。\\n\\n- postcss-loader：用于对 CSS 代码进行后处理，如自动添加浏览器前缀等。\\n\\n- vue-loader：用于解析和转换 Vue 单文件组件。\\n\\n- ts-loader：用于将 TypeScript 代码转换为 JavaScript 代码。\\n\\n### 自定义 Loader\\n\\n```js\\n// 核心代码：\\n\\nfunction clearConsoleLoader(source) {\\n  // 使用正则表达式匹配并替换console语句\\n  const modifiedSource = source.replace(/console\\\\.[a-z]+\\\\(.+\\\\);?/g, '');\\n\\n  return modifiedSource;\\n}\\n\\nmodule.exports = clearConsoleLoader;\\n\\n//使用\\nmodule.exports = {\\n  // ...\\n  module: {\\n    rules: [\\n      {\\n        test: /\\\\.js$/,\\n        exclude: /node_modules/,\\n        use: ['babel-loader', './path/to/clearConsoleLoader.js'],\\n      },\\n    ],\\n  },\\n};\\n```\\n\\n## Plugin（插件）\\n\\n### 工作原理\\n\\nWebpack Plugin 是用来扩展 Webpack 功能的工具，它可以在 Webpack 构建过程中的不同阶段执行一些额外的操作。\\n\\n插件的工作原理是通过在 Webpack 的构建过程中的不同生命周期中注册一些钩子函数，然后在对应的阶段执行这些钩子函数中的逻辑。\\n\\nWebpack 的构建过程中有以下几个生命周期：\\n\\n- 初始化阶段：在这个阶段，Webpack 会初始化配置参数，加载插件，并准备开始编译。\\n\\n- 编译阶段：在这个阶段，Webpack 会从入口文件开始递归解析所有的依赖模块，并将模块转换成 AST（抽象语法树），然后根据配置文件中的规则进行转换和处理。\\n\\n- 完成编译阶段：在这个阶段，Webpack 已经完成了所有的模块的转换和处理，并且生成了最终的输出文件。\\n\\n- 输出阶段：在这个阶段，Webpack 会将生成的输出文件写入到磁盘上。\\n\\n插件可以在这些生命周期中的任意阶段注册对应的钩子函数，并在钩子函数中执行一些额外的操作。\\n\\n### 常用 Plugin\\n\\n以下是一些常用的 Webpack 插件：\\n\\n- html-webpack-plugin：用于生成 HTML 文件，并自动将打包后的资源插入到 HTML 文件中。\\n\\n- mini-css-extract-plugin：用于将 CSS 代码提取成单独的文件，并生成一个 CSS 文件。\\n\\n- webpack-bundle-analyzer：用于分析打包后的文件结构，并生成一个可视化的报告。\\n\\n- webpack-dev-server：用于提供一个本地开发服务器，并自动刷新浏览器。\\n\\n- webpack-merge：用于合并多个 Webpack 配置文件。\\n\\n- webpack-plugin-replace：用于在打包过程中替换文件中的变量。\\n\\n- webpack-bundle-analyzer：用于分析打包后的文件结构，并生成一个可视化的报告。\\n\\n- webpack-dev-server：用于提供一个本地开发服务器，并自动刷新浏览器。\\n\\n- webpack-merge：用于合并多个 Webpack 配置文件。\\n\\n- webpack-plugin-replace：用于在打包过程中替换文件中的变量。\\n\\n### 自定义 Plugin\\n\\n```js\\nclass MyPlugin {\\n  apply(compiler) {\\n    // 注册初始化阶段的钩子函数\\n    compiler.hooks.initialize.tap('MyPlugin', () => {\\n      console.log('MyPlugin initialized');\\n    });\\n\\n    // 注册编译阶段的钩子函数\\n    compiler.hooks.compile.tap('MyPlugin', () => {\\n      console.log('MyPlugin compiling');\\n    });\\n  }\\n}\\n\\nmodule.exports = MyPlugin;\\n\\n// 使用\\n\\nconst MyPlugin = require('./my-plugin');\\n\\nmodule.exports = {\\n  // ...\\n  plugins: [\\n    new MyPlugin(),\\n  ],\\n};\\n```\\n\\n## 打包过程\\n\\n- 读取配置文件：Webpack 会首先读取配置文件，根据配置文件中的入口、出口等信息进行打包。\\n\\n- 解析模块依赖：Webpack 会从指定的入口文件开始递归解析所有的模块依赖，直到找到所有的模块。\\n\\n- 加载器处理：对于不同类型的模块，Webpack 会使用相应的加载器对其进行处理。例如，对于 JavaScript 模块，Webpack 会使用 Babel 加载器将 ES6 语法转换为 ES5 语法；对于 CSS 模块，Webpack 会使用 CSS 加载器将 CSS 代码打包进 JS 文件中。\\n\\n- 插件处理：在模块加载完成之后，Webpack 会执行一系列插件，用于完成一些额外的任务，例如生成 HTML 文件、提取 CSS 文件等。\\n\\n- 编译打包：Webpack 将经过处理的模块和插件生成最终的打包文件。通常情况下，Webpack 会生成一个或多个 JavaScript 文件，同时也可以生成其他类型的文件，例如 CSS、图片等。\\n\\n- 输出打包文件：Webpack 将生成的打包文件输出到指定的目录中。通常情况下，Webpack 会将打包文件输出到 dist 目录下。\\n\\n## 加速 Webpack 打包速度和减小打包体积的优化\\n\\n### 优化打包速度\\n\\n1. 优化 Webpack 配置：使用 Tree shaking 来减小打包体积，设置 Webpack 的 mode 为 production 以启用 UglifyJsPlugin 等插件进行代码压缩和优化。\\n\\n2. 使用 Webpack 的 code splitting 功能：将代码分割成较小的块，以便在需要时动态加载。\\n\\n3. 压缩图片和字体文件：使用 ImageMinWebpackPlugin 和 FontminWebpackPlugin 等插件来压缩图片和字体文件，减小打包体积。\\n\\n4. 缓存：启用 Webpack 的缓存功能，以便在修改代码时只重新打包修改的文件，而不是重新打包所有文件。\\n\\n5. 使用 DLLPlugin和DllReferencePlugin：将一些第三方库打包成单独的文件，以便在每次打包应用程序时不必重新打包这些库。\\n\\n6. 使用 HappyPack 插件：使用多线程来加速Webpack打包，以便同时处理多个任务。\\n\\n7. 使用 externals 选项：将一些不需要打包的库从打包中排除，以便减小打包体积。\\n\\n8. 使用 webpack-bundle-analyzer 插件：分析打包后的文件，以便找出冗余的代码和依赖关系，进行优化。\\n\\n这些技巧可以帮助优化Webpack的打包速度和打包体积。\\n\\n## Webpack 配置文件\\n\\n```js\\nconst path = require('path');\\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // 自动引入资源插件  npm install --save-dev html-webpack-plugin\\nconst MiniCssExtracPlugin = require('mini-css-extrac-plugin'); // css抽离\\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\\n//加载toml、yarm、json5数据资源 npm install toml yarm json5 -D\\nconst toml = require('toml');\\nconst yarm = require('yarm');\\nconst json5 = require('json5');\\n\\nmodule.exports = (env) => {\\n  return {\\n    // 手动分离公共文件，通过配置成对象的方式实现多入口代码分割\\n    // entry: {\\n    //  index:{\\n    //    import:\\\"./src/index.js\\\",\\n    //    dependOn: \\\"shared\\\"  // 抽离公共文件\\n    //  },\\n    //  shared: \\\"lodash\\\"      // 公共的js文件\\n    // },\\n    // 多入口\\n    // entry: {\\n    // \\t pageOne: './src/pageOne/index.js',\\n    //  \\tpageTwo: './src/pageTwo/index.js',\\n    //  \\tpageThree: './src/pageThree/index.js',\\n    // },\\n    // 单入口\\n    entry: {\\n      index: './src/index.js',\\n    },\\n    output: {\\n      filename: 'scripts/[name].[contenthash].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\\n      path: path.resolve(__dirname, './dist'),\\n      clean: true, // 清除上一次的垃圾文件\\n      assetModuleFilename: 'images/[contenthash][ext]', // 在images目录下，根据文件内容自动生成hash文件名\\n      publicPath: 'https://*****.com/', // 公共路径（cdn域名或者本地localhost）\\n    },\\n    mode: env.prodection ? 'prodection' : 'development', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\\n    devtool: 'cheap-module-source-map', // 真实报错文件指向,生产环境一般不开启sourcemap\\n    // 插件（非必要的，缺少也不影响项目打包）\\n    plugins: [\\n      new HtmlWebpackPlugin({\\n        template: './index.html', // 模板\\n        filename: 'app.html',\\n        inject: 'body', // script 存在的位置\\n        hash: true, // 解决缓存\\n        minify: {\\n          removeAttributeQuotes: true, // 压缩，去掉引号\\n        },\\n      }),\\n      new MiniCssExtracPlugin({\\n        filename: 'style/[contenthash].css',\\n      }),\\n    ],\\n    devServer: {\\n      static: './dist', // 监听根目录文件变化，自动刷新页面插件 npm install --save-dev webpack-dev-server\\n      //反向代理\\n      proxy: {\\n        '/ajax': {\\n          target: 'https:**********',\\n          ws: true,\\n          changeOrigin: true,\\n        },\\n      },\\n    },\\n    // 模块（必要的，缺少影响项目打包）\\n    module: {\\n      rules: [\\n        //资源模块类型我们称之为Asset Modules Type，总共有四种，来代替loader，分别是：\\n        // asset/resource：发送一个单独的文件并导出URL，替代file-loader\\n        // asset/inline：导出一个资源的data URI(base64)，替代url-loader\\n        // asset/source：导出资源的源代码，之前通过使用raw-loader实现\\n        // asset：介于asset/resource和asset/inline之间， 之前通过url-loader+limit属性实现。\\n        {\\n          test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则图片文件\\n          type: 'asset',\\n          generator: {\\n            filename: 'images/[contenthash][ext]', // 优先级高于 assetModuleFilename\\n          },\\n        },\\n        {\\n          // 支持less\\n          // npm install style-loader css-loader less-loader less --save-dev\\n          // 抽离 npm install mini-css-extrac-plugin  --save-dev   webpack5环境下构建的插件\\n          test: /\\\\.(le|c)ss$/, // .less and .css\\n          use: [MiniCssExtracPlugin.loader, /* \\\"style-loader\\\", */ 'css-loader', 'less-loader'],\\n        },\\n        {\\n          test: /\\\\.(woff|woff2|eot|ttf|oft)$/, // 正则字体文件\\n          type: 'asset/resource',\\n        },\\n        //加载csv、xml数据资源 npm install csv-loader xml-loader -D\\n        {\\n          test: /\\\\.(csv|tsv)$/,\\n          use: 'csv-loader',\\n        },\\n        {\\n          test: /\\\\.xml$/,\\n          use: 'xml-loader',\\n        },\\n        //加载toml、yarm、json5数据资源\\n        {\\n          test: /\\\\.toml$/,\\n          type: 'json',\\n          parser: {\\n            parse: toml.parse,\\n          },\\n        },\\n        {\\n          test: /\\\\.yarm$/,\\n          type: 'json',\\n          parser: {\\n            parse: yarm.parse,\\n          },\\n        },\\n        {\\n          test: /\\\\.json5$/,\\n          type: 'json',\\n          parser: {\\n            parse: json5.parse,\\n          },\\n        },\\n        // loader工具 支持数组方式链式调用，数组靠后的元素先执行\\n        {\\n          // 压缩图片\\n          //图片小于一定大小使用base64 否则使用file-loader产生真实图片 npm install url-loader --save-dev\\n          test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则\\n          use: [\\n            {\\n              loader: 'url-loader',\\n              options: {\\n                limit: 5000, //小于限定使用base64\\n                name: 'home/images/[name].[hash:8].[ext]',\\n                publicPath: `../../`,\\n                esModule: false,\\n              },\\n            },\\n          ],\\n        },\\n        // 使用babel-loader npm install -D babel-loader @babel/core @babel/preset-env\\n        // regeneratorRuntime是webpack打包生成的全局辅助函数，由babel生成，用于兼容 async/await 的语法\\n        // npm install --save @babel/runtime\\n        // npm install --save-dev @babel/plugin-transform-runtime\\n        {\\n          test: /\\\\.js$/,\\n          exclude: /node_modules/, // *业务代码里面可能会引入node_modules外部js，这些js不需要babel-loader编译，因此需要排除掉\\n          use: {\\n            loader: 'babel-loader', // *引入babel-loader\\n            options: {\\n              presets: ['@babel/preset-env'], // *引入预设\\n              plugins: [\\n                [\\n                  '@babel/plugin-transform-runtime', // *配置插件信息\\n                ],\\n              ],\\n            },\\n          },\\n        },\\n      ],\\n    },\\n    optimization: {\\n      minimizer: [new CssMinimizerPlugin(), new TerserPlugin()], //代码压缩 mode改为 production\\n      splitChunks: {\\n        // 缓存\\n        cacheGroups: {\\n          vendor: {\\n            test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n            name: 'vendors',\\n            chunks: 'all', // 自动重复代码抽离\\n          },\\n        },\\n      },\\n    },\\n  };\\n};\\n```\\n\\n## Webpack 配置文件拆分\\n\\n### webpack.config.common.js\\n\\nwebpack.config.common.js 文件用于公共环境配置\\n\\n```js\\nconst path = require('path');\\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // 自动引入资源插件  npm install --save-dev html-webpack-plugin\\nconst MiniCssExtracPlugin = require('mini-css-extrac-plugin'); // css抽离\\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\\n//加载toml、yarm、json5数据资源 npm install toml yarm json5 -D\\nconst toml = require('toml');\\nconst yarm = require('yarm');\\nconst json5 = require('json5');\\n\\nmodule.exports = {\\n  entry: {\\n    index: './src/index.js',\\n  },\\n  output: {\\n    path: path.resolve(__dirname, './dist'),\\n    clean: true, // 清除上一次的垃圾文件\\n    assetModuleFilename: 'images/[contenthash][ext]', // 在images目录下，根据文件内容自动生成hash文件名\\n  },\\n  // 插件（非必要的，缺少也不影响项目打包）\\n  plugins: [\\n    new HtmlWebpackPlugin({\\n      template: './index.html', // 模板\\n      filename: 'app.html',\\n      inject: 'body', // script 存在的位置\\n      hash: true, // 解决缓存\\n      minify: {\\n        removeAttributeQuotes: true, // 压缩，去掉引号\\n      },\\n    }),\\n    new MiniCssExtracPlugin({\\n      filename: 'style/[contenthash].css',\\n    }),\\n  ],\\n  // 模块（必要的，缺少影响项目打包）\\n  module: {\\n    rules: [\\n      //资源模块类型我们称之为Asset Modules Type，总共有四种，来代替loader，分别是：\\n      // asset/resource：发送一个单独的文件并导出URL，替代file-loader\\n      // asset/inline：导出一个资源的data URI(base64)，替代url-loader\\n      // asset/source：导出资源的源代码，之前通过使用raw-loader实现\\n      // asset：介于asset/resource和asset/inline之间， 之前通过url-loader+limit属性实现。\\n      {\\n        test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则图片文件\\n        type: 'asset',\\n        generator: {\\n          filename: 'images/[contenthash][ext]', // 优先级高于 assetModuleFilename\\n        },\\n      },\\n      {\\n        // 支持less\\n        // npm install style-loader css-loader less-loader less --save-dev\\n        // 抽离 npm install mini-css-extrac-plugin  --save-dev   webpack5环境下构建的插件\\n        test: /\\\\.(le|c)ss$/, // .less and .css\\n        use: [MiniCssExtracPlugin.loader, /* \\\"style-loader\\\", */ 'css-loader', 'less-loader'],\\n      },\\n      {\\n        test: /\\\\.(woff|woff2|eot|ttf|oft)$/, // 正则字体文件\\n        type: 'asset/resource',\\n      },\\n      //加载csv、xml数据资源 npm install csv-loader xml-loader -D\\n      {\\n        test: /\\\\.(csv|tsv)$/,\\n        use: 'csv-loader',\\n      },\\n      {\\n        test: /\\\\.xml$/,\\n        use: 'xml-loader',\\n      },\\n      //加载toml、yarm、json5数据资源\\n      {\\n        test: /\\\\.toml$/,\\n        type: 'json',\\n        parser: {\\n          parse: toml.parse,\\n        },\\n      },\\n      {\\n        test: /\\\\.yarm$/,\\n        type: 'json',\\n        parser: {\\n          parse: yarm.parse,\\n        },\\n      },\\n      {\\n        test: /\\\\.json5$/,\\n        type: 'json',\\n        parser: {\\n          parse: json5.parse,\\n        },\\n      },\\n      // loader工具 支持数组方式链式调用，数组靠后的元素先执行\\n      {\\n        // 压缩图片\\n        //图片小于一定大小使用base64 否则使用file-loader产生真实图片 npm install url-loader --save-dev\\n        test: /\\\\.(png|gif|jp?g|svg|webp|ico)$/, // 正则\\n        use: [\\n          {\\n            loader: 'url-loader',\\n            options: {\\n              limit: 5000, //小于限定使用base64\\n              name: 'home/images/[name].[hash:8].[ext]',\\n              publicPath: `../../`,\\n              esModule: false,\\n            },\\n          },\\n        ],\\n      },\\n      // 使用babel-loader npm install -D babel-loader @babel/core @babel/preset-env\\n      // regeneratorRuntime是webpack打包生成的全局辅助函数，由babel生成，用于兼容 async/await 的语法\\n      // npm install --save @babel/runtime\\n      // npm install --save-dev @babel/plugin-transform-runtime\\n      {\\n        test: /\\\\.js$/,\\n        exclude: /node_modules/, // *业务代码里面可能会引入node_modules外部js，这些js不需要babel-loader编译，因此需要排除掉\\n        use: {\\n          loader: 'babel-loader', // *引入babel-loader\\n          options: {\\n            presets: ['@babel/preset-env'], // *引入预设\\n            plugins: [\\n              [\\n                '@babel/plugin-transform-runtime', // *配置插件信息\\n              ],\\n            ],\\n          },\\n        },\\n      },\\n    ],\\n  },\\n  optimization: {\\n    splitChunks: {\\n      // 缓存\\n      cacheGroups: {\\n        vendor: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          name: 'vendors',\\n          chunks: 'all', // 自动重复代码抽离\\n        },\\n      },\\n    },\\n  },\\n};\\n```\\n\\n### webpack.config.dev.js\\n\\nwebpack.config.dev.js 文件用于开发环境配置，`npx webpack -c ./webpack.config.dev.js`\\n\\n```js\\nmodule.exports = {\\n  output: {\\n    filename: 'scripts/[name].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\\n  },\\n  mode: 'development', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\\n  devtool: 'cheap-module-source-map', // 真实报错文件指向,生产\\n  devServer: {\\n    static: './dist', // 监听根目录文件变化，自动刷新页面插件 npm install --save-dev webpack-dev-server\\n    //反向代理\\n    proxy: {\\n      '/ajax': {\\n        target: 'https:**********',\\n        ws: true,\\n        changeOrigin: true,\\n      },\\n    },\\n  },\\n};\\n```\\n\\n### webpack.config.prod.js\\n\\nwebpack.config.prod.js 文件用于生产环境配置，`npx webpack -c ./webpack.config.prod.js`\\n\\n```js\\nconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); //css压缩 npm install css-minimizer-webpack-plugin  --save-dev\\nconst TerserPlugin = require('terser-webpack-plugin'); // js压缩  npm install --save-dev terser-webpack-plugin\\n\\nmodule.exports = {\\n  output: {\\n    filename: 'scripts/[name].[contenthash].js', // 将所有的js放入同一个文件夹，并且根据文件名自动命名\\n    publicPath: 'https://*****.com/', // 公共路径（cdn域名或者本地localhost）\\n  },\\n  mode: 'prodection', // 生产环境或者开发环境 package.json 启动命令：npx webpack --env prodection\\n  optimization: {\\n    minimizer: [new CssMinimizerPlugin(), new TerserPlugin()], //代码压缩 mode改为 production\\n  },\\n  performance: {\\n    hints: false, // 关闭性能提示\\n  },\\n};\\n```\\n\\n### webpack.config.js\\n\\n总的配置文件，根据环境变量来决定使用哪个配置文件，`npx webpack -c ./webpack.config.js --env development`\\n\\n```js\\nconst { merge } = require('webpack-merge'); // npm install webpack-merge -D\\nconst commonConfig = require('./webpack.config.common');\\nconst productionConfig = require('./webpack.config.prod');\\nconst developmentConfig = require('./webpack.config.dev');\\n\\nmodule.exports = (env) => {\\n  switch (true) {\\n    case env.development:\\n      return merge(commonConfig, developmentConfig);\\n    case env.production:\\n      return merge(commonConfig, productionConfig);\\n      defult: return new Error();\\n  }\\n};\\n```\\n\\n## 封装 Webpack 自定义插件\\n\\n```js\\n1. 创建一个 JavaScript 文件，并导出一个函数。这个函数将作为你的插件的构造函数。\\n\\n2. 在函数中定义一个 apply 方法，该方法接收一个 compiler 参数。这个 compiler 对象是 Webpack 的核心，它包含了 Webpack 的所有配置和工作流程。\\n\\n3. 在 apply 方法中，可以通过 compiler.hooks 对象访问 Webpack 的生命周期钩子。通过这些钩子，你可以在 Webpack 运行的不同阶段执行自定义代码。\\n\\n4. 实现你的插件逻辑，例如在特定的 Webpack 钩子上注册回调函数，向编译器添加自定义插件等。\\n\\n5. 将你的插件打包成一个 npm 模块，并在项目中引入和使用它。\\n\\n下面是一个简单的 Webpack 插件示例：\\n\\nconst MyPlugin = function() {};\\n\\nMyPlugin.prototype.apply = function(compiler) {\\n  compiler.hooks.done.tap('MyPlugin', stats => {\\n    console.log('Webpack is done!');\\n  });\\n};\\n\\nmodule.exports = MyPlugin;\\n\\n在这个示例中，我们定义了一个 MyPlugin 插件，它在 Webpack 编译完成后输出一条信息。\\n在 apply 方法中，我们使用 compiler.hooks.done 钩子注册了一个回调函数，在编译完成后输出一条消息。\\n\\n要使用这个插件，你需要将它打包成一个 npm 模块，并在 Webpack 配置文件中引入和使用它：\\n\\nconst MyPlugin = require('my-plugin');\\n\\nmodule.exports = {\\n  plugins: [\\n    new MyPlugin()\\n  ]\\n};\\n\\n这个示例中，我们在 Webpack 配置文件中引入了 MyPlugin 插件，并将它作为插件数组的一项传递给 plugins 选项。\\n这样，当 Webpack 编译时，MyPlugin 将会被启用并执行它的逻辑。\\n```\\n\",\"wordCount\":2361},{\"id\":\"1477085777\",\"title\":\"React 如何实现超大文件的上传和下载\",\"date\":\"2022-05-23\",\"tags\":[\"react\"],\"fileName\":\"React 如何实现超大文件的上传和下载.md\",\"content\":\"\\n## 背景\\n\\n文件传输是一个常见的需求。对于大文件的下载和上传，直接使用传统的方式可能会遇到性能和用户体验方面的问题。幸运的是，前端技术提供了一些高效的解决方案：文件流操作和切片下载与上传。本文将深入探讨这些技术，帮助你理解它们的原理和实现方法，以优化文件传输效率和提升用户体验。\\n\\n## 一、前端文件流操作\\n\\n在前端开发中，文件流操作是指通过数据流的方式处理文件，对文件进行读取、写入和展示等操作。下面详细介绍了前端文件流操作的几个基本概念和技术。\\n\\n### 数据流和文件处理的基本概念\\n\\n数据流是指连续的数据序列，可以从一个源传输到另一个目的地。在前端开发中，文件可以被看作数据流的一种形式，可以通过数据流的方式进行处理。文件处理涉及读取和写入文件的操作，包括读取文件的内容、写入数据到文件，以及对文件进行删除、重命名等操作。\\n\\n### Blob 对象和 ArrayBuffer：处理二进制数据\\n\\n在前端处理文件时，经常需要处理二进制数据。Blob（Binary Large Object）对象是用来表示二进制数据的一个接口，可以存储大量的二进制数据。Blob 对象可以通过构造函数进行创建，也可以通过其他 API 生成，例如通过 FormData 对象获取上传的文件。而 ArrayBuffer 是 JavaScript 中的一个对象类型，用于表示一个通用的、固定长度的二进制数据缓冲区。我们可以通过 ArrayBuffer 来操作和处理文件的二进制数据。\\n\\n代码如下：\\n\\n```jsx\\nimport React, { useState } from 'react';\\n\\nfunction FileInput() {\\n  const [fileContent, setFileContent] = useState('');\\n  // 读取文件内容到ArrayBuffer\\n  function readFileToArrayBuffer(file) {\\n    return new Promise((resolve, reject) => {\\n      const reader = new FileReader();\\n      // 堆代码 duidaima.com\\n      // 注册文件读取完成后的回调函数\\n      reader.onload = function (event) {\\n        const arrayBuffer = event.target.result;\\n        resolve(arrayBuffer);\\n      };\\n      // 读取文件内容到ArrayBuffer\\n      reader.readAsArrayBuffer(file);\\n    });\\n  }\\n  // 将ArrayBuffer转为十六进制字符串\\n  function arrayBufferToHexString(arrayBuffer) {\\n    const uint8Array = new Uint8Array(arrayBuffer);\\n    let hexString = '';\\n    for (let i = 0; i < uint8Array.length; i++) {\\n      const hex = uint8Array[i].toString(16).padStart(2, '0');\\n      hexString += hex;\\n    }\\n    return hexString;\\n  }\\n  // 处理文件选择事件\\n  function handleFileChange(event) {\\n    const file = event.target.files[0]; // 获取选中的文件\\n    if (file) {\\n      readFileToArrayBuffer(file)\\n        .then((arrayBuffer) => {\\n          const hexString = arrayBufferToHexString(arrayBuffer);\\n          setFileContent(hexString);\\n        })\\n        .catch((error) => {\\n          console.error('文件读取失败:', error);\\n        });\\n    } else {\\n      setFileContent('请选择一个文件');\\n    }\\n  }\\n  return (\\n    <div>\\n      <input type=\\\"file\\\" onChange={handleFileChange} />\\n      <div>\\n        <h4>文件内容：</h4>\\n        <pre>{fileContent}</pre>\\n      </div>\\n    </div>\\n  );\\n}\\n\\nexport default FileInput;\\n```\\n\\n上面代码里，我们创建了一个名为 FileInput 的函数式组件。该组件包含一个文件选择框和一个用于显示文件内容的 <pre> 元素。当用户选择文件时，通过 FileReader 将文件内容读取为 ArrayBuffer，然后将 ArrayBuffer 转换为十六进制字符串，并将结果显示在页面上。\\n\\n### 使用 FileReader 进行文件读取\\n\\nFileReader 是前端浏览器提供的一个 API，用于读取文件内容。通过 FileReader，我们可以通过异步方式读取文件，并将文件内容转换为可用的数据形式，比如文本数据或二进制数据。FileReader 提供了一些读取文件的方法，例如 readAsText()、readAsArrayBuffer() 等，可以根据需要选择合适的方法来读取文件内容。\\n\\n### 将文件流展示在前端页面中\\n\\n一旦我们成功地读取了文件的内容，就可以将文件流展示在前端页面上。具体的展示方式取决于文件的类型。例如，对于文本文件，可以直接将其内容显示在页面的文本框或区域中；对于图片文件，可以使用 <img> 标签展示图片；对于音视频文件，可以使用 <video> 或 <audio> 标签来播放。通过将文件流展示在前端页面上，我们可以实现在线预览和查看文件内容的功能。\\n\\n好的，这一部分就基本介绍完毕，总结一下。前端文件操作流是处理大型文件的一种常见方式，他可以通过数据流的方式对文件进行操作。Blob对象 和 ArrayBuffer是处理二进制数据的重要工具。而 FileReader则是读取文件内容的的关键组件。通过这些技术，我们可以方便的在前端页面上进行操作或者文件展示。\\n\\n## 二、文件切片下载\\n\\n这一步就进入到我们今天文章主题了，先来主要的看下流程:\\ngraph LR\\nA(开始) --> B{选择文件}\\nB -- 用户选择文件 --> C[切割文件为多个切片]\\nC --> D{上传切片}\\nD -- 上传完成 --> E[合并切片为完整文件]\\nE -- 文件合并完成 --> F(上传成功)\\nD -- 上传中断 --> G{保存上传进度}\\nG -- 上传恢复 --> D\\n\\nG -- 取消上传 --> H(上传取消)\\n\\n### 传统文件下载的性能问题\\n\\n文件切片下载是一种提升文件下载效率的技术，通过将大文件分割成多个小片段（切片），并使用多个并发请求同时下载这些切片，从而加快整体下载速度。传统的文件下载方式对于大文件来说存在性能问题。当用户请求下载一个大文件时，服务器需要将整个文件发送给客户端。这会导致以下几个问题：\\n\\n1. 较长的等待时间：大文件需要较长的时间来传输到客户端，用户需要等待很长时间才能开始使用文件。\\n2. 网络阻塞：由于下载过程中占用了网络带宽，其他用户可能会遇到下载速度慢的问题。\\n3. 断点续传困难：如果下载过程中出现网络故障或者用户中断下载，需要重新下载整个文件，无法继续之前的下载进度。\\n\\n### 利用文件切片提升下载效率\\n\\n文件切片下载通过将文件分割成多个小片段，每个片段大小通常在几百KB到几MB之间。然后客户端通过多个并发请求同时下载这些片段。这样做的好处是：\\n\\n![1.jpg](https://free4.yunpng.top/2025/02/27/67bfb865ba8df.jpg)\\n\\n快速启动：客户端可以快速开始下载，因为只需要下载第一个切片即可。\\n并发下载：通过使用多个并发请求下载切片，可以充分利用带宽，并提高整体下载速度。\\n断点续传：如果下载中断，客户端只需要重新下载中断的切片，而不需要重新下载整个文件。\\n\\n切片上传代码示例：\\n\\n```jsx\\nconst [selectedFile, setSelectedFile] = useState(null);\\nconst [progress, setProgress] = useState(0);\\n// 处理文件选择事件\\nfunction handleFileChange(event) {\\n  setSelectedFile(event.target.files[0]);\\n}\\n// 处理文件上传事件\\nfunction handleFileUpload() {\\n  if (selectedFile) {\\n    // 计算切片数量和每个切片的大小\\n    const fileSize = selectedFile.size;\\n    const chunkSize = 1024 * 1024; // 设置切片大小为1MB\\n    const totalChunks = Math.ceil(fileSize / chunkSize);\\n    // 创建FormData对象，并添加文件信息\\n    const formData = new FormData();\\n    formData.append('file', selectedFile);\\n    formData.append('totalChunks', totalChunks);\\n    // 循环上传切片\\n    for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\\n      const start = chunkNumber * chunkSize;\\n      const end = Math.min(start + chunkSize, fileSize);\\n      const chunk = selectedFile.slice(start, end);\\n      formData.append(`chunk-${chunkNumber}`, chunk, selectedFile.name);\\n    }\\n    // 发起文件上传请求\\n    axios\\n      .post('/upload', formData, {\\n        onUploadProgress: (progressEvent) => {\\n          const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);\\n          setProgress(progress);\\n        },\\n      })\\n      .then((response) => {\\n        console.log('文件上传成功:', response.data);\\n      })\\n      .catch((error) => {\\n        console.error('文件上传失败:', error);\\n      });\\n  }\\n}\\n```\\n\\n当涉及到切片上传和下载时，前端使用的技术通常是基于前端库或框架提供的文件处理功能，结合后端服务实现。\\n\\n上面代码里我们提到了文件如何切片上传。\\n当用户选择文件后，通过 handleFileChange 函数处理文件选择事件，将选择的文件保存在 selectedFile 状态中。\\n当用户点击上传按钮时，通过 handleFileUpload 函数处理文件上传事件。\\n\\n在 handleFileUpload 函数中，计算切片数量和每个切片的大小，并创建一个 FormData 对象用于存储文件信息和切片数据。\\n\\n### 实现客户端切片下载的方案\\n\\n实现客户端切片下载的基本方案如下：\\n\\n1. 服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。\\n2. 客户端发送请求获取切片列表，同时开始下载第一个切片。\\n3. 客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。\\n4. 当所有切片都下载完成后，客户端将下载的数据合并为完整的文件。\\n\\n代码示例：\\n\\n```jsx\\nfunction downloadFile() {\\n  // 发起文件下载请求\\n  fetch('/download', {\\n    method: 'GET',\\n    headers: {\\n      'Content-Type': 'application/json',\\n    },\\n  })\\n    .then((response) => response.json())\\n    .then((data) => {\\n      const totalSize = data.totalSize;\\n      const totalChunks = data.totalChunks;\\n      let downloadedChunks = 0;\\n      let chunks = [];\\n      // 下载每个切片\\n      for (let chunkNumber = 0; chunkNumber < totalChunks; chunkNumber++) {\\n        fetch(`/download/${chunkNumber}`, {\\n          method: 'GET',\\n        })\\n          .then((response) => response.blob())\\n          .then((chunk) => {\\n            downloadedChunks++;\\n            chunks.push(chunk);\\n            // 当所有切片都下载完成时\\n            if (downloadedChunks === totalChunks) {\\n              // 合并切片\\n              const mergedBlob = new Blob(chunks);\\n              // 创建对象 URL，生成下载链接\\n              const downloadUrl = window.URL.createObjectURL(mergedBlob);\\n              // 创建 <a> 元素并设置属性\\n              const link = document.createElement('a');\\n              link.href = downloadUrl;\\n              link.setAttribute('download', 'file.txt');\\n              // 模拟点击下载\\n              link.click();\\n              // 释放资源\\n              window.URL.revokeObjectURL(downloadUrl);\\n            }\\n          });\\n      }\\n    })\\n    .catch((error) => {\\n      console.error('文件下载失败:', error);\\n    });\\n}\\n```\\n\\n我们看下代码，首先使用 BLOB 对象创建一共对象 URL，用于生成下载连接，然后创建 a 标签并且设置 href 的属性为刚刚创建的对象 URL,继续设置 a 标签的 download 属性是文件名，方便点击的时候自动下载文件。\\n\\n### 显示下载进度和完成状态\\n\\n为了显示下载进度和完成状态，可以在客户端实现以下功能：\\n显示进度条：客户端可以通过监听每个切片的下载进度来计算整体下载进度，并实时更新进度条的显示。\\n显示完成状态：当所有切片都下载完成后，客户端可以显示下载完成的状态，例如显示一个完成的图标或者文本。\\n\\n这里我们可以继续接着切片上传代码示例里的继续写。\\n代码示例：\\n\\n```jsx\\n\\n// 处理文件下载事件\\nfunction handleFileDownload() {\\n  axios.get('/download', {\\n    responseType: 'blob',\\n    onDownloadProgress: progressEvent => {\\n      const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);\\n      setProgress(progress);\\n    }\\n  })\\n    .then(response => {\\n      // 创建一个临时的URL对象用于下载\\n      const url = window.URL.createObjectURL(new Blob([response.data]));\\n      const link = document.createElement('a');\\n      link.href = url;\\n      link.setAttribute('download', 'file.txt');\\n      document.body.appendChild(link);\\n      link.click();\\n      document.body.removeChild(link);\\n    })\\n    .catch(error => {\\n      console.error('文件下载失败:', error);\\n    });\\n}\\n\\n\\n<button onClick={handleFileDownload}>下载文件</button>\\n  <div>进度：{progress}%</div>\\n```\\n\\n1. 当用户点击下载按钮时，通过 handleFileDownload 函数处理文件下载事件。\\n2. 在 handleFileDownload 函数中，使用 axios 库发起文件下载请求，并设置 responseType: 'blob' 表示返回二进制数据。\\n3. 通过监听 onDownloadProgress 属性获取下载进度，并更新进度条的显示。\\n4. 下载完成后，创建一个临时的 URL 对象用于下载，并通过动态创建 <a> 元素模拟点击下载。\\n\\n## 三、大文件上传的问题与解决方案\\n\\n### 传统的文件上传方式存在的问题\\n\\n1. 大文件上传耗时长，容易导致请求超时。\\n2. 占用服务器和网络带宽资源，可能影响其他用户的访问速度。\\n3. 如果上传中断，需要重新上传整个文件，效率低下。\\n4. 难以实现上传进度的显示和控制。\\n\\n### 前端文件切片上传的优势\\n\\n1. 将大文件分割为更小的文件切片，分多次上传，提高上传效率和稳定性。\\n2. 提供上传进度的监控和展示，提高用户体验。\\n3. 充分利用浏览器的并发上传能力，减轻服务器负担。\\n4. 实现断点续传功能，避免重复上传已上传的部分。\\n\\n### 实现前端切片上传的方法\\n\\n1. 使用 JavaScript 的 `File API` 获取文件对象，并使用 `Blob.prototype.slice()` 方法将文件切割为多个切片。\\n2. 使用 FormData 对象将切片数据通过 AJAX 或 Fetch API 发送到服务器。\\n3. 在后端服务器上接收切片并保存到临时存储中，等待后续合并。\\n4. 在客户端通过监听上传进度事件，在进度条或提示中展示上传进度。\\n\\n代码示例：\\n\\n```jsx\\n\\nconst [file, setFile] = useState(null);  //用来存放我本地上传的文件\\nconst chunkSize = 1024 * 1024; // 1MB 切片大小\\nconst upload = () => {\\n  if (!file) {\\n    alert(\\\"请选择要上传的文件！\\\");\\n    return;\\n  }\\n  const chunkSize = 1024 * 1024; // 1MB\\n  let start = 0;\\n  let end = Math.min(chunkSize, file.size);\\n  while (start < file.size) {\\n    const chunk = file.slice(start, end);\\n\\n    // 创建FormData对象\\n    const formData = new FormData();\\n    formData.append('file', chunk);\\n    // 发送切片到服务器\\n    fetch('上传接口xxxx', {\\n      method: 'POST',\\n      body: formData\\n    })\\n      .then(response => response.json())\\n      .then(data => {\\n        console.log(data);\\n        // 处理响应结果\\n      })\\n      .catch(error => {\\n        console.error(error);\\n        // 处理错误\\n      });\\n    start = end;\\n    end = Math.min(start + chunkSize, file.size);\\n  }\\n};\\n\\nreturn (\\n  <div>\\n  <input type=\\\"file\\\" onChange={handleFileChange} />\\n  <button onClick={upload}>上传</button>\\n  </div>\\n);\\n```\\n\\n在上面的代码中，创建了一个名为 Upload 的函数组件。它使用了 React 的 useState 钩子来管理选中的文件。通过 onChange 事件监听文件输入框的变化，并在 handleFileChange 函数中获取选择的文件，并更新 file 状态。\\n\\n点击`上传`按钮时，调用 upload 函数。它与之前的示例代码类似，将文件切割为多个大小相等的切片，并使用 FormData 对象和 fetch 函数发送切片数据到服务器。\\n\\n### 实现断点续传的技术：记录和恢复上传状态\\n\\n在前端，可以使用 localStorage 或 sessionStorage 来存储已上传的切片信息，包括已上传的切片索引、切片大小等。每次上传前，先检查本地存储中是否存在已上传的切片信息，若存在，则从断点处继续上传。在后端，可以使用一个临时文件夹或数据库来记录已接收到的切片信息，包括已上传的切片索引、切片大小等。在上传完成前，保存上传状态，以便在上传中断后能够恢复上传进度。\\n\\n```jsx\\nimport React, { useEffect, useRef, useState } from 'react';\\n\\nfunction Upload() {\\n  const [file, setFile] = useState(null);\\n  const [uploadedChunks, setUploadedChunks] = useState([]);\\n  const [uploading, setUploading] = useState(false);\\n  const uploadRequestRef = useRef();\\n  const handleFileChange = (event) => {\\n    const selectedFile = event.target.files[0];\\n    setFile(selectedFile);\\n  };\\n  const uploadChunk = (chunk) => {\\n    // 创建FormData对象\\n    const formData = new FormData();\\n    formData.append('file', chunk);\\n    // 发送切片到服务器\\n    return fetch('your-upload-url', {\\n      method: 'POST',\\n      body: formData,\\n    })\\n      .then((response) => response.json())\\n      .then((data) => {\\n        console.log(data);\\n        // 处理响应结果\\n        return data;\\n      });\\n  };\\n  const upload = async () => {\\n    if (!file) {\\n      alert('请选择要上传的文件！');\\n      return;\\n    }\\n    const chunkSize = 1024 * 1024; // 1MB\\n    const totalChunks = Math.ceil(file.size / chunkSize);\\n    let start = 0;\\n    let end = Math.min(chunkSize, file.size);\\n    setUploading(true);\\n    for (let i = 0; i < totalChunks; i++) {\\n      const chunk = file.slice(start, end);\\n      const uploadedChunkIndex = uploadedChunks.indexOf(i);\\n      if (uploadedChunkIndex === -1) {\\n        try {\\n          const response = await uploadChunk(chunk);\\n          setUploadedChunks((prevChunks) => [...prevChunks, i]);\\n          // 保存已上传的切片信息到本地存储\\n          localStorage.setItem('uploadedChunks', JSON.stringify(uploadedChunks));\\n        } catch (error) {\\n          console.error(error);\\n          // 处理错误\\n        }\\n      }\\n      start = end;\\n      end = Math.min(start + chunkSize, file.size);\\n    }\\n    setUploading(false);\\n    // 上传完毕，清除本地存储的切片信息\\n    localStorage.removeItem('uploadedChunks');\\n  };\\n  useEffect(() => {\\n    const storedUploadedChunks = localStorage.getItem('uploadedChunks');\\n    if (storedUploadedChunks) {\\n      setUploadedChunks(JSON.parse(storedUploadedChunks));\\n    }\\n  }, []);\\n  return (\\n    <div>\\n      <input type=\\\"file\\\" onChange={handleFileChange} />\\n      <button onClick={upload} disabled={uploading}>\\n        {uploading ? '上传中...' : '上传'}\\n      </button>\\n    </div>\\n  );\\n}\\n```\\n\\n首先，使用 useState 钩子创建了一个 uploadedChunks 状态来保存已上传的切片索引数组。初始值为空数组。\\n然后，我们使用 useRef 钩子创建了一个 uploadRequestRef 引用，用于存储当前的上传请求。\\n在 handleFileChange 函数中，我们更新了 file 状态以选择要上传的文件。\\n在 uploadChunk 函数中，我们发送切片到服务器，并返回一个 Promise 对象来处理响应结果。\\n在 upload 函数中，我们添加了断点续传的逻辑。首先，我们获取切片的总数，并设置 uploading 状态为 true 来禁用上传按钮。\\n然后，我们使用 for 循环遍历所有切片。对于每个切片，我们检查 uploadedChunks 数组中是否已经包含该索引，如果不包含，则进行上传操作。\\n在上传切片之后，我们将已上传的切片索引添加到 uploadedChunks 数组，并使用 localStorage 保存已上传的切片信息。\\n最后，在上传完毕后，我们将 uploading 状态设为 false，并清除本地存储的切片信息。\\n\\n在实现大文件上传时要考虑服务器端的处理能力和存储空间，以及安全性问题。同时，为了保障断点续传的准确性，应该尽量避免并发上传相同文件的情况，可以采用文件唯一标识符或用户会话标识符进行区分。\\n\\n## 四、优化用户体验：切片下载与上传的应用场景\\n\\n### 后台管理系统中的文件下载和上传\\n\\n文件下载：在后台管理系统中，用户可能需要下载大型文件，如报表、日志文件、数据库备份等。通过将文件切片下载，可以提高下载速度和稳定性，同时允许用户中断下载并从中断处继续下载。\\n\\n文件上传：后台管理系统中，用户可能需要上传大型文件，如数据导入、文件备份等。使用切片上传可以提高上传效率，分批上传文件切片，并显示上传进度，使用户能够了解上传的状态。\\n\\n### 图片/视频上传和预览\\n\\n图片上传和预览：在图片上传场景中，用户可以选择多张图片进行上传。通过切片上传，可以加快图片上传速度，并实时显示上传进度。同时，在上传完成后，可以提供预览功能，让用户可以立即查看上传的图片。\\n\\n视频上传和预览：对于较大的视频文件，切片上传可以确保上传过程可靠且高效。同时，可以实现上传进度的实时展示。上传完成后，通过切片下载技术，用户可以流畅地观看视频，无需等待整个文件下载完成。\\n\\n### 云存储和云盘应用中的文件操作\\n\\n文件分块上传：云存储和云盘应用通常需要处理大量文件的上传。通过切片上传可以提高上传速度和稳定性，并允许用户中断并继续上传。\\n文件分块下载：当用户需要下载云存储或云盘中的大型文件时，可以使用切片下载技术，加快下载速度并提供中断恢复功能。\\n文件预览和在线编辑：通过将文件切片并进行预览，在线编辑，可以提供更好的用户体验。用户可以在不需完全下载文件的情况下，直接预览和编辑文件。\\n\",\"wordCount\":3701},{\"id\":\"802312278\",\"title\":\"class-transformer 实践\",\"date\":\"2020-12-14\",\"tags\":[\"typescript\",\"class-transformer\"],\"fileName\":\"class-transformer 实践.md\",\"content\":\"\\n## 为什么要使用这个库\\n\\n比如，我们在后台管理系统中要发布一篇文章，我们只需创建一个普通的平面对象，然后将所有填写的标题、内容等信息给到这个普通对象。但是，如果这个普通对象若是转为对应的类对象，则会出现以下问题：\\n\\n代码：\\n\\n```ts\\nimport { plainToClass } from 'class-transformer';\\nimport { validate } from 'class-validator';\\nimport Express from 'express';\\n\\nimport Article from './model/Article';\\nimport articleRoute from './routes/articleRoute';\\n\\nconst app = Express();\\n\\napp.use('/api/article', articleRoute);\\n\\n// 约束为平面对象\\nconst article: any = {};\\n\\narticle.title = '12345';\\narticle.content = '123';\\narticle.publishTime = new Date();\\n// 下面的属性是必须的，但是这里进行注释\\n// article.tagList = ['12']\\n\\n// 按理说，这里应该要输出缺失了tagList这个属性的信息\\nvalidate(article).then((errors) => {\\n  console.log(errors);\\n});\\n\\napp.listen(3000, () => console.log('服务已开启！'));\\n```\\n\\n运行结果（没有捕获到任何信息）：\\n\\n![1.png](https://free4.yunpng.top/2025/02/27/67bfb1b1c37a5.png)\\n\\n因此，我们需要对平面对象进行转换，才可结合 class-validator 对类属性信息进行约束。\\n\\n## 安装\\n\\n```ts\\nyarn add class-transformer\\n```\\n\\n## 使用\\n\\n```ts\\nimport { plainToClass } from 'class-transformer';\\nimport { validate } from 'class-validator';\\nimport Express from 'express';\\n\\nimport Article from './model/Article';\\nimport articleRoute from './routes/articleRoute';\\n\\nconst app = Express();\\n\\napp.use('/api/article', articleRoute);\\n\\n// 这是个平面对象\\nconst article: any = {};\\n\\narticle.title = '12345';\\narticle.content = '123';\\narticle.publishTime = new Date();\\n\\nconst newArticle = plainToClass(Article, article);\\n\\nvalidate(newArticle).then((errors) => {\\n  console.log(errors);\\n});\\n\\napp.listen(3000, () => console.log('服务已开启！'));\\n```\\n\\n运行结果:\\n\\n![2.png](https://free4.yunpng.top/2025/02/27/67bfb1b1ad296.png)\\n\\n## 没这么简单\\n\\n如果，一开始给平面对象赋值时的属性的类型就不对呢？\\n\\n如下代码：\\n\\n```ts\\n// 这是个平面对象\\nconst article: any = {};\\n\\n// 类约束是的类型是字符串，这里赋值数字\\narticle.title = 123;\\narticle.content = '123';\\narticle.publishTime = new Date();\\narticle.tagList = ['123'];\\n\\nconst newArticle = plainToClass(Article, article);\\n\\nconsole.log(newArticle.title, typeof newArticle.title);\\n\\nvalidate(newArticle).then((errors) => {\\n  console.log(errors);\\n});\\n```\\n\\n运行结果：\\n\\n![3.png](https://free4.yunpng.top/2025/02/27/67bfb1ec0579f.png)\\n\\n这里可以看出，虽然数据类型对于不上，但还是验证通过了。所以，我们需要使用 class-transform 提供给我们的运行时的类型验证。\\n\\n## 使用装饰器 @Type 进行运行时的类型约束\\n\\n1. 安装reflect-metadata\\n\\n```ts\\nyarn add reflect-metadata\\n```\\n\\n2. 在入口文件`index.ts`中全局导入\\n\\n```ts\\n// 最好在第一行导入，否则可能依旧会报错\\nimport 'reflect-metadata'\\nimport Express from 'express'\\nimport articleRoute from './routes/articleRoute'\\nimport Article from './model/Article'\\nimport { validate } from 'class-validator'\\nimport { plainToClass } from 'class-transformer'\\n...\\n```\\n\\n3. 对Article类进行运行时的类型约束\\n\\n```ts\\nimport { ArrayMinSize, IsDate, IsNotEmpty } from 'class-validator'\\nimport { Type } from 'class-transformer'\\n\\nclass Article {\\n\\n  @IsNotEmpty({ message: '文章标题不可以为空' })\\n  // 运行时的类型约束\\n  @Type(() => String)\\n  public title: string\\n\\n  @IsNotEmpty({ message: '文章标签不可以为空' })\\n  @ArrayMinSize(1, { message: '文章标签至少有一个' })\\n  // 文档建议如果是字符串的数组，使用字符串约束更好，因为js其实不存在数字数组，字符串数组等\\n  @Type(() => String)\\n  // 上面虽然解决了不是字符串的数组的问题，但是如果传进来的是一个字符串呢？这就太tm难了，所以再在编译时检查一下算了吧，运行时不管了\\n  @IsArray({ message: '文章标签必须是一个数组' })\\n  public tagList: string[]\\n\\n  @IsNotEmpty({ message: '发布日期不可以为空' })\\n  @IsDate()\\n  @Type(() => Date)\\n  public publishTime: Date\\n\\n  @IsNotEmpty({ message: '文章内容不可以为空' })\\n  @Type(() => String)\\n  public content: string\\n}\\n\\nexport default Article\\n```\\n\\n4. 运行结果\\n\\n![4.png](https://free4.yunpng.top/2025/02/27/67bfb1ec05754.png)\\n\\n可以看出，已经将数字类型的 title 转为了字符串类型，同时也通过了验证。\\n\",\"wordCount\":308},{\"id\":\"1155390892\",\"title\":\"React 工程中 SVG 的高级使用方法\",\"date\":\"2020-09-09\",\"tags\":[\"react\",\"webpack\",\"svg\"],\"fileName\":\"React 工程中 SVG 的高级使用方法.md\",\"content\":\"\\n## 比较 low 的做法\\n\\n打开 create-react-app 的官方文档，它会告诉你使用 svg，将 svg 进行导入（实际导入的是 svg 的路径字符串），然后放到 img 的 src 上。这种方法我们称为将 svg 当做图片使用。\\n\\n为什么这种方式不好？\\n\\n比如：无法改变 svg 的颜色\\n\\n## 使用 svg-sprite-loader（自己配置法）\\n\\n使用 svg-sprite-loader 要在 webpack.config.js 里配置，但是我们用 create-react-app 搭建起来的项目里没有 webpack 的配置文件。\\n\\n使用 `yarn eject` 命令，可以把配置文件弄出来。运行后，发现项目下多了两个目录，其中就有 webpack.config.js，我们就可以修改它进行配置。按照官网配置即可。\\n\\n注意：一定要先进行 git commit，才能运行 eject，否则会无法成功弹出配置。\\n\\n### 步骤\\n\\n1. 安装两个 loader\\n\\n```\\nyarn add --dev svg-sprite-loader\\nyarn add --dev svgo-loader\\n```\\n\\n2. 在 webpack.config.js 中配置这两个 loader\\n\\n```js\\n{\\n  test: /\\\\.svg$/,\\n  use: [\\n    { loader: 'svg-sprite-loader', options: {} },\\n    { loader: 'svgo-loader', options: {} },\\n  ]\\n},\\n```\\n\\n3. 使用\\n\\nApp.tsx\\n\\n```tsx\\nimport x from \\\"icons/apple.svg\\\";\\n\\nconsole.log(x) // 查看浏览器dom树，可以发现多了一个svg\\n\\n// 多出来的svg如下：\\n<svg fill='red'>\\n   <use xlinkHref='#apple'/>\\n</svg>\\n```\\n\\napple 就是文件名。svg 上还可以直接加 fill 属性来改变颜色。\\n引入的 x 如果不使用，就是如果不打印，页面上的图标就看不到了。必须用一下图标才能生效。这是因为treeshaking，意思是，如果你用不上一个东西，我就把他从树上摇下来。react 发现你引入了 x，但是没使用，就会把它删了。\\n那我怎么样既能引入也不需要打印呢？\\ntreeshaking 不适用于 require，所以可以用 require导入\\n\\n4. 封装 svg 成 icon 组件\\n\\n现在每次使用 svg 都要写三句代码，还要 require 引入。避免重复，把它封装成组件。\\n\\n```tsx\\nimport React from 'react';\\n\\nconst importAll = (requireContext: __WebpackModuleApi.RequireContext) => requireContext.keys().forEach(requireContext);\\ntry {\\n  importAll(require.context('../icons', true, /\\\\.svg$/));\\n} catch (error) {\\n  console.log(error);\\n}\\n\\ntype Props = {\\n  name: string;\\n};\\n\\nfunction Icon(props: Props) {\\n  return (\\n    <svg className=\\\"icon\\\">\\n      <use xlinkHref={'#' + props.name} />\\n    </svg>\\n  );\\n}\\n\\nexport default Icon;\\n```\\n\\n说明：\\n\\n把 require 导入也放进来。但是如果有 100 个 svg，就要写 100 次 require。所以我们选择直接导入一个目录，这个目录里存放所有的 svg。这里封装为 importAll。\\n\\n但是有报错，说找不到 `__WebpackModuleApi`，这是因为在 ts 里不支持这个的问题。去谷歌搜索解决方案。\\n安装：`yarn add --dev @types/webpack-env` 就可以解决。\\n\\n其他组件想使用 Icon，一句话引入即可 `<Icon name='chart'/>` name 属性是文件名。\\n\\nIcon 如果想改变颜色，可以直接在 css 里用 fill 改变：\\n\\n```css\\n.icon {\\n  fill: rgb(140, 177, 253);\\n}\\n```\\n\\n可是有一些svg图标是自带颜色的，在它们的文件里会通过 fill 属性指定颜色。如果是这种情况，就改不了颜色了。我们可以选择手动去它们的 svg 文件里删除 fill 属性，但是如果有很多图标，一个个删除太慢了。\\n\\nsvgo-loader 有一个功能，可以删除fill属性，只需要把需要的语句添加到配置文件的 svgo-loader 后边的选项options 里边就可以。\\nsvgo 就是 svg optimizer 优化器的意思。\\n\\n```js\\n{ loader: 'svgo-loader', options: {\\n  plugins:[\\n      {removeAttrs: {attrs:'fill'}}\\n    ]\\n  }\\n},\\n```\\n\",\"wordCount\":682},{\"id\":\"76987253\",\"title\":\"使用 useReducer 和 Context 实现 redux 的功能\",\"date\":\"2020-07-24\",\"tags\":[\"react\",\"redux\"],\"fileName\":\"使用 useReducer 和 Context 实现 redux 的功能.md\",\"content\":\"\\n## 使用 useReducer 和 Context 实现 redux 的功能\\n\\n步骤：\\n\\n1. 将数据集中在一个 store 对象\\n2. 将所有操作集中在 reducer\\n3. 创建一个 Context\\n4. 创建对数据的读写 API\\n5. 将第4步的内容放到第 3 步的 Context 中\\n6. 用 Context.Provider 将 Context 提供给所有组件\\n7. 各个组件用 useContext 获取读写 API\\n\\n代码演示：\\n\\n```tsx\\nimport React, { Dispatch, createContext, useContext, useEffect, useReducer } from 'react';\\n\\nimport './App.css';\\n\\ninterface IPersonState {\\n  books: string[];\\n  movies: string[];\\n}\\n\\ntype IPersonAction = {\\n  type: 'getBooks' | 'getMovies';\\n  payload: string[];\\n};\\n\\nconst initialState: IPersonState = {\\n  books: [],\\n  movies: [],\\n};\\n\\nfunction reducer(state: IPersonState = initialState, action: IPersonAction) {\\n  if (action.type === 'getBooks') {\\n    return { ...state, books: action.payload };\\n  }\\n  if (action.type === 'getMovies') {\\n    return { ...state, movies: action.payload };\\n  }\\n  return state;\\n}\\n\\nexport interface IContextValue {\\n  state: IPersonState;\\n  dispatch: Dispatch<IPersonAction>;\\n}\\n\\nconst Context = createContext<IContextValue | undefined>(undefined);\\n\\nfunction Person() {\\n  const [state, dispatch] = useReducer(reducer, initialState);\\n\\n  return (\\n    <Context.Provider value={{ state, dispatch }}>\\n      <div>\\n        <Books />\\n        <Movies />\\n      </div>\\n    </Context.Provider>\\n  );\\n}\\n\\nfunction Books() {\\n  const { state, dispatch } = useContext(Context)!;\\n  useEffect(() => {\\n    fetch('http://api.kuanglinfeng.com')\\n      .then((response) => response.json())\\n      .then((data) => dispatch({ type: 'getBooks', payload: data.books }));\\n  }, []);\\n\\n  return (\\n    <div>\\n      <h1>我的书籍</h1>\\n      <ul>\\n        {state.books!.map((book) => (\\n          <li key={book}>{book}</li>\\n        ))}\\n      </ul>\\n    </div>\\n  );\\n}\\n\\nfunction Movies() {\\n  const { state, dispatch } = useContext(Context)!;\\n\\n  useEffect(() => {\\n    fetch('http://api.kuanglinfeng.com')\\n      .then((response) => response.json())\\n      .then((data) => dispatch({ type: 'getMovies', payload: data.movies }));\\n  }, []);\\n  return (\\n    <div>\\n      <h1>我的电影</h1>\\n      {state.movies.map((movie) => (\\n        <li key={movie}>{movie}</li>\\n      ))}\\n    </div>\\n  );\\n}\\n\\nfunction App() {\\n  return (\\n    <div className=\\\"App\\\">\\n      <Person />\\n    </div>\\n  );\\n}\\n\\nexport default App;\\n```\\n\\n如何对 reducer 进行拆分？\\n\\n答：可将 reducer 写成多个对象的形式，合并所有的子 reducer 时只需要 `{...reducer1, ...reducer2, ...}` 即可\\n\",\"wordCount\":121},{\"id\":\"1642119396\",\"title\":\"Icon 的所有方案\",\"date\":\"2020-07-21\",\"tags\":[\"icon\"],\"fileName\":\"Icon 的所有方案.md\",\"content\":\"\\n## icon 的各种做法\\n\\n1. img 法\\n2. background 法\\n3. background 合一法\\n4. font 法\\n5. svg-symbol 法\\n6. css 就是干法\\n\\n### img 法\\n\\n1. 搞一张图片\\n2. 使用`<img src=\\\"图片路径\\\"/>`来使用图片\\n3. 通过其它 css 属性来控制图片的大小，位置等\\n\\n优点：可以利用图片默认自动缩放的特性，通过仅设置宽度或者高度来改变图片的大小\\n\\n### background 法\\n\\n1. 搞一张图片\\n2. 利用 css 属性`background: url(./image.png)`\\n3. 通过其它 css 属性来控制图片的大小，位置等\\n\\n### background 合一法\\n\\n1. 将几张图片拼成一张图，可以用网上的 css sprites generator 工具\\n2. 利用 css 属性`width，height, overflow, background-position`来显示某一张图片\\n\\n### font 法\\n\\n使用 icon-font，字体即图标，图标即字体。常用网站：http://iconfont.cn\\n\\n注意：一般来说，字体图标的 Entity Number 一般都以`&#xe6`开头，因为这一段范围通常不表示任何字符\\n\\n- inconfont 的 HTML 形式（对应 iconfont.cn 里的 unicode 功能）\\n\\n用法：\\n\\n1. 在样式里引入@font-face\\n\\n```css\\n@font-face {\\n  font-family: 'iconfont'; /* project id 1958405 */\\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\\n  src:\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\\n}\\n```\\n\\n2. 使用字体对应的 Entity Number（unicode）并指定 font-family\\n\\n```html\\n<div style=\\\"font-family: iconfont;\\\">&#xe600;</div>\\n```\\n\\n- inconfont 的 CSS 形式（对应 iconfont.cn 里的 Font class 功能）\\n\\n1. 在样式里引入@font-face，并使用伪类指定对应 iconfont 的 Entity Number\\n\\n```css\\n@font-face {\\n  font-family: 'iconfont'; /* project id 1958405 */\\n  src: url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot');\\n  src:\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.eot?#iefix') format('embedded-opentype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff2') format('woff2'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.woff') format('woff'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.ttf') format('truetype'),\\n    url('//at.alicdn.com/t/font_1958405_gp6ql65yxke.svg#iconfont') format('svg');\\n}\\n.xxx:before {\\n  content: '\\\\e600';\\n}\\n```\\n\\n2. 指定 font-family 和伪类\\n\\n```html\\n<div class=\\\"xxx\\\" style=\\\"font-family: iconfont;\\\"></div>\\n```\\n\\n### svg-symbol 法\\n\\n这种方式是最推荐的做法。与以上方式相比有如下特点：\\n\\n1. 支持多色图标，不再受单色限制\\n2. 通过一些技巧，支持像字体那样，通过 font-size，color 来调样式\\n3. 兼容性较差，支持 ie9+即现代浏览器\\n4. 浏览器渲染 svg 的性能一般，还不如 png\\n\\n使用步骤：\\n\\n1. 从 iconfont.cn 上拷贝项目下生成的 symbol 代码\\n\\n```js\\n//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js\\n```\\n\\n2. 加入通用 css 代码（引入一次就行）\\n\\n```html\\n<style type=\\\"text/css\\\">\\n  .icon {\\n    width: 1em;\\n    height: 1em;\\n    vertical-align: -0.15em;\\n    fill: currentColor;\\n    overflow: hidden;\\n  }\\n</style>\\n```\\n\\n3. 挑选相应的图标并获取类名，应用于页面\\n\\n```html\\n<svg class=\\\"icon\\\" aria-hidden=\\\"true\\\">\\n  <use xlink:href=\\\"#icon-xxx\\\"></use>\\n</svg>\\n```\\n\\n### 「CSS 就是干」法\\n\\n纯 css 技巧来实现 icon。\\n\\n推荐一个网站，这个网站是一个设计师写的，全是用 css 实现的 icon。\\n\\nhttps://cssicon.space\\n\",\"wordCount\":481}]");export{n as a};
